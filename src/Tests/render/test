0.7071  -0.4082 0.5774  0       
0       0.8165  0.5774  0       
-0.7071 -0.4082 0.5774  0       
0       0       -5.196  1       


Хотел бы напомнить, что мы занимаемся написанием игр, а не исследованием психологчиески абстрактного мышления. Замечу, что любая архитектура - это лишь плод работы человеческого мозга (проектированием чаще всего занимается один человек). Так что все ошибки проектирования - это чаще всего ошибки именно человеческие, а не компьютерные.  Фактически любая хорошая не элементарня архетектура вводит лес (или что гораздо лучше систему) формальностей. Из вышесказанного следует: если хочешь понять архитектуру - пойми её архитектора. Пусть это звучит достаточно банально - большинство, я уверен, это пропустят мимо ушей - но это так, как не верти. 

Далее по статье. Сосбственно здесь пойдёт моё понимание смысла проектирования. И поэтому следующие идеи могут быть субъективными. Я вообще не могу понять - зачем программисту одной задачи лезть в код программиста другой задачи. На мой взгляд рядовой программист должен работать с архитектором (проектировщиком), и высокоуровневые решения об устойчивости и гибкости архетектуры на данном уровне абстракции должны приниматься только этой парой: программист - архитектор. По привединому примеру: я бы разделил понятия графической, физической, звуковой. и т.п. моделей. Каждый модуль (иерархия, абстракция) пишется как отдельная система с использованием [b]жёстко ограниченой[/b] базовой архитектуры классов и функций (стандартные списки, распределение памяти на низком уровне, работа с файлами, и т.д.). Для каждого программиста (или группы, если задача достаточно большая) определяется жёсткий интерфейс задачи. И не в коем случае никаких красивых расширяемых иерархий.  Если задача даётся группе, то идёт опять же жёсткое разделение обязянностей по задачам и выделение отдельного интерфейса работы каждому. Иначе имеем головную боль... А ещё великолепный лозунг: "С утра пришёл - обновись. А вдруг кто-то вечером что-то изменил". 

Хотелось бы узнать: как автор статьи отностится к интерфейсу OpenGL и его расширяемости (которая кстати присутствует даже в жёсткой архитектуре)?

И последнее: проектирование - это логика и баланс. Если не будет первого - архитектура развалится, не будет второго - архитектура будет не дееспособна. А пример по поводу GDIShapt и прочего сам по себе глуп. Как может объект просто рисоваться. Это всё равно, что сказать человеку: "Иди". Вопрос: куда? по какой поверхности? зачем? Рисоваться можно куда-то и с какими-то свойствами но не просто взять и нарисоваться. [b]Так что архитектура - это логика и баланс[/b] А не гибкость вседозволенность.

[b]aruslan[/b]
Опять же по частям: я не услышал главного: предложенная тобой схема - это на самом деле отображение интерфейсов или нет? Если нет. То если можно по-подробнее. Я всё же не могу понять зачем это нужно.

>Итак, вы предоставили все решать, например, мне (как проектировщику графической системы).
>А я решил, что негоже вам вообще анимировать что-либо в сцене.

Есть такое понятие, как [b]техническая задание[\b]. Я оговариваю с тобой что ты должне выполнить в своей системе и интерфейс, по которому я буду производить интеграцию. Так что если анимация не оговорена - её и не будет. 

Теперь предположи у нас есть интерфейс узла и интерфейс модели. 

//далее скрытая часть, не доступная игровым программистам, написанная разработчкиом графической системы

class RenderInterface;
class SceneNode;

class Model
{
  friend class SceneNode;
  public:
          virtual int* GetInterfaces () const = 0;

  protected:
           virtual void Draw (RenderInterface&,SceneNode&) = 0;
};

class SceneNode
{
  public:
               void  Scale (const Vector3&);
               void  Rotate (const Vector3&,float angle);
               void Translate (const Vector3&);

               void BindModel (Model&);
                void UnbindModel ();

                void Draw (RenderInterface&);

                       //и т.д.

  private:
          uint mGameID; //к примеру жёсткий идентификатор крыла
};

//далее то, что видит игровой программист

typedef int MODEL;
typedef int NODE;
typedef int SCENE;

MODEL LoadModel (const char*file_name);
void     DeleteModel (MODEL);

NODE  CreateNode (NODE owner,MODEL mdl);
NODE  GetNode (NODE owner,uint game_id);
void    DeleteNode (NODE);

void   TranslateNode (NODE,const Vector3&);
void   RotateNode (NODE,const Vector3&,float);

 //и т.д.

Так вот: данная система работает даже в сетевом варианте. Прошу прощения что это всего лишь набросок и безусловно готовой программой его назвать не в коем разе нельзя. Но я думаю ты понял смысл. заметь, я обошёлся своими силами без применения кодогенератора. А как по мне: то проектировщик для того и нужен, чтобы координировать и синхронизировать,  да писать интерфейсы. Я, например, (субъективно) никогда не отдам процесс проектирования машине. 

Кстати приемром автоматического проектирования может служить MFC AppWizard. Но он для игр, опять же субъективное мнение, не годен. 