#ifndef __MISC_RB_TREE__
#define __MISC_RB_TREE__

#include <types.h>

/////////////////////////////////////////////////////////////////////////////////////////////
///Красно - чёрное бинарное дерево
/////////////////////////////////////////////////////////////////////////////////////////////
class RedBlackTree
{
  protected:
    struct  mapnode_t;
    friend  struct RedBlackTree::mapnode_t;

  public:

                   RedBlackTree ();

            enum Colors {
              RED = 1, BLACK = 0
            };        

/////////////////////////////////////////////////////////////////////////////////////////////
///Количество
/////////////////////////////////////////////////////////////////////////////////////////////
        int         count  () const { return mCount; }

/////////////////////////////////////////////////////////////////////////////////////////////
///Добавление / удаление
/////////////////////////////////////////////////////////////////////////////////////////////
        void        insert (mapnode_t&);
        void        erase  (mapnode_t&);

/////////////////////////////////////////////////////////////////////////////////////////////
///Первый / последний / root
/////////////////////////////////////////////////////////////////////////////////////////////
        mapnode_t&  GetMin   () const { return mRoot ? GetMin (*mRoot) : mNull; }
        mapnode_t&  GetMax   () const { return mRoot ? GetMax (*mRoot) : mNull; }
        mapnode_t&  GetRoot  () const { return mRoot ? *mRoot : mNull; }

/////////////////////////////////////////////////////////////////////////////////////////////
///Наименьший - наибольший    
/////////////////////////////////////////////////////////////////////////////////////////////
        mapnode_t&  GetMin   (const mapnode_t& x) const;
        mapnode_t&  GetMax   (const mapnode_t& x) const;

  protected:
/////////////////////////////////////////////////////////////////////////////////////////////
///Обмен данными
/////////////////////////////////////////////////////////////////////////////////////////////
    virtual  void       swap    (mapnode_t& dest,mapnode_t& src) = 0 {} 

/////////////////////////////////////////////////////////////////////////////////////////////
///Изменение корня
/////////////////////////////////////////////////////////////////////////////////////////////
            void        SetRoot  (mapnode_t& node) { mRoot = &node; }

  protected:
            void        reset    () { mRoot = NULL; mCount = 0; }

  private:
/////////////////////////////////////////////////////////////////////////////////////////////
///Реализация дополнительных методов
/////////////////////////////////////////////////////////////////////////////////////////////
    void          LeftRotate  (mapnode_t*);
    void          RightRotate (mapnode_t*);
    void          DeleteFixup (mapnode_t*);
    mapnode_t*    successor   (mapnode_t*);

  private:
    static mapnode_t   mNull;
    mapnode_t*         mRoot;
    int                mCount;
};

/////////////////////////////////////////////////////////////////////////////////////////////
///Узел красно - чёрного дерева
/////////////////////////////////////////////////////////////////////////////////////////////
struct RedBlackTree::mapnode_t
{
  mapnode_t *left, *right, *parent;
  int       color;

  mapnode_t&  IterNext () const;
  mapnode_t&  IterPrev () const;

  mapnode_t&  GetMin   () const;            
  mapnode_t&  GetMax   () const; 

  bool        valid    () const { return this && this != &mNull; }
  operator    bool     () const { return valid (); }

              mapnode_t (): parent (NULL), left (&mNull), right (&mNull), color(BLACK) {}
              mapnode_t (mapnode_t* p,mapnode_t* l,mapnode_t* r,int c): parent (p), left (l), right (r), color(c) {}
};


#endif