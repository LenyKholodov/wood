
                         ПО КНИГЕ ГЕРБЕРТА ШИЛДТА















                           ┌───────────────╖
                           │               ║
                           │    ╔══════╕   ║
                           │    ║      ╘═══╝
                           │    ║
                           │    ║
                           │    ║
                           │    ║
                           │    ║
                           │    ║      ┌───╖
                           │    ╙──────┘   ║
                           │               ║
                           ╘═══════════════╝



                    ДЛЯ ПРОФЕССИОНАЛЬНЫХ ПРОГРАММИСТОВ






                                ЧАСТЬ 1.













                             Москва, 1989 г.


                         С О Д Е Р Ж А Н И Е


Предисловие ......................................................  7

ГЛАВА 1. ИСЧЕЗАЮЩИЕ И ИЕРАРХИЧЕСКИЕ МЕНЮ .........................  9
Что такое исчезающие и иерархические меню? ....................... 11
Работа видеоадаптеров ............................................ 13
Доступ к экрану через BIOS ....................................... 18
Использование int86() ............................................ 19
Сохранение части экрана .......................................... 21
Восстановление экрана ............................................ 24
Создание исчезающих меню ......................................... 26
Высвечивание меню ................................................ 28
Высвечивание рамки ............................................... 31
Ввод выбора пользователя ......................................... 32
Функция popup() .................................................. 39
Общий обзор ...................................................... 42
Прямой доступ к видео памяти ..................................... 55
Определение расположения видео памяти ............................ 56
Изменение save_video() и restore_video() ......................... 58
Создание иерархических окон ...................................... 77
Фреймы меню ...................................................... 78
Создание фрейма меню ............................................. 79
Функция pulldown() ............................................... 82
Восстановление экрана ............................................ 85
Простая программа, использующая процедуру pulldown ............... 86


ГЛАВА 2. ВСПЛЫВАЮЩИЕ ОКНА ....................................... 108
Теория всплывающих окон ......................................... 109
Оконные структуры ................................................112
Создание структуры окна ..........................................114
Активирование и деактивирование окна .............................117
Оконные функции ввода/вывода .....................................121
Функция позиционирования курсора в окне ..........................122
Функция window_getche() ..........................................124
Функция window_gets() ............................................128
Функция window_putchar() .........................................130
Функция window_puts ..............................................133
Дополнительные функции управления экраном ........................134
Изменение размера и положения окна во время выполнения программы .139
Создание прикладных программ, использующих всплывающие окна ......147
Программа преобразов. из десят. в шестнадц. систему счисления ....148
Калькулятор с четырьмя функциями .................................150
Всплывающая записная книжка ......................................155
Совместное использование всех программ ...........................159
Модификации программ управления окнами ...........................204


ГЛАВА 3. ПРОГРАММЫ, ОСТАЮЩИЕСЯ РЕЗИДЕНТНЫМИ ......................210
Что такое TSR-программа? .........................................212
Прерывания в семействе процессоров 8086 ..........................213
Прерывания против DOS и BIOS: Tревога в стране DOS ...............214
Модификатор функций прерывания Турбо Си ..........................216
Общий план TSR-программы .........................................218
Использование прерывания печати экрана ...........................219
Раздел инициализации .............................................220
Прикладная часть TSR-программы ...................................225
Использование прерывания по нажатию клавиши ......................254
Буфер символов, введенных с клавиатуры ...........................256
Функция инициализации ............................................258
Прикладная часть TSR-программы ...................................260
Тайна 28-го прерывания ...........................................296
Проблемы при создании TSR-программ ...............................298


ГЛАВА 4. ГРАФИКА .................................................299
Видеорежимы и цветовая палитра ...................................301
Запись точки растра ..............................................305
Работа адаптеров CGA/EGA в графическеом режиме ...................306
Вычерчивание линий ...............................................311
Изображение и закрашивание прямоугольников .......................316
Вычерчивание окружностей .........................................318
Простейшая тестовая программы ....................................322
Сохранение и загрузка графических изображений ....................333
Дублирование части экрана ........................................338
Вращение точки в плоскости экрана ................................341
Вращение обьекта .................................................345
Сборка подпрограмм ...............................................364


ГЛАВА 5. ВИДЕОИГРЫ ...............................................410
Спрайты ..........................................................411
Поле игры ........................................................413
Мультипликация на экране .........................................413
Мультипликация спрайта ...........................................429
Организация данных в видеоиграх ..................................434
Контроль границ ..................................................434
Изменение цвета ..................................................435
Табло счета активного противника .................................436
Разработка видеоигры .............................................437
Тело главной программы ...........................................443
Программа генерации движения спрайта компьютера ..................452
Программа контроля касания спрайтов ..............................460
Полный текст программы игры TAG ..................................461
Некоторые соображения по возможной модификации программы .........490


















               Предисловие
     -----------------------------------------------------------------

          Если вы  хотите   создавать   программы   мирового   уровня,
     написанные на Си, то эта книга - для вас!

          Меня зовут Герб Шилдт.  Я ветеран программирования во многих
     компаниях и программирую на Си более десяти лет.  Перед тем,  как
     начать  писать  эту  книгу,  я изучил большое количество удачного
     программного обеспечения,  пытаясь определить,  какие  черты  они
     имеют  в отличие от менее удачных программ. Я  хотел понять,  что
     делает одни программы более удачными, чем другие, аналогичные им.
     После  этого  прояснились  общие  черты.  Удачные  программы были
     написаны  людьми,  которые  не  только  имели  крепкую  хватку  в
     специальной  области,  но  и  в совершенстве освоили оборудование
     компьютера,   включая   операционную   систему    и    аппаратное
     обеспечение.  Только программист,  осуществляющий полный контроль
     над  ними  может  писать  программы  с  дружелюбным   интерфейсом
     пользователя  которые эффективно выполняются и дают пользователям
     большую гибкость.

          Эта книга открывает многие секреты,  используемые  мастерами
     программирования  для достижения профессиональных результатов.  С
     ее  помощью  вы  расширите  подходы  и  методы,  которые   делают
     программы  интересными.  После прочтения книги вы будете способны
     писать  программы,    которые     заслужат     внимание.    Здесь
     рассматриваются следующие вопросы:

     # Прямой доступ к памяти экрана для быстрого отображения
     # Исчезающие и иерархические (popup и pulldown) меню
     # Процедуры работы с окнами
     # Завершение программ и оставление их в памяти
     # Интерфейс с мышью
     # Графические функции, включая вращение объектов
     # Языковые интерпретаторы
     # Передача файлов через последовательный порт

          Эта книга для  любого  и  каждого  программиста  на  Си,  от
     новичка  до  профессионала.  Даже  если вы начинающий,  вы можете
     использовать функции и программы  из  этой  книги  без  понимания
     отдельных деталей их работы.  Более подготовленные читатели могут
     использовать эти программы как основу для своих приложений.

          Исходные тексты этой  книги  соответствуют  стандарту  ANSI,
     кроме  некоторых функций,  специфичных для ПК.  Таким образом все
     эти программы можно компилировать на любом  компиляторе,  который
     поддерживает стандарт. Я использовал для их разработки Турбо Си и
     Microsoft Си.

          Некоторые из  многих  полезных  и   интересных   функций   и
     программ, содержащихся в книги достаточно длинны.  Если вы, как и
     я,  возможно хотите использовать их,  но вам лень набивать их  на
     компьютере и потом выискивать неизбежные опечатки,  то для такого
     случая я предоставляю исходные коды,  содержащиеся в этой  книге,
     на дискете.  Цена услуги - 24.95$.  Заполните приложенную форму и
     пошлите  ее  по  указанному  адресу  вместе  с   оплатой.   Можно
     использовать карточки MasterCard и Visa.

                          ГЛАВА 1.
                          --------
               Исчезающие и иерархические меню.
     -----------------------------------------------------------------

          Одна из наиболее очевидных черт  профессионально  написанных
     программ - это использование исчезающих и иерархических меню. При
     правильном использовании,  эти меню дают  программам  дружелюбие,
     которое  пользователи  от  них  и  ожидают.  Хотя  по  существу и
     простые,  и  исчезающие,  и   иерархические   меню   представляют
     некоторые трудности в программировании.

          Создание исчезающих  и  иерархических  меню  требует прямого
     управления  экраном.  Хотя  основные  программы  меню   полностью
     мобильны,  программы  доступа  к  экрану  зависят от операционной
     системы  и  оборудования  и  не  используют  обычные  функции  Си
     ввода/вывода на консоль.  Программы видео доступа разработаны для
     работы с любым  компьютером,  использующим  ДОС  и  имеющим  BIOS
     операционной  системы  совместимый с IBM.  BIOS-ДОС выбран потому
     что он широко используется,  но вы можете применить основные идеи
     и в других системах.

          Даже  если   вас   сейчас   не   интересуют   исчезающие   и
     иерархические меню,  то вам следует прочитать часть этой главы, в
     которой  обсуждаются  видеоадаптеры,  знание многих основных идей
     необходимо для понимания последующих глав.



               Что такое исчезающие и иерархические меню?
     -----------------------------------------------------------------

          Важно понимать  что  такое исчезающие и иерархические меню и
     чем  они  отличаются  от  стандартных  меню.  При   использовании
     стандартных  меню  экран  очищается или сдвигается,  и появляется
     меню.  Когда выбор сделан, экран опять очищается или сдвигается и
     программа продолжается. Выбор выполняется по номеру или по первой
     букве каждой альтернативы.

          Когда используется исчезающее или иерархическое меню, то оно
     покрывает прямо  содержимое  экрана.  После выбора режима,  экран
     возвращается в предыдущее состояние. Вы выбираете нужный режим из
     меню  одним  из  двух  способов:  (1)  нажимая  активную клавишу,
     которая является буквой или номером, связанным с выбором, или (2)
     используя    клавиши   управления   курсором   для   передвижения
     подсвеченного поля  и   клавишу   Ввод.   Обычно   текущее   поле
     показывается   в   инверсном   виде.   Основная   разница   между
     стандартными меню и исчезающими и иерархическими меню в  том, что
     стандартное меню прерывает программу.  Исчезающие и иерархические
     меню только приостанавливают текущие действия программы.  С точки
     зрения  пользователя  стандартное меню - прерывание концентрации,
     тогда  как  исчезающее  меню  -   просто   легкая   приостановка,
     концентрация внимания пользователя не нарушена.

          Разница между  исчезающими  и  иерархическими  меню  проста.
     Только одно исчезающее меню может быть на экране в  данный момент
     времени.  Оно используется когда меню имеет только один уровень в
     глубину,  это бывает,  когда выбор из меню не имеет подвыборов. С
     другой  стороны  несколько  иерархических меню могут быть активны
     одновременно.  Они используются когда выбор из одного меню  может
     потребовать  использования другого меню для определения некоторых
     альтернатив. Например, вы можете использовать иерархическое меню,
     если   вы   пишете  программу,  которая  определяет  фрукт.  Если
     пользователь выбрал "яблоко",  следующее меню предлагает  выбрать
     цвет   яблока,   а   третье   меню  высвечивает  яблоки,  которые
     удоволетворяют предыдущим выборам.

          Вы можете   представлять   исчезающее   меню   просто    как
     иерархическое  меню,  которое  не  имеет  подменю,  но разработка
     отдельных процедур для этих типов меню имеет то преимущество, что
     иерархическое  меню  требует значительно более сложной программы,
     чем простое исчезающее меню.

          Хотя имеется много способов  расположения  меню  на  экране,
     функции,  разработанные  в  этой  главе имеют наиболее общий вид.
     Этот метод помещает очередное  поле  меню  на  новую  строку  под
     первым полем.



               Работа видеоадаптеров.
     -----------------------------------------------------------------

          Из-за того,  что создание исчезающих  и  иерархических  меню
     требует  прямого  управления  экраном,  важно понимание адаптеров
     дисплея. Три основных типа адаптеров - это  одноцветный  адаптер,
     цветной/графический    адаптер    (CGA)   и   усовершенствованный
     графический адаптер  (EGA).  CGA  и  EGA  могут  иметь  несколько
     режимов   работы,  включая  40-  или  80-  символьный  текст  или
     графические операции.  Эти  режимы  показаны   в   таблице   1-1.
     Программы  меню,  разработанные  в  этой  главе,  разработаны для
     использования  режима  80-символьного  текста,  который  является
     наиболее общим  режимом  для общецелевых применений.  Это значит,
     что видео режим системы должен быть 2,  3 или  7.  Независимо  от
     используемого режима - координаты левого верхнего угла - 0,0.


     Таблица 1-1.
     ------------

     Режим    Тип                    Размеры          Адаптеры
     ---------------------------------------------------------------
      0       текст,ч/б              40*25            CGA,EGA
      1       текст 16 цветов        40*25            CGA,EGA
      2       текст ч/б              80*25            CGA,EGA
      3       текст 16 цветов        80*25            CGA,EGA
      4       графика 4 цвета        320*200          CGA,EGA
      5       графика 4 серых тона   320*200          CGA,EGA
      6       графика ч/б            640*200          CGA,EGA
      7       текст ч/б              80*25            монохромный
      8       графика 16 цветов      160*200          PCjr
      9       графика 16 цветов      320*200          PCjr
     10       графика 4 или 16 цв.   640*200          PCjr,EGA
     13       графика 16 цветов      320*200          EGA
     14       графика 16 цветов      640*200          EGA
     15       графика 4 цвета        640*350          EGA
     --------------------------------------------------------------


          Символы, выводимые  на   экран,   содержатся   в   некоторой
     зарезервированной  области  памяти  на  адаптере  дисплея.  Адрес
     одноцветной информации В0000000H. И CGA, и EGA хранят информацию,
     начиная  с  B80000000H.  (Они различны для того,  чтобы позволить
     использовать раздельно текстовый и  графический  экран  -  но  на
     практике  это  делается редко.) Хотя функции CGA и EGA различны в
     разных режимах, они одинаковы в режимах 2 и 3.

          Каждый символ,  выводимый на экран,  требует два байта видео
     памяти.  Первый байт содержит собственно символ,  второй содержит
     аттрибуты   экрана.   Для   цветного   экрана   байт   аттрибутов
     интерпретируется так,  как показано в таблице 1-2. Если у вас EGA
     или CGA, то по умолчанию принимается режим 3, и символы выводятся
     с байтом аттрибутов 7.  Это значение включает три основных цвета,
     производя для символа белый цвет.  Для переключения  в  инверсный
     режим  небходимо  выключить  три  основных  бита  и  включить три
     фоновых бита, что дает значение 70H.

          Одноцветный адаптер распознает биты мигания и интенсивности.
     К счастью,  он разработан так, что интерпретирует аттрибут 7, как
     нормальный текст (белое на черном) и  70Н  как  инверсное  видео.
     Кстати, значение 1 дает подчеркнутые символы.



     Таблица 1-2
     -----------
     Байт видеоадаптера

          Бит      Двоичная величина     Значение при установке
     ----------------------------------------------------------------
           0             1               голубой основной
           1             2               зеленый основной
           2             4               красный основной
           3             8               малая интенсивность
           4            16               голубой фоновый
           5            32               зеленый фоновый
           6            64               красный фоновый
           7           128               мигающий символ
     ----------------------------------------------------------------

          Каждый адаптер имеет по крайней мере в 4 раза больше памяти,
     чем необходимо для вывода  текста  в  80-символьном  режиме.  Для
     этого есть  две  причины.  Во-первых,  лишняя  память  нужна  для
     графики, (конечно кроме  одноцветного  адаптера).  Во-вторых  это
     позволяет  держать  в  памяти  несколько  экранов  и потом просто
     переключаться между ними по мере  необходимости.  Каждая  область
     памяти  называется  видеостраницей и эффект от переключения между
     видеостраницами впечатляющ.  По умолчанию при  инициализации  ДОС
     используется  страница 0,  и виртуально все приложения используют
     страницу 0.  По этой причине она используется  и  в  этой  главе.
     Однако,  вы можете использовать и другие страницы, если захотите.

          Имеется три  способа  доступа  к  видеоадаптеру.  Первый это
     через прерывание ДОС, которое достаточно медленно для исчезающего
     меню.  Второй - это через процедуры BIOS,  которые быстрее,  и на
     быстродействующих машинах,  таких,  как AT  или  PS/2  достаточно
     быстры,  если меню невелики.  Третий способ - это чтение и запись
     прямо в видеопамять,  что происходит  очень  быстро,  но  требует
     большей работы от вас. Эта глава рассматривает два разных подхода
     в видео процедурах.  Один использует BIOS, а другой прямой доступ
     к видеопамяти.



               Доступ к экрану через BIOS
     -----------------------------------------------------------------

          Из-за того,  что  исчезающие  и  иерархические  меню  должны
     сохранять   информацию  с  того  места  экрана,  на  котором  они
     расположены, и восстанавливать его после выбора,  вы должны иметь
     процедуры,  которые  сохраняют  и  загружают часть экрана.  Метод
     сохранения и восстановления части экрана,  рассматриваемый в этом
     разделе связан с вызовами двух встроенных в BIOS функций, которые
     читают и записывают символы на экран.

          Как вы знаете,  вызовы BIOS  могут  быть  очень  медленными.
     Однако,  они  (более  или  менее)  гарантируют  работу  на  любом
     компьютере,  который имеет BIOS,  совместимый с  IBM,  даже  если
     аппаратура  экрана  другая.  Позже  в этой главе вы узнаете,  как
     выполнять прямой  доступ  к  видеопамяти  на  IBM   PC   и   100%
     совместимых   машинах   для   того,   чтобы   увеличить  скорость
     выполнения. Однако,  использование прямого доступа к  видеопамяти
     снижает в некоторой степени переносимость, так как требуется 100%
     совместимость компьютера с IBM PC.  Программы меню, основанные на
     BIOS следует использовать в применениях,  которые требуют большей
     мобильности.



               Использование int86()
     -----------------------------------------------------------------

          Вызовы BIOS  используют  программные прерывания.  BIOS имеет
     несколько различных прерываний для разных целей.  Одно из них  мы
     будем использовать для доступа к экрану. Это прерывание 16 (10Н),
     которое используется для доступа к дисплею. (Если вы не знакомы с
     доступом к BIOS, то вы найдете хорошее описание в моей книге "Си:
     Полный справочник",  Беркли, 1987). Как и многие прерывания BIOS,
     прерывание    16   имеет   несколько   режимов,   выбор   которых
     выполняется по значению  регистра  AH.  Если  функция  возвращает
     значение,  то  оно  заносится  в регистр AL.  Однако,  иногда для
     возвращения нескольких значений используются другие регистры. Для
     доступа  к  прерываниям BIOS вам придется использовать функцию Си
     int86(). (Некоторые компиляторы могут называть эту функцию другим
     именем,   но   MicroSoft  C  и  Турбо  Си  называют  ее  int86().
     Последующие рассуждения ориентированы на эти трансляторы,  но  вы
     можете их обобщить.

         Функция int86() имеет следующую форму:

      int int86(num,inregs,outregs)
      int num; /* номер прерывания */
      union REGS *inregs; /* входные значения регистров */
      union REGS *outregs; /* выходные значения регистров */

         Функция int86() возвращает значение  регистра  АХ.  Тип  REGS
     описывается в заголовке DOS.H. Этот тип показан здесь так, как он
     определен в Турбо Си, однако, он аналогично определен в MisroSoft
     C и в других компиляторах.

     struct WORDREGS {
      unsigned int ax, bx, cx, dx, si, di, cflag, flags;
     };
     struct BYTEREGS {
     unsigned char al, ah, bl, bh, cl, ch, dl, dh;
     };
     union REGS {
     struct WORDREGS x;
     struct BYTEREGS h;
     };

          Как вы можете видеть,  REGS - это объединение двух структур.
     Использование структуры WORDREGS позволяет рассматривать регистры
     ЦП как 16-битные числа.  BYTREGS дает вам доступ к  отдельным  8-
     битным регистрам.  Например, для доступа к прерыванию 16, функции
     5, вы должны использовать следующую последовательность.

     union REGS in,out;

     in.h.ah=5;
     int86(16,&in,&out);



               Сохранение части экрана.
     -----------------------------------------------------------------

          Для сохранения содержимого экрана,  должно быть прочитано  и
     запомнено текущее значение каждой позиции экрана.  Для считывания
     символа с определенной позиции  экрана,  используется  прерывание
     16,  функция  8,  которая  возвращает  символ  и  связанный с ним
     аттрибут текущей  позиции  курсора.  Для  считывания  символа   с
     определенного  места  экрана,  вы  должны  иметь способ установки
     курсора.  Хотя некоторые компиляторы Си поддерживают эту функцию,
     многие ее   не  имеют.  Тем  не  менее  показанная  ниже  функция
     goto_xy() может быть использована.  Она использует прерывание 16,
     функцию  2  с  координатой  столбца в DL и координатой ряда в DH.
     Видеостраница задается  в  ВН   (используется   страница   0   по
     умолчанию).

     /* установка курсора в x,y */
     void goto_xy(x,y)
     int x,y;
     {
      union REGS r;

      r.h.ah=2; /* функция установки курсора */
      r.h.dl=y; /* координата колонки       */
      r.h.dh=x; /* координата строки        */
      r.h.bh=0; /* видео страница           */
      int86(0x10,&r,&r);
     }

          Прерывание 16,  функция  8  возвращает  символ  из   текущей
     позиции курсора  в  AL и его атрибут в AH.  Функция save_video(),
     показанная здесь,  считывает часть экрана, сохраняет информацию в
     буфер, и очищает эту часть экрана.

     /* сохранение части экрана */
     void save_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      union REGS r;
      register int i,j;

      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
          goto_xy(j,i);
          r.h.ah=8; /* функция чтения символа   */
          r.h.bh=0; /* видео страница           */
          *buf_ptr++ = int86(0x10,&r,&r);
          putchar(' '); /* очистка экрана */
        }
     }

Первые четыре параметра save_video определяют координаты верхнего
левого и правого  нижнего  угла  сохраняемой  области.   Параметр
buf_ptr  это  целый указатель на область памяти, которая содержит
информацию.  Она должна быть достаточно большой, чтобы разместить
всю информацию, считанную с экрана.

Программы  в этой главе размещают буфер динамически, но вы можете
использовать  любую  другую  схему,  если  это  важно  для  ваших
приложений.   Не забудьте, однако, что буфер должен существовать,
до тех пор, пока экран не вернется  в  исходное  состояние.   Эта
функция  также чистит область, записывая пробел в каждой позиции.



               Восстановление экрана
     -----------------------------------------------------------------

          Восстановление экрана  после  сделанного  выбора  из   меню,
     заключается просто в записи предварительно запомненной информации
     назад в видео память.  Для того,  чтобы сделать это,  используйте
     прерывание 16, функцию 9, которая требует, чтобы символ был в AL,
     аттрибут в BL,  видео страница в ВН,  а  количество  записываемых
     символов  в  CX  (в  нашем  случае  1).  Функция restore_video(),
     описанная  здесь,  помещает  информацию  из  буфера,  на  который
     указывает  buf_ptr,  на  экран,  заданный  начальными и конечными
     координатами X и Y.

     /* восстановление части экрана */
     void restore_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      union REGS r;
      register int i,j;

      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
          goto_xy(j,i);
          r.h.ah=9; /* функция записи символа   */
          r.h.bh=0; /* видео страница           */
          r.x.cx=1; /* число повторений символа */
          r.h.al=*buf_ptr++; /* символ          */
          r.h.bl=*buf_ptr++; /* атрибут         */
          *buf_ptr++ = int86(0x10,&r,&r);
        }
     }



               Создание исчезающих меню
     -----------------------------------------------------------------

          Функции, создающей  исчезающее  меню,  должна  быть передана
     некоторая информация.  Во-первых, это список предоставляемых меню
     режимов. Поскольку  в  меню  передаются высвечиваемые строки,  то
     простейший путь передачи списка строк в функцию - помещение  их в
     двумерный массив и передача указателя на массив. Как утверждалось
     ранее,  значение  меню  может  быть  выбрано  либо  передвижением
     освещенной  области  на  нужное  поле  и нажатием ВК или нажатием
     клавиши,  указывающей на это поле. Для того, чтобы функция знала,
     какие  клавиши  "горячие"  и  что они обозначают,  ей должны быть
     переданы их имена.  Лучший путь  для  этого  -  передать  строку,
     которая содержит символы "горячих" клавиш в том же порядке, что и
     строки меню.

          Функция popup() должна также знать как много режимов в меню,
     и поэтому это число должно быть передано  ей.  Она  должна  также
     знать  где  расположить  меню,  то  есть  нужны координаты X и Y.
     Наконец, в некоторых ситуациях может  быть  желательным  помещать
     меню  в  рамку,  а  в других - нет.  Поэтому должно быть передано
     значение  рамка  включена/выключена.  Для  того,   чтобы   начать
     разработку функции popup() нам нужно описание :

     /* высветить исчезающее меню и возвратить выбор */
     int popup(menu,keys,count,x,y,border)
     char *menu[];  /* текст меню */
     char *keys;    /* горячие клавиши */
     int count;     /* число режимов */
     int x,y;       /* координаты левого верхнего угла */
     int border;    /* если 0 то без рамки */

          Функция popup() делает следующее :

     # Сохраняет область экрана под меню
     # Высвечивает рамку, если надо
     # Высвечивает меню
     # Получает ответ пользователя
     # Восстанавливает экран в исходное состояние

          Две из  этих  целей  были  достигнуты   в   save_video()   и
     restore_video(),   описанных   в   предыдущем   разделе.  Давайте
     рассмотрим как достигнуть три оставшиеся.



               Высвечивание меню.
     -----------------------------------------------------------------

          Для того,  чтобы высветить  меню,  необходимо  помнить,  что
     popup  получает  указатель  на  массив указателей на строки.  Для
     высвечивания отдельных строк вы  просто  индексируете  указатель,
     как  массив.  Каждый  элемент  в  массиве  является указателем на
     соответствующий элемент меню.  Следующая  функция  display_menu()
     высвечивает каждый элемент меню.

     /* высвечивание меню на своем месте */
     void display_menu(menu,x,y,count)
     char *menu[];
     int x,y,count;
     {
      register int i;

     for(i=0;i<count;i++,x++) {
       goto_xy(x,y);
       printf(menu[i]);
       }
     }

          Как вы можете видеть,  эта  функция  получает  указатель  на
     массив  строк,  которые  надо  вывести,  координаты начала меню и
     количество строк в меню.

          В дальнейшем  простейший  способ  создать  двумерный  массив
     символов,  который содержит строки меню - это создание переменной
     в общем виде:

     char *<имя меню> [] = {
     "первая строка",
     "вторая строка",
      .
      .

      .
     "N-ая   строка" };

          Это описание   автоматически   заставляет   компилятор    Си
     поместить строки в таблицу строк.  Переменная указывает на первый
     символ первой строки в таблице.  Например,  это описание  создает
     переменную fruit (фрукт), которая указывает на "Я" в "Яблоко".

     char *fruit[] = {
      "Яблоко",
      "Апельсин",
      "Груша",
      "Грейпфрут",
      "Малина",
      "Клубника"
     };





               Высвечивание рамки
     -----------------------------------------------------------------
          Если нужна рамка,  то можно воспользоваться  нижеприведенной
     программой для  вывода рамки вокруг меню с заданными координатами
     левого верхнего и правого нижнего углов.  Она использует символы,
     которые  являются частью стандартного набора символов на машинах,
     совместимых с IBM. Если вы хотите, вы можете выбрать другие.

     void draw_border(startx,starty,endx,endy)
     int   startx,starty,endx,endy;
     {
        register int i;
        for(i=startx+1;i<endx;i++) {
          goto_xy(i,starty);
          putchar(179);
          goto_xy(i,endy);
          putchar(179);
        }
        for(i=starty+1;i<endy;i++) {
          goto_xy(startx,i);
          putchar(196);
          goto_xy(endx,i);
          putchar(196);
        }

        goto_xy(startx,starty); putchar(218);
        goto_xy(startx,endy  ); putchar(191);
        goto_xy(endx  ,starty); putchar(192);
        goto_xy(endx  ,endy  ); putchar(217);
     }



               Ввод выбора пользователя
     -----------------------------------------------------------------

          Как утверждалось,  пользователь может вводить выбор одним из
     двух способов.  Во-первых с помощью клавиш СТРЕЛКА ВНИЗ и СТРЕЛКА
     ВВЕРХ может переместить освещение на строку и нажать Ввод  для ее
     выбора, (Обычно освещение строки выполняется в инверсном режиме.)
     Освещенную строку также можно передвигать пробелом. Второй способ
     это  нажатие  клавиши,  связанной с выбором.  Функция get_resp(),
     показанная здесь, достигает этих целей.

     /* ввести выбор пользователя */
     get_resp(x,y,count,menu,keys)
     int x,y,count;
     char *menu[];
     char *keys;
     {
      union inkey {
        char ch[2];
        int i;
      } c;
     int arrow_choice=0,key_choice;

     y++;
     /* осветить первый выбор */
     goto_xy(x,y);
     write_video(x,y,menu[0],REV_VID);

     for(;;) {
      while(!bioskey(1)); /* ждать нажатия */
      c.i=bioskey(0);

     /* вернуть выбор в номальный режим */
     goto_hy(arrow_choice,y);
     write_video(x+arrow_choice,y,
             menu[arrow_choice],norm_vid);
     if(c.ch[0]) { /* обычная клавиша */
      key_choice= is_in(keys,tоlower(c.ch[0]));
     if(key_choice) return key_choice-1;
     switch(c.ch[0]) {
       case '\r' : return arrow_choice;
       case ' '  : arrow_choice++;
                   break;
      case ESC   : return -1; /* выйти */
        }
     }
     else { /* специальная клавиша */
      switch(c.ch[1]) {
       case 72 : arrow_choice--; /* стрелка вниз */
                 break;
       case 80 : arrow_choice++; /* стрелка вверх */
                 break;

          }
       }
     if(arrow_choice==count) arrow_choice=0;
     if(arrow_choice<0) arrow_choice=count-1;
         /* подсветить выбранную опцию */
      goto_xy(x+arrow_choice,y);
      write_video(x+arrow_choice,y,menu[arrow_choice],REV_VID);
      }
     }


          Kогда get_resp()  начинает  выполняться,  освещается  первое
     значение меню.  Макроопределение REV_VID определяется везде,  как
     70Н, а NORM_VID как 7Н. Клавиша ESCAPE используется для окончания
     работы  с меню.  Значение ESC 27.  После этого программа входит в
     цикл,  ожидающий действий пользователя.  Она  использует  функцию
     bioskey() для того,  чтобы дождаться нажатия клавиши, а затем для
     считывания с этой клавиши. Функция bioskey() специфична для Турбо
     Си. Если вы используете другой транслятор, вы можете использовать
     следующую версию функции.

     /* эмуляция части функции bioskey Турбо Си */
     bioskey(c)
     int c;
     {
      switch(c) {
       case 0: return get_key();
       case 1: return kbhit();
       }
     }

     /* чтение 16 битного скан кода клавиши */
     get_key()
     {
      union REGS r;

      r.h.ah=0;
      return int86(0x16, &r,&r);

          Причина, по  которой вы должны использовать bioskey() вместо
     getchar() состоит в том,  что программа должна иметь  возможность
     считывать  полный  16  битный  скан  код,  генерируемый  нажатием
     клавиши.  Если нажата символьная клавиша,  то символ помещается в
     младшие  8  бит,  а  старшие 8 бит равны 0.  Однако,  если нажата
     специальная клавиша,  такая, как стрелка, младший байт равен 0, а
     старший  содержит  код позиции клавиши.  Коды позиции для стрелки
     вверх и стрелки вниз равны 72 и 80 соответственно. Такие функции,
     как   getchar(),   возвращают   только  код  символа,  и  поэтому
     необходимо получить прямо скан код помимо них.

          Каждый раз  при нажатии стрелки освещенная опция переходит в
     нормальное изображение, а следующая - освещается. Нажатие стрелки
     вниз, в   момент   освещения  крайней  нижней  позиции,  означает
     возвращение  к  первому  значению.  То  же  самое,  но   наоборот
     происходит когда  нажимается  стрелка вверх при освещенной первой
     строке.

          Функция write_video() используется функцией  get_resp()  для
     записи  строки на дисплей в позиции Х,Y с определенным атрибутом.
     Write_video(),  показанная здесь,  используется для вывода строки
     меню  в  инверсном режиме,  если она освещена,  или в нормальном,
     если она не освещена.

     /* вывод строки с определенным атрибутом */
     void write_video(x,y,p,attrib)
     int x,y;
     char *p;
     int attrib;
     {
      union REGS r;
      register int i,j;

      for(i=y; *p; i++) {
       goto_xy(x,i);
          r.h.ah=9; /* функция записи символа   */
          r.h.bh=0; /* видео страница           */
          r.x.cx=1; /* число повторений символа */
          r.h.al=*p++; /* символ          */
          r.h.bl=attrib; /* атрибут         */
          int86(0x10,&r,&r);
       }

          Функция is_in()  возвращает  позицию  "горячей"  клавиши   в
     строке. Если  пользователь  нажал  не ключевую клавишу,  то is_in
     возвращает 0.

     is_in(s,c)
     char *s,c;
     {
      register int i;

      for(i=0; *s; i++)
         if(*s++ == c) return i+1;
      return 0;
     }



               Функция popup()
     -----------------------------------------------------------------

         А теперь,  когда все части созданы,  функция popup может быть
     записана, как это показано здесь.

     /* вывести исчезающее меню и вернуть выбор
        возвращает -2, если меню не может быть создано
        возвращает -1, если пользователь нажал клавишу ESC
        в остальных случаях она возвращает номер выбранной
        альтернативы, начиная с 0 */
     int popup(menu,keys,count,x,y,border)
     char *menu[];  /* текст меню */
     char *keys;    /* горячие клавиши */
     int count;     /* число альтернатив */
     int x,y;       /* координаты левого верхнего угла */
     int border;    /* если 0 то без рамки */
     {
      register int i,len;
      int endx endy choice;
      unsigned int *p;

      if((x>24)||(x<0)||(y>79)||(y<0)) {
       printf(" выход за пределы экрана");
       return -2;
      }
     /* вычисление размеров */
     len=0;
     for(i=0;i<count;i++)
      if(strlen(menu[i]) > len) len=strlen(menu[i]);
     endy=len+2+y;
     endx=count+1+x;
     if((endx+1>24) || (endy+1>79)) {
       printf(" выход за пределы экрана");
       return -2;
      }
     /* размещение памяти для видео буфера */
     p=(unsigned int *)malloc((endx-x+1)*(endy-y+1));
      if(!p) exit(1); /* Вы можете здесь сами обработать ошибку */

     /* сохранение части экрана */
     void save_video(startx,endx,starty,endy,p);

     if(border) draw_border(x,y,endx,endy);

     /* высвечивание меню на своем месте */
     void display_menu(menu,x,y,count);

     /* ввести выбор пользователя */
     choice=get_resp(x,y,count,menu,keys)

     /* восстановление части экрана */
     void restore_video(startx,endx,starty,endy,p);
     free(p);
     return choice;
     }

          Как вы  можете  видеть,  popup()  проверяет выход за пределы
     экрана и слишком большой размер меню.  Она  возвращает  -2,  если
     возникла  одна  из  этих  ситуаций.  Из-за  того,  что get_resp()
     возвращает -1,  при  нажатии  клавиши  ESC,   возвращение   этого
     значения  функцией  popup следует рассматривать как "уничтожение"
     меню.  Если пользователь сделал выбор,  то возвращаемое  значение
     будет в пределах от 0 до count-1 с соответствием первому значению
     меню 0.  Как уже  указывалось,  popup()  использует  динамическое
     размещение памяти для обеспечения временной памяти для информации
     об экране.  Обычно это  лучший  подход,  но  вы  можете  свободно
     изменить его, если это важно для вашего приложения.



               Общий обзор
     -----------------------------------------------------------------

          Простая программа,   показанная   здесь,   использует    все
     программы, разработанные для использования исчезающих меню. Вы не
     видели только функции cls(),  которая  очищает  экран.  Некоторые
     трансляторы Си не имеют функции для этого,  и если это так, то вы
     не можете использовать следующую программу  (в чистом виде).

     /* процедура исчезающего меню для работы в текстовом режиме */
     #include "stdio.h"
     #include "dos.h"
     #include "stdlib.h"

     #define BORDER 1
     #define ESC 27
     #define REV_VID 0x70
     #define NORM_VID  7

     void save_video(),restore_video();
     void goto_xy(),cls(),write_video();
     void display_menu(),draw_border();

     char *fruit[] = {
      "Яблоко",
      "Апельсин",
      "Груша",
      "Грейпфрут",
      "Малина",
      "Клубника"
     };

     char *color[]={
      "Красный",
      "Желтый",
      "Оранжевый",
      "Зеленый"
     };

     char *apple_type[] = {
      "Красный деликатес",
      "Джонатан",
      "Белый налив",
      "Антоновка"
     };

     main()
     {
      int i;

     cls();
     goto_xy(0,0);
     for(i=0;i<25;i++)
      printf("Это тест исчезающего меню\n");
     popup(fruit,"яагрмк",6,1,3,BORDER);
     popup(color,"кжоз",4,5,10,BORDER);
     popup(apple_type,"кдба",4,10,18,BORDER);
     }

     /* вывести исчезающее меню и вернуть выбор
        возвращает -2, если меню не может быть создано
        возвращает -1, если пользователь нажал клавишу ESC
        в остальных случаях она возвращает номер выбранной
        альтернативы, начиная с 0 */
     int popup(menu,keys,count,x,y,border)
     char *menu[];  /* текст меню */
     char *keys;    /* горячие клавиши */
     int count;     /* число альтернатив */
     int x,y;       /* координаты левого верхнего угла */
     int border;    /* если 0 то без рамки */
     {
      register int i,len;
      int endx endy choice;
      unsigned char *p;

      if((x>24)||(x<0)||(y>79)||(y<0)) {
       printf(" выход за пределы экрана");
       return -2;
      }
     /* вычисление размеров */
     len=0;
     for(i=0;i<count;i++)
      if(strlen(menu[i]) > len) len=strlen(menu[i]);
     endy=len+2+y;
     endx=count+1+x;
     if((endx+1>24) || (endy+1>79)) {
       printf(" выход за пределы экрана");
       return -2;
      }
     /* размещение памяти для видео буфера */
     p=(unsigned int *)malloc((endx-x+1)*(endy-y+1));
      if(!p) exit(1); /* Вы можете здесь сами обработать ошибку */

     /* сохранение части экрана */
     void save_video(x,endx+1,y,endy+1,p);

     if(border) draw_border(x,y,endx,endy);

     /* высвечивание меню на своем месте */
     void display_menu(menu,x,y,count);

     /* ввести выбор пользователя */
     choice=get_resp(x,y,count,menu,keys)

     /* восстановление части экрана */
     void restore_video(x,endx+1,y,endy+1,p);
     free(p);
     return choice;
     }

     /* высвечивание меню на своем месте */
     void display_menu(menu,x,y,count)
     char *menu[];
     int x,y,count;
     {
      register int i;

     for(i=0;i<count;i++,x++) {
       goto_xy(x,y);
       printf(menu[i]);
       }
     }

     void draw_border(startx,starty,endx,endy)
     int   startx,starty,endx,endy;
     {
      register int i;

      for(i=startx+1;i<endx;i++) {
     goto_xy(i,starty);
     putchar(179);
     goto_xy(i,endy);
     putchar(179);
     }

      for(i=starty+1;i<endy;i++) {
     goto_xy(startx,i);
     putchar(196);
     goto_xy(endx,i);
     putchar(196);
     }

     goto_xy(startx,starty); putchar(218);
     goto_xy(startx,endy  ); putchar(191);
     goto_xy(endx  ,starty); putchar(192);
     goto_xy(endx  ,endy  ); putchar(217);
     }

     /* ввести выбор пользователя */
     get_resp(x,y,count,menu,keys)
     int x,y,count;
     char *menu[];
     char *keys;
     {
      union inkey {
        char ch[2];
        int i;
      } c;
     int arrow_choice=0,key_choice;

     y++;
     /* осветить первый выбор */
     goto_xy(x,y);
     write_video(x,y,menu[0],REV_VID);

     for(;;) {
      while(!bioskey(1)); /* ждать нажатия */
      c.i=bioskey(0);

     /* вернуть выбор в номальный режим */
     goto_xy(arrow_choice,y);
     write_video(x+arrow_choice,y,
             menu[arrow_choice],norm_vid);
     if(c.ch[0]) { /* обычная клавиша */
      key_choice= is_in(keys,tоlower(c.ch[0]));
     if(key_choice) return key_choice-1;
     switch(c.ch[0]) {
       case '\r' : return arrow_choice;
       case ' '  : arrow_choice++;
                   break;
      case ESC   : return -1; /* выйти */
        }
     }
     else { /* специальная клавиша */
      switch(c.ch[1]) {
       case 72 : arrow_choice--; /* стрелка вниз */
                 break;
       case 80 : arrow_choice++; /* стрелка вверх */
                 break;

          }
       }
     if(arrow_choice==count) arrow_choice=0;
     if(arrow_choice<0) arrow_choice=count-1;
         /* подсветить выбранную опцию */
      goto_xy(x+arrow_choice,y);
      write_video(x+arrow_choice,y,menu[arrow_choice],REV_VID);
      }
     }

     /* вывод строки с определенным атрибутом */
     void write_video(x,y,p,attrib)
     int x,y;
     char *p;
     int attrib;
     {
      union REGS r;
      register int i,j;

      for(i=y; *p; i++) {
       goto_xy(x,i);
          r.h.ah=9; /* функция записи символа   */
          r.h.bh=0; /* видео страница           */
          r.x.cx=1; /* число повторений символа */
          r.h.al=*p++; /* символ          */
          r.h.bl=attrib; /* атрибут         */
          int86(0x10,&r,&r);
       }
     }

     /* сохранение части экрана */
     void save_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      union REGS r;
      register int i,j;

      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
          goto_xy(j,i);
          r.h.ah=8; /* функция чтения символа   */
          r.h.bh=0; /* видео страница           */
          *buf_ptr++ = int86(0x10,&r,&r);
          putchar(' '); /* очистка экрана */
        }
     }

     /* восстановление части экрана */
     void restore_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      union REGS r;
      register int i,j;

      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
          goto_xy(j,i);
          r.h.ah=9; /* функция записи символа   */
          r.h.bh=0; /* видео страница           */
          r.x.cx=1; /* число повторений символа */
          r.h.al=*buf_ptr++; /* символ          */
          r.h.bl=*buf_ptr++; /* атрибут         */
          int86(0x10,&r,&r);
        }
     }

     /* очистка экрана */
     void cls()
     {
      union REGS r;

      r.h.ah=6; /* код прокрутки экрана */
      r.h.al=0; /* код очистки экрана */
      r.h.ch=0; /* начальная строка */
      r.h.cl=0; /* начальная колонка */
      r.h.dh=24; /* конечная строка */
      r.h.dl=79; /* конечная колонка */
      r.h.bh=7; /* очистка пустой строки */
      int86(0x10,&r,&r);
     }

          Вводите эту программу в ваш компьютер  и  запускаете  ее.  В
     ходе ее  выполнения  каждое  меню будет высвечено и исчезнет.  (В
     этой программе все ответы теряются, но реальное применение будет,
     конечно, их обрабатывать.) Даже если ваш компьютер очень быстрый,
     вы возможно заметите,  что исчезновение и появление меню  требуют
     определенной задержки.  Единственный путь решения этой проблемы -
     читать и писать символы прямо в видео память, что и обсуждается в
     следующем  разделе.  Еще  раз  отметим,  что  единственное важное
     достоинство использование BIOS в том,  что такие меню работают на
     любом компьютере,  который поддерживает BIOS,  совместимый с IBM,
     даже если компьютер не 100% совместимый.



               Прямой доступ к видео памяти
     -----------------------------------------------------------------

          Для создания   меню,  которые  действительно  "исчезают"  вы
     должны миновать вызовы функций BIOS и прямо  обращаться  к  видео
     памяти.   Это   позволяет   высвечивать  символы  с  молниеносной
     быстротой.  При прямой записи и чтении из видео памяти вы  можете
     использовать исчезающие меню в реальном времени!

          Чтение и запись в видео память требует использования ДАЛЬНИХ
     указателей.  Если  ваш   компилятор   не   поддерживает   дальних
     указателей, то  вы  не  имеете  прямого  доступа  к видео памяти.
     Дальние указатели могут быть поддерживаемы транслятором  Си одним
     из  двух  способов.  Первый  - использование ключевого слова far,
     используемого   в   большинстве   компиляторов.   Они   позволяют
     определять указатель,  как дальний. Другой способ - использование
     большой модели памяти,  в  которой  все  указатели  по  умолчанию
     дальние.   Программы,   используемые   в  этой  главе  используют
     описатель far.  Если вы хотите,  вы можете просто удалить  его  и
     скомпилировать программу,  используя транслятор с большой моделью
     памяти.



               Определение расположения видео памяти
     -----------------------------------------------------------------

            Одноцветный адаптер  использует  для  видео  памяти  адрес
     B0000000H, a все остальные - В8000000Н. Для того, чтобы программы
     с  меню работали правильно с каждым адаптером,  они должны знать,
     какой адаптер имеет система.  К  счастью,  для  этого  существует
     простой способ. Прерывание BIOS 16, функция 15 возвращает текущий
     видео режим.  Как упоминалось раньше,  программы, разработанные в
     этой главе,  требуют режима 2,  3 или 7. Адаптеры CGA и EGA могут
     использовать режим 2 и 3,  но  не  режим  7.  Только  одноцветный
     адаптер использует этот режим.  Таким образом, если текущий видео
     режим 7, то используется одноцветный адаптер, в остальных случаях
     это  EGA или CGA.  Для наших задач,  в текстовом режиме EGA и CGA
     одинаковы и поэтому все равно,  какой  из  адаптеров  у  системы.
     Таким  образом функция popup() должна поверить какой из адаптеров
     у  системы  и  присвоить  глобальной  переменной   указатель   на
     соответствующий адрес.  Этот фрагмент программы позволяет сделать
     это.

     vmode = video_mode();
      if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
        printf(" должен быть 80 символьный текстовый режим");
        exit(1);
     }
      /* присвоить соответствующий адрес видео памяти */
     if(vmode==7) vid_mem=(char far *)0xB0000000;
     else   vid_mem=(char far *)0xB8000000;

          Функция video_mode()   возвращает  текущий  видео  режим,  и
     переменную vid_mem, объявленную везде как char far.



               Изменение save_video() и restore_video()
     -----------------------------------------------------------------

          Kaк только   переменной   vid_mem  присвоен  соответствующий
     адрес,  появляется простой способ использовать ее  для  чтения  и
     записи символов в видео память.  Запомните,  видео память требует
     двух байтов для каждого символа,  один для символа,  а другой для
     атрибута.  Из-за того, что символьный байт первый, а атрибутный -
     второй, то каждой строке экрана требуется  160  байт.  Для  того,
     чтобы  определить адрес отдельного символа вы должны использовать
     формулу:

      адрес = адрес_адаптера + X*160 + Y*2

          Функции save_video()  и  restore_video()  при  использовании
     прямого доступа к видео памяти выглядят следующим образом.

     void save_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      register int i,j;
      char far *v, far *t;

      v=vid_mem;
      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
           t = v + (j*160) + i*2;  /* вычисляем адрес */
           *buf_ptr++ = *t++;      /* чтение символа */
           *buf_ptr++ = *t;        /* чтение атрибута */
           *(t-1) = ' ';           /* очистка окна */
         }
     }

     /* восстановление части экрана */
     void restore_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      register int i,j;
      char far *v, far *t;

      v=vid_mem;
      t=v;
      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
          v = t;
          v += (j*160) + i*2;   /* вычисляем адрес */
          *v++ = *buf_ptr++;    /* запись символа */
          *v = *buf_ptr++;      /* запись атрибута */
         }
     }

          Как вы видете,  символы и атрибуты записываются или читаются
     с  помощью  использования  указателей  на  видео  память.  Другие
     функции,   которые  читают  и  записывают  символы  преобразуются
     подобным образом.

          Если весь доступ к дисплею  делать  прямым,  требуется  одна
     новая функция (показанная здесь). Функция write_char() записывает
     один  символ  в  определенную  позицию  экрана   с   определенным
     атрибутом.

     /* запись символа с определенным аттрибутом */
     void write_char(x,y,ch,attrib)
     int x,y;
     char ch;
     int attrib;
     {
      register int i;
      char far *v;

      v=vid_mem;
      v += (x*160) +y*2;
      *v++ = ch; /* запись символа */
      *v = attrib; /* запись атрибута */
     }

          Полная  версия  исчезающих меню с прямым доступом  приведена
     здесь  с   тем  же  простым   тестовым  примером.  Введите  его в
     в свой компьютер и  сравните  по  производительности  с  версией,
     использующей BIOS.  Как вы увидете, разница потрясающая. Кажется,
     что меню появляются и исчезают мгновенно.

     /* Программа исчезающих меню для текстового режима
        с использованием прямого доступа к видео памяти */
     #include "stdio.h"
     #include "dos.h"
     #include "stdlib.h"

     #define BORDER 1
     #define ESC 27
     #define REV_VID 0x70
     #define NORM_VID  7

     void save_video(),restore_video();
     void goto_xy(),cls(),write_video();
     void display_menu(),draw_border();
     char far *vid_mem;

     char *fruit[] = {
      "Яблоко",
      "Апельсин",
      "Груша",
      "Грейпфрут",
      "Малина",
      "Клубника"
     };

     char *color[]={
      "Красный",
      "Желтый",
      "Оранжевый",
      "Зеленый"
     };

     char *apple_type[] = {
      "Красный деликатес",
      "Джонатан",
      "Белый налив",
      "Антоновка"
     };

     main()
     {
      int i;

     cls();
     goto_xy(0,0);
     for(i=0;i<25;i++)
      printf("Это тест исчезающего меню\n");
     popup(fruit,"яагрмк",6,1,3,BORDER);
     popup(color,"кжоз",4,5,10,BORDER);
     popup(apple_type,"кдба",4,10,18,BORDER);
     }

     /* вывести исчезающее меню и вернуть выбор
        возвращает -2, если меню не может быть создано
        возвращает -1, если пользователь нажал клавишу ESC
        в остальных случаях она возвращает номер выбранного
        режима, начиная с 0 */
     int popup(menu,keys,count,x,y,border)
     char *menu[];  /* текст меню */
     char *keys;    /* горячие клавиши */
     int count;     /* число режимов */
     int x,y;       /* координаты левого верхнего угла */
     int border;    /* если 0 то без рамки */
     {
      register int i,len;
      int endx endy choice;
      unsigned char *p;

      if((x>24)||(x<0)||(y>79)||(y<0)) {
       printf(" выход за пределы экрана");
       return -2;
      }
     /* вычисление размеров */
     len=0;
     for(i=0;i<count;i++)
      if(strlen(menu[i]) > len) len=strlen(menu[i]);
     endy=len+2+y;
     endx=count+1+x;
     if((endx+1>24) || (endy+1>79)) {
       printf(" выход за пределы экрана");
       return -2;
      }
     vmode = video_mode();
      if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
        printf(" должен быть 80 символьный текстовый режим");
        exit(1);
     }

      /* присвоить соответствующий адрес видео памяти */
     if(vmode==7) vid_mem=(char far *)0xB0000000;
     else   vid_mem=(char far *)0xB8000000;
     /* размещение памяти для видео буфера */
     p=(unsigned int *)malloc((endx-x+1)*(endy-y+1));
      if(!p) exit(1); /* Вы можете здесь сами обработать ошибку */

     /* сохранение части экрана */
     void save_video(x,endx+1,y,endy+1,p);

     if(border) draw_border(x,y,endx,endy);

     /* высвечивание меню на своем месте */
     void display_menu(menu,x,y,count);

     /* ввести выбор пользователя */
     choice=get_resp(x,y,count,menu,keys)

     /* восстановление части экрана */
     void restore_video(x,endx+1,y,endy+1,p);
     free(p);
     return choice;
     }

     /* высвечивание меню на своем месте */
     void display_menu(menu,x,y,count)
     char *menu[];
     int x,y,count;
     {
      register int i;

     for(i=0;i<count;i++,x++) {
       write_string(x,y,menu[i],NORM_VID);
       }
     }

     void draw_border(startx,starty,endx,endy)
     int   startx,starty,endx,endy;
     {
      register int i;
      char far *v,far *t;

      v=vid_mem;
      t=v;
      for(i=startx+1;i<endx;i++) {
      v += (i*160) + starty*2;
      *v++ = 179;
      *v = NORM_VID;
      v=t;
      v += (i*160) + endy*2;
      *v++ = 179;
      *v = NORM_VID;
      v=t;
     }

      for(i=starty+1;i<endy;i++) {
      v += (startx*160) + i*2;
      *v++ = 196;
      *v = NORM_VID;
      v=t;
      v += (endx*160) + i*2;
      *v++ = 196;
      *v = NORM_VID;
      v=t;
     }

     write_char(startx,starty,218,NORM_VID);
     write_char(startx,endy  ,191,NORM_VID);
     write_char(endx  ,starty,192,NORM_VID);
     write_char(endx  ,endy  ,217,NORM_VID);
     goto_xy(startx,endy  ); putchar(191);
     goto_xy(endx  ,starty); putchar(192);
     goto_xy(endx  ,endy  ); putchar(217);
     }

     /* ввести выбор пользователя */
     get_resp(x,y,count,menu,keys)
     int x,y,count;
     char *menu[];
     char *keys;
     {
      union inkey {
        char ch[2];
        int i;
      } c;
     int arrow_choice=0,key_choice;

     y++;
     /* осветить первый выбор */
     goto_xy(x,y);
     write_string(x,y,menu[0],REV_VID);

     for(;;) {
      while(!bioskey(1)); /* ждать нажатия */
      c.i=bioskey(0);

     /* вернуть выбор в номальный режим */
     goto_xy(arrow_choice,y);
     write_string(x+arrow_choice,y,
             menu[arrow_choice],norm_vid);
     if(c.ch[0]) { /* обычная клавиша */
      key_choice= is_in(keys,tolower(c.ch[0]));
     if(key_choice) return key_choice-1;
     switch(c.ch[0]) {
       case '\r' : return arrow_choice;
       case ' '  : arrow_choice++;
                   break;
      case ESC   : return -1; /* выйти */
        }
     }
     else { /* специальная клавиша */
      switch(c.ch[1]) {
       case 72 : arrow_choice--; /* стрелка вниз */
                 break;
       case 80 : arrow_choice++; /* стрелка вверх */
                 break;

          }
       }
     if(arrow_choice==count) arrow_choice=0;
     if(arrow_choice<0) arrow_choice=count-1;
         /* подсветить выбранную опцию */
      goto_xy(x+arrow_choice,y);
      write_string(x+arrow_choice,y,menu[arrow_choice],REV_VID);
      }
     }

     /* вывод строки с определенным атрибутом */
     void write_string(x,y,p,attrib)
     int x,y;
     char *p;
     int attrib;
     {
      register int i,j;
      char far *v;

      v=vid_mem;
      v += (x*160) + y*2;
      for(i=y; *p; i++) {
        *v++ =*p++; /* запись символа */
        *v++ =attrib; /* запись атрибута */
       }
     }

     /* запись символа с определенным аттрибутом */
     void write_char(x,y,ch,attrib)
     int x,y;
     char ch;
     int attrib;
     {
      register int i;
      char far *v;

      v=vid_mem;
      v += (x*160) +y*2;
      *v++ = ch; /* запись символа */
      *v = attrib; /* запись атрибута */
     }

     /* сохранение части экрана с использованием
        прямого доступа к видео памяти */
     void save_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      register int i,j;
      char far *v, far *t;

      v=vid_mem;
      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
           t = v + (j*160) + i*2;  /* вычисляем адрес */
           *buf_ptr++ = *t++;      /* чтение символа */
           *buf_ptr++ = *t;        /* чтение атрибута */
           *(t-1) = ' ';           /* очистка окна */
         }
     }

     /* восстановление части экрана с использованием
        прямого доступа к видео памяти */
     void restore_video(startx,endx,starty,endy,buf_ptr)
     int   startx,endx,starty,endy;
     unsigned int *buf_ptr;
     {
      register int i,j;
      char far *v, far *t;

      v=vid_mem;
      t=v;
      for(i=starty;i<endy;i++)
        for(j=startx;j<endx;j++) {
          v = t;
          v += (j*160) + i*2;   /* вычисляем адрес */
          *v++ = *buf_ptr++;    /* запись символа */
          *v = *buf_ptr++;      /* запись атрибута */
         }
     }

     /* очистка экрана */
     void cls()
     {
      union REGS r;

      r.h.ah=6; /* код прокрутки экрана */
      r.h.al=0; /* код очистки экрана */
      r.h.ch=0; /* начальная строка */
      r.h.cl=0; /* начальная колонка */
      r.h.dh=24; /* конечная строка */
      r.h.dl=79; /* конечная колонка */
      r.h.bh=7; /* очистка пустой строки */
      int86(0x10,&r,&r);
     }

     /* установка курсора в x,y */
     void goto_xy(x,y)
     int x,y;
     {
      union REGS r;

      r.h.ah=2; /* функция установки курсора */
      r.h.dl=y; /* координата колонки       */
      r.h.dh=x; /* координата строки        */
      r.h.bh=0; /* видео страница           */
      int86(0x10,&r,&r);
     }

     /*  запрос текущего видео режима */
     video_mode()
     {
      union REGS r;

      r.h.ah = 15;   /* получить режим */
      return int86(0x10,&r,&r) & 255;
     }

     is_in(s,c)
     char *s,c;
     {
      register int i;

      for(i=0; *s; i++)
         if(*s++ == c) return i+1;
      return 0;
     }



               Создание иерархических окон
     -----------------------------------------------------------------

          Иерархические окна  фундаментально  отличаются  от   простых
     исчезающих меню тем, что два или более исчезающих меню могут быть
     активными  одновременно.  Вообще  иерархические  меню   позволяют
     пользователю выбирать   режимы   непосредственно   из  режимов  и
     используются для поддержки системы меню.  В  отличие  от  функции
     popup(),   которая   сохраняет   экран,   высвечивает   меню,   и
     восстанавливает экран,  функция pulldown(),  разработанная в этом
     разделе только сохраняет экран (если это нужно), высвечивает меню
     и   возвращает   выбор   пользователя.   Восстановление    экрана
     обрабатывается  как  отдельная  задача  в  любом месте программы.
     Перед тем как вы сможете создать иерархическое  меню,  вы  должны
     изменить свое представление о меню.



               Фреймы меню
     -----------------------------------------------------------------

          Центральным понятием    для     создания     иерархического,
     многоуровневого меню является фрейм меню.  В сущности,  программы
     иерархических меню требуют чтобы каждое  меню  имело  свой  фрейм
     ссылок,  определенных до того,  как программа,  которая испольует
     меню, начала выполняться.  Каждое меню активизируется  по  номеру
     его   фрейма   и   необходимая  информация  загружается  по  мере
     необходимости для различных функций, поддерживающих меню.

          Лучший способ для поддержки фреймов меню  -  создать  массив
     структур,  которые содержат информацию,  относящуюся к меню.  Эта
     структура определяется так, как описано здесь:

      struct menu_frame {
        int startx,endx,starty,endy;
        unsigned char *p; /* указатель на информацию экрана */
        char **menu;      /* указатель на строки меню */
        int border;       /* рамка включено/выключено */
        int count;        /* число альтернатив */
        int astive;       /* активно ли меню сейчас */
      } frame[MAX_FRAME];

     где МAX_FRAME - макроконстанта, которая определяет как много меню
     вы можете иметь.  Только одна дополнительная информация требуется
     для  иерархических  меню,  которая не нужна для исчезающих меню -
     флаг активности.  Флаг используется в качестве сигнала,  что меню
     уже  на  экране  и  предупреждает  перезаписывание  информации  с
     экрана.



               Создание фрейма меню
     -----------------------------------------------------------------

          Перед использованием  меню  для  этого  должен  быть  создан
     фрейм. Функция make_menu(), показанная здесь, создает фрейм меню.

      /* создание фрейма иерархического меню.
         1 если фрейм может быть создан
         в противном случае 0 */
     make_menu(num,menu,keys,count,x,y,border)
     int num;   /* номер меню */
     char *menu;   /* текст меню */
     char *keys;   /* горячие клавиши */
     int count;    /* число альтернатив */
     int x,y;      /* левый верхний угол */
     int border;   /* рамка */
     {
      register int i,len;
      int endx,endy,choice,vmode;
      unsigned char *p;

      if(num>MAX_FRAME) {
       printf("Слишком много меню");
       return 0;
     }
      if((x>24)||(x<0)||(y>79)||(y<0)) {
       printf(" выход за пределы экрана");
       return 0;
      }

     /* вычисление размеров */
     len=0;
     for(i=0;i<count;i++)
      if(strlen(menu[i]) > len) len=strlen(menu[i]);
     endy=len+2+y;
     endx=count+1+x;
     if((endx+1>24) || (endy+1>79)) {
       printf(" выход за пределы экрана");
       return 0;
      }

     /* размещение памяти для видео буфера */
     p=(unsigned int *)malloc((endx-x+1)*(endy-y+1));
      if(!p) exit(1); /* Вы можете здесь сами обработать ошибку */

     /* создание фрейма */
     frame[num].startx=x;
     frame[num].endx=endx;
     frame[num].starty=y;
     frame[num].endy=endy;
     frame[num].p = p;
     frame[num].menu = (char **) menu;
     frame[num].border = border;
     frame[num].keys = keys;
     frame[num].count = count;
     frame[num].active =0;
     return 1;
     }

          Вы вызываете   make_menu   с   теми  же  аргументами,  какие
     используются в popup() кроме номера  меню,  который  должен  быть
     определен   в  первом  аргументе.  Этот  номер  используется  для
     идентификации меню.



               Функция pulldown()
     -----------------------------------------------------------------

          Функция pulldown() показана здесь:

     /* Высветить меню и получить выбор
        возвращает -1, если пользователь нажал клавишу ESC
        в остальных случаях номер альтернативы, начиная с 0 */

     int pulldown(num)
     int num; /* номер фрейма */
     {
      int vmode,choice;

      vmode=video_mode();
      if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
        printf(" должен быть 80 символьный текстовый режим");
        exit(1);
     }

      /* присвоить соответствующий адрес видео памяти */
     if(vmode==7) vid_mem=(char far *)0xB0000000;
     else   vid_mem=(char far *)0xB8000000;

     /* узнать активность окна */
     if(!frame[num].active) { /* не активно */
         save_video(num);
         frame[num].active= 1; /* установить признак активности */
     }

     if( frame[num].border) draw_worder(num);

     display_menu(num);  /* высветить меню */
     return get_resp(num);  /* возвратить выбор */
     }

          Для использования pulldown()  просто  передайте  номер  того
     меню,  которое  вы  хотите высветить.  Однако вы должны помнить о
     восстановлении окна,  используя  restore_video()  везде  в  своей
     программе.  Запомните,  что основное отличие иерархических меню в
     том,  что они позволяют двум или более меню оставаться на  экране
     одновременно  и  быть  потенциально  активными,  по мере того как
     пользователь  выбирает  опции.  Тем  не  менее  вам  не   следует
     восстанавливать  экран  до  того,  как  процесс  выбора полностью
     завершен.

          Обратите внимание,  что часть экрана, используемая для меню,
     сохраняется  только  если  признак  активности  равен 0.  Так как
     иерархическое меню может быть вызвано повторно,  экран не  должен
     сохраняться  много раз.  (Другими словами при повторном вхождении
     будет сохранено  само  меню,  записанное  поверх  первоначального
     содержимого экрана, которое уже сохранено.)



               Восстановление экрана
     -----------------------------------------------------------------

          Как и   другие   функции    поддержки    меню,    измененная
     restore_video   показанная  здесь,  преобразована  для  работы  с
     фреймами.  Поэтому  функции  restore_video()  теперь   передается
     только номер меню, что делает интерфейс более очевидным.

     /* восстановление части экрана */
     void restore_video(num)
     int   num;
     {
      register int i,j;
      char far *v, far *t;
      char *buf_ptr;

      buf_ptr=frame[num].p;
      v=vid_mem;
      t=v;
      for(i=frame[num].starty;i<frame[num].endy;i++)
        for(j=frame[num].startx;j<frame[num].endx;j++) {
          v = t;
          v += (j*160) + i*2;   /* вычисляем адрес */
          *v++ = *buf_ptr++;    /* запись символа */
          *v = *buf_ptr++;      /* запись атрибута */
         }
      frame[num].active= 0;
     }



               Простая программа, использующая процедуру pulldown
     -----------------------------------------------------------------

          Все функции  для  иерархических меню показаны здесь вместе с
     простой программой-образцом  и  их  можно  прямо  вводить  в  ваш
     компьютер.

     /* процедура иерархического меню для текстового режима
        и простая программа-пример */
     #include "stdio.h"
     #include "dos.h"
     #include "stdlib.h"

     #define BORDER 1
     #define ESC 27
     #define REV_VID 0x70
     #define NORM_VID  7

     void save_video(),restore_video();
     void goto_xy(),cls(),write_video();
     void display_menu(),draw_border();
     char far *vid_mem;

      struct menu_frame {
        int startx,endx,starty,endy;
        unsigned char *p; /* указатель на информацию экрана */
        char **menu;      /* указатель на строки меню */
        int border;       /* рамка включено/выключено */
        int count;        /* число альтернатив */
        int astive;       /* активно ли меню сейчас */
      } frame[MAX_FRAME];

     char *fruit[] = {
      "Яблоко",
      "Апельсин",
      "Груша",
      "гРейпфрут",
      "Малина"
      "Клубника"
     };

     char *color[]={
      "Красный",
      "Желтый",
      "Оранжевый",
      "Зеленый"
     };

     char *apple_type[] = {
      "Красный деликатес",      ?
      "Джонатан",
      "Белый налив",
      "Aнтоновка"
     };

     char *grape_type[]= {
       "Конкорд",
       "кАнадский",
       "Томпсон",
       "кРасное пламя"
     };

     main()
     {
      int i;

      cls();
      goto_xy(0,0);

     /* во-первых создадим фреймы меню */
     make_menu(0,fruit,"яагрмк",6,5,20,BORDER);
     make_menu(1,color,"кжоз",4,9,28,BORDER);
     make_menu(2,apple_type,"кдба",4,12,32,BORDER);
     make_menu(3,grape_type,"катр",4,9,10,BORDER);

     printf("Выберите фрукт:");

     pd_driver(); /* запуск системы меню */

     }

     void pd_driver()
     {
      int choice1,choice2,selection;

      /* активизация окон по мере надобности */
     while((choice1=pulldown(0)) != -1) {
       switch ( choice1 ) {
         case 0 :  /* яблоко */
           while((choice2=pulldown(1)) != -1) {
             if(choice2 ==0) selection=pulldown(2);/*красное яблоко */
             restore_video(2);
           }
           restore_video(1);
           break;
         case 1 :
         case 2 : goto_xy(1,0);
           printf("неправильный выбор");
           break;
         case 3 : /* грейпфрут */
           selection=pulldown(3);
           restore_video(3);
           break;
         case 4 :
         case 5 : goto_xy(1,0);
           printf("неправильный выбор");
           break;
       }
      }
         restore_video(0);
     }

     /* Высветить меню и получить выбор */

     int pulldown(num)
     int num; /* номер фрейма */
     {
      int vmode,choice;

      vmode=video_mode();
      if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
        printf(" должен быть 80 символьный текстовый режим");
        exit(1);
     }

      /* присвоить соответствующий адрес видео памяти */
     if(vmode==7) vid_mem=(char far *)0xB0000000;
     else   vid_mem=(char far *)0xB8000000;

     /* узнать активнсть окна */
     if(!frame[num].active) { /* не активно */
         save_video(num);
         frame[num].active= 1; /* установить признак активности */
     }

     if( frame[num].border) draw_worder(num);

     display_menu(num);  /* высветить меню */
     return get_resp(num);  /* возвратить выбор */
     }

      /* создание фрейма иерархического меню.
         1 если фрейм может быть создан
         в противном случае 0 */
     make_menu(num,menu,keys,count,x,y,border)
     int num;   /* номер меню */
     char *menu;   /* текст меню */
     char *keys;   /* горячие клавиши */
     int count;    /* число альтернатив */
     int x,y;      /* левый верхний угол */
     int border;   /* рамка */
     {
      register int i,len;
      int endx,endy,choice,vmode;
      unsigned char *p;

      if(num>MAX_FRAME) {
       printf("Слишком много меню");
       return 0;
     }
      if((x>24)||(x<0)||(y>79)||(y<0)) {
       printf(" выход за пределы экрана");
       return 0;
      }

     /* вычисление размеров */
     len=0;
     for(i=0;i<count;i++)
      if(strlen(menu[i]) > len) len=strlen(menu[i]);
     endy=len+2+y;
     endx=count+1+x;
     if((endx+1>24) || (endy+1>79)) {
       printf(" выход за пределы экрана");
       return 0;
      }

     /* размещение памяти для видео буфера */
     p=(unsigned int *)malloc((endx-x+1)*(endy-y+1));
      if(!p) exit(1); /* Вы можете здесь сами обработать ошибку */

     /* создание фрейма */
     frame[num].startx=x;
     frame[num].endx=endx;
     frame[num].starty=y;
     frame[num].endy=endy;
     frame[num].p = p;
     frame[num].menu = (char **) menu;
     frame[num].border = border;
     frame[num].keys = keys;
     frame[num].count = count;
     frame[num].active =0;
     return 1;
     }

     /* высвечивание меню на своем месте */
     void display_menu(num)
      int num;
     {
      char **m;
      register int i, x;

      x = frame[num].startx+1;
      m = frame[num].menu;

     for(i=0;i<frame[num].count;i++,x++) {
       write_string(x,frame[num].starty+1,m[i],NORM_VID);
       }
     }

     void draw_border(num)
     int  num ;
     {
      register int i;
      char far *v,far *t;

      v=vid_mem;
      t=v;
      for(i=frame[num].startx+1;i<frame[num].endx;i++) {
      v += (i*160) + frame[num].starty*2;
      *v++ = 179;
      *v = NORM_VID;
      v=t;
      v += (i*160) + frame[num].endy*2;
      *v++ = 179;
      *v = NORM_VID;
      v=t;
     }

      for(i=frame[num].starty+1;i<frame[num].endy;i++) {
      v += (frame[num].startx*160) + i*2;
      *v++ = 196;
      *v = NORM_VID;
      v=t;
      v += (frame[num].endx*160) + i*2;
      *v++ = 196;
      *v = NORM_VID;
      v=t;
     }

     write_char(frame[num].startx,frame[num].starty,218,NORM_VID);
     write_char(frame[num].startx,frame[num].endy  ,191,NORM_VID);
     write_char(frame[num].endx  ,frame[num].starty,192,NORM_VID);
     write_char(frame[num].endx  ,frame[num].endy  ,217,NORM_VID);
     goto_xy(frame[num].startx,frame[num].endy  ); putchar(191);
     goto_xy(frame[num].endx  ,frame[num].starty); putchar(192);
     goto_xy(frame[num].endx  ,frame[num].endy  ); putchar(217);
     }

     /* ввести выбор пользователя */
     get_resp(num)
     int num;
     {
      union inkey {
        char ch[2];
        int i;
      } c;
     int arrow_choice=0,key_choice;
     int x,y;

     x=frame[num].startx+1;
     y=frame[num].starty+1;

     /* осветить первый выбор */
     goto_xy(x,y);
     write_string(x,y,frame[num].menu[0],REV_VID);

     for(;;) {
      while(!bioskey(1)); /* ждать нажатия */
      c.i=bioskey(0);

     /* вернуть выбор в номальный режим */
     goto_xy(arrow_choice,y);
     write_string(x+arrow_choice,y,
             frame[num].menu[arrow_choice],norm_vid);
     if(c.ch[0]) { /* обычная клавиша */
      key_choice= is_in(frame[num].keys,tolower(c.ch[0]));
     if(key_choice) return key_choice-1;
     switch(c.ch[0]) {
       case '\r' : return arrow_choice;
       case ' '  : arrow_choice++;
                   break;
      case ESC   : return -1; /* выйти */
        }
     }
     else { /* специальная клавиша */
      switch(c.ch[1]) {
       case 72 : arrow_choice--; /* стрелка вниз */
                 break;
       case 80 : arrow_choice++; /* стрелка вверх */
                 break;

          }
       }
     if(arrow_choice==frame[num].count) arrow_choice=0;
     if(arrow_choice<0) arrow_choice=frame[num].count-1;
         /* подсветить выбранную опцию */
      goto_xy(x+arrow_choice,y);
      write_string(x+arrow_choice,y,
                   frame[num].menu[arrow_choice],REV_VID);
      }
     }

     /* вывод строки с определенным атрибутом */
     void write_string(x,y,p,attrib)
     int x,y;
     char *p;
     int attrib;
     {
      register int i,j;
      char far *v;

      v=vid_mem;
      v += (x*160) + y*2;
      for(i=y; *p; i++) {
        *v++ =*p++; /* запись символа */
        *v++ =attrib; /* запись атрибута */
       }
     }

     /* запись символа с определенным аттрибутом */
     void write_char(x,y,ch,attrib)
     int x,y;
     char ch;
     int attrib;
     {
      register int i;
      char far *v;

      v=vid_mem;
      v += (x*160) +y*2;
      *v++ = ch; /* запись символа */
      *v = attrib; /* запись атрибута */
     }

     /* сохранение части экрана с использованием
        прямого доступа к видео памяти */
     void save_video(num)
      int num;
     {
      register int i,j;
      char far *v, far *t;
      char *buf_ptr;

      buf_ptr=frame[num].p;
      v=vid_mem;
      for(i=frame[num].starty;i<frame[num].endy;i++)
        for(j=frame[num].startx;j<frame[num].endx;j++) {
           t = (v + (j*160) + i*2);  /* вычисляем адрес */
           *buf_ptr++ = *t++;      /* чтение символа */
           *buf_ptr++ = *t;        /* чтение атрибута */
           *(t-1) = ' ';           /* очистка окна */
         }
     }

     /* восстановление части экрана */
     void restore_video(num)
     int   num;
     {
      register int i,j;
      char far *v, far *t;
      char *buf_ptr;

      buf_ptr=frame[num].p;
      v=vid_mem;
      t=v;
      for(i=frame[num].starty;i<frame[num].endy;i++)
        for(j=frame[num].startx;j<frame[num].endx;j++) {
          v = t;
          v += (j*160) + i*2;   /* вычисляем адрес */
          *v++ = *buf_ptr++;    /* запись символа */
          *v = *buf_ptr++;      /* запись атрибута */
         }
      frame[num].active= 0;
     }

     /* очистка экрана */
     void cls()
     {
      union REGS r;

      r.h.ah=6; /* код прокрутки экрана */
      r.h.al=0; /* код очистки экрана */
      r.h.ch=0; /* начальная строка */
      r.h.cl=0; /* начальная колонка */
      r.h.dh=24;/* конечная строка */
      r.h.dl=79;/* конечная колонка */
      r.h.bh=7; /* очистка пустой строки */
      int86(0x10,&r,&r);
     }

     /* установка курсора в x,y */
     void goto_xy(x,y)
     int x,y;
     {
      union REGS r;

      r.h.ah=2; /* функция установки курсора */
      r.h.dl=y; /* координата колонки       */
      r.h.dh=x; /* координата строки        */
      r.h.bh=0; /* видео страница           */
      int86(0x10,&r,&r);
     }

     /*  запрос текущего видео режима */
     video_mode()
     {
      union REGS r;

      r.h.ah = 15;   /* получить режим */
      return int86(0x10,&r,&r) & 255;
     }

     is_in(s,c)
     char *s,c;
     {
      register int i;

      for(i=0; *s; i++)
         if(*s++ == c) return i+1;
      return 0;
     }

          В этом примере,  если пользователь выберет "Яблоко",  то  он
     или она  будет  запрошен  о  цвете яблока;  если выбран "Красный"
     цвет, то будет высвечен список  красных  сортов  яблок.  Если  же
     будет  выбран грейпфрут то пользователь будет запрошен о желаемом
     типе. Меню для выбора яблок показано на рисунке.

     +-------------------------------------------------------+
     | выберите фрукт:                                       |
     |               +---------+                             |
     |               |Яблоко   |                             |
     |               |Апельсин |                             |
     |               |Груша    |                             |
     |               |гРейпфрут|                             |
     |               |Малин+-------+                         |
     |               |Клубн|Красный|                         |
     |               +-----|Желтый |                         |
     |                     |Ора+-----------------+           |
     |                     |Зел|Красный деликатес|           |
     |                     +---|Д*ж*о*н*а*т*а*н**|           |
     |                         |Белый налив      |           |
     |                         |Антоновка        |           |
     |                         +-----------------+           |
     |                                                       |
     +-------------------------------------------------------+

          Посмотрите внимательно   на   функцию  pd_driver(),  которая
     следует   за   главной   функцией   main().   При   использовании
     иерархических меню вы должны создавать функцию, которая управляет
     системой меню.  Основа стратегии управляющей функции должна  быть
     аналогична функции  pd_driver()  из этого примера.  Не забывайте,
     что эта простая программа только иллюстрирует  как активизировать
     меню.  Ваша  реальная  прикладная  программа  будет  обрабатывать
     выбранные режимы  более  разумным  образом.  Запомните,  что  для
     использования      иерархических     меню     нужна     следующая
     последовательность действий.

      1. Создать меню, используя make_menu().
      2. Активизировать меню, используя pulldown().
      3. Восстановить экран,  используя restore_video(), при выходе из
         каждого меню.



               Добавочные опции
     -----------------------------------------------------------------

          Процедуры меню,  разработанные  в  этой  главе,  подходят  в
     большинстве  ситуаций.  Однако,  вы  можете  по  желанию добавить
     некоторые из следующих возможностей:

     # Высвечивание заголовка меню
     # Линейное меню (все опции на одной строке)
     # Использование разных цветов для разных меню


                               ГЛАВА 2
                               -------

                           ВСПЛЫВАЮЩИЕ ОКНА
     -----------------------------------------------------------------

          Всплывающие окна   могут   придать   вашей   программе   тот
     профессиональный вид,  который не может  быть  достигнут  другими
     средствами.  Всплывающие  окна создают впечатление,  что вы,  как
     программист,  в  совершенстве  владеете  экраном.   А   так   как
     пользователь  обычно  судит  о  программе по ее пользовательскому
     интерфейсу, то это положительное впечатление распространится и на
     всю программу в целом.

          Данная глава  содержит  описание  полного набора функций для
     всплывающих окон,  которые позволят вам создавать и  использовать
     множественные окна.

          Программы управления   окнами   используют  функции  прямого
     доступа к видеопамяти,  представленные в Главе 1. Из-за того, что
     окна в большинстве случаев, имеют значительно больший размер, чем
     меню,  то использование функций из ROM-BIOS просто невозможно,  -
     даже на самых быстрых компьютерах.

          Однако перед   рассмотрением  оконных  функций  очень  важно
     правильно понять,  что  же  такое  всплывающие  окна  и  как  они
     используются.



                          Теория всплывающих окон.
     -----------------------------------------------------------------

          Всплывающее окно   представляет    собой    часть    экрана,
     используемую для специальных целей. Перед появлением окна текущее
     содержимое экрана сохраняется и  лишь  после  этого  производится
     отображение окна.

          При завершении программы, использующей данное окно, это окно
     удаляется,  а первоначальное содержимое экрана восстанавливается.
     (Данный  процесс  аналогичен появлению всплывающих меню).  Вполне
     возможно одновременное отображение на экране нескольких окон.

          Хотя это  и  не  обязательно,  но  все  хорошие   программы,
     работающие  с  окнами,  позволяют интерактивно изменять размеры и
     позицию окна на экране. Следовательно, оконные функции допускают,
     что  окно  не  всегда  будет  находиться в одном и том же месте и
     иметь один и тот же размер.

          Разработка функций,  управляющих  окнами,  является  сложной
     задачей  из-за  необходимости  обеспечения запрета для прикладной
     программы осуществлять вывод за границы окна.  Поскольку  размеры
     окна   могут   изменяться  без  "сообщения"  об  этом  прикладной
     программе,  то именно функции управления окнами,  а не прикладная
     программа,    должны   предохранить   от   выхода   за   границы.
     Следовательно,  все обычные функции Си, осуществляющие ввод/вывод
     на  консоль  (например,  printf()  и  lets()  )  ,  не могут быть
     использованы и должны быть заменены на  функции,  ориентированные
     на ввод/вывод с использованием окон.

          Теория использования  окон  крайне проста.  Каждая отдельная
     задача программы использует свое собственное  окно.  При  запуске
     задачи активируется и ее окно.  При завершении работы задачи - ее
     окно удаляется.  Если же задача прерывается,  то,  хотя ее работа
     приостанавливается,  но  ее  окно  не  удаляется,  а инициируемая
     прерыванием задача,  просто создает свое окно поверх предыдущего.
     (Обычно те задачи, которые не используют окон, очищают экран. Это
     приводит к рассеиванию внимания пользователя.  В то же время  при
     использовании  окон  подобные  прерывания  выглядят как временные
     паузы).

          Чтобы понять,  как  окна  могут  быть  наиболее   эффективно
     использованы, предположим, что вы разработали текстовый редактор,
     включающий  ряд  дополнительных  функций,  таких  как   "записная
     книжка",  калькулятор  с  четырьмя  математическими  операциями и
     конвертер чисел из десятичного в шестнадцатиричное представление.
     Так  как  все  эти  функции  в  действительности  не  относятся к
     операциям  редактирования  текста,   то   их   реализация   тесно
     переплетается   с  концепцией  всплывающих  окон.  Таким  образом
     получается,  что  использование  какой-либо  из   вспомогательных
     функций лишь приостанавливает основную задачу (редактирование), а
     не прерывает ее.



               Оконные структуры.
     -----------------------------------------------------------------

          Правильная реализация  всплывающих  окон требует,  чтобы все
     атрибуты,  необходимые для описания их границ, были в любое время
     доступны  всем  оконным  функциям.  Для достижения этого мы будем
     использовать  концепцию  структуры,  аналогичную   той,   которая
     использовалась  при  описании  функций спускающихся меню.  Однако
     структура окна содержит некоторую специфическую  информацию. Ниже
     показан массив, используемый для хранения структур.

                  struct window_frame
                    {
                    int startx, endx, starty, endy; /*позиция окна*/
                    int curx, cury; /*текущая позиция курсора в окне*/
                    unsigned chsr *p; /*указатель буфера*/
                    char *header; /*имя окна*/
                    int border; /*включение/выключение границ*/
                    int active; /*на экране или невидимо*/
                    } frame [MAX_FRAME];

          Переменные startx,  starty,  endx и endy  хранят  координаты
     верхнего  левого  и  нижнего правого углов окна.  Текущая позиция
     курсора в окне содержится в переменных curx  и  cury.  Сохранение
     этих переменных осуществляется из-за того,  что положение курсора
     может изменяться и вручную и путем использования оконных функций.
     Указатель p указывает на область памяти,  хранящей первоначальное
     содержимое  части  экрана,  занятой  данным  окном.  Часто   окно
     снабжается  заголовком,  иденцифирующим содержимое окна.  На этот
     заголовок и указывает header.  Переменная border используется для
     определения   необходимости   вычерчивания  границ  вокруг  окна.
     Переменная active установлена в "1", если в данный момент окно на
     экране, и в "0" - в противном случае.

          С точки   зрения   программирования  использование  окон  не
     составляет труда.  Во-первых,  вы создаете структуру окна, затем,
     когда  появляется  необходимость в окне,  то при записи в него вы
     используете    специальные     оконно-ориентированные     функции
     ввода/вывода.  Когда  же  окно больше не нужно,  вы деактивируете
     его.



                         Создание структуры окна.
     -----------------------------------------------------------------

          Ниже показана    функция    под   названием   make_window(),
     используемая для создания структуры окна.


         /* Создать рамку спускающегося окна.
          Возвратить 1, если рамка окна  может
          быть создана и 0 в противном случае */
         маке_window(num, header,startx,starty,endx,endy,border)
         int num;               /* номер окна                           */
         char *header;          /* текст заголовка                      */
         int startx,starty;     /* координаты X,Y левого верхнего угла  */
         int endx,endy;         /* координаты X,Y правого верхнего угла */
         int border;            /* без бордюра, если 0                  */
         {
         unsigned char *p;

         if(num>MAX_FRAME)
             {
             printf("Too many windows\n");
             return 0;
             }

         if((startx>24) || (startx<0) || (starty>78) || (starty<0))
             {
             printf("range error");
             return 0;
             }

         if((endx>24) || (endy>79))
             {
             printf("window won't fit");
             return 0;
             }

       /* отвести достаточное количество памяти */
       p=(unsigned char *) malloc(2*(endx-startx+1)*(endy-starty+1));
       if(!p) exit(1); /* перейти к высшему собственному обработчику
       ошибок */

           /* создать рамку */
           frame[num].startx = startx; frame[num].endx = endx;
           frame[num].starty = starty; frame[num].endy = endy;
           frame[num].p = p;
           frame[num].haeder = header;
           frame[num].border = border;
           frame[num].active = 0;
           frame[num].curx = 0; frame[num].cury = 0;
           return 1;
         }

          Как вы  можете  видеть  из  описания  функции,  она  требует
     передачи  номера  окна,  структуру которого вы хотите создать,  и
     всей остальной соответствующей информации.  Ниже  показан  пример
     вызова  make_window()  для  создания  окна  номер  0 с заголовком
     "Редактор [Esс для выхода]",  с верхним левым углом  в  0,0  и  с
     нижним правым углом в 24,78 и имеющем границы.

      make_window (0, "Редактор [Ese для вывода]", 0,0,24,78, BORDER);

          Отметим, что переменные, определяющие позицию курсора curx и
     cury устанавливаются 0.  Это означает,  что при первой  активации
     окна,  курсор будет установлен в его верхний левый угол.  Функция
     также управляет размещением окна на экране.



                      Активирование и деактивирование окна.
     -----------------------------------------------------------------

          Для активирования окна используется функция window (). Здесь
     num  будет  содержать  номер  структуры  окна,  которое вы хотите
     использовать.


         /* Вывести на экран спускающееся окно */
         void window(num)
         int num; /* номер окна */
         {
           int vmode, choice;
           int x, y;

           vmode = video_mode();
           if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
             printf("video must be in 80 column text mode");
             exit(1);
           }
           /* установить соответствующий адрес видеопамяти */
           if(vmode==7) vid_mem = (char far *) 0xB0000000;
           else vid_mem = (char far *) 0xB0000000;

           /* сделать окно активным */
           if(!frame[num].active)    /* используется не постоянно */
              {
              save_video(num);       /* сохранить текущее содержимое экрана */
              frame[num].active = 1; /* установить флаг активности */
              }

           if(!frame[num].border) draw border(num);
           display_header(num);      /* вывести окно на экран */

           x = frame[num].startx + frame[num].curx + 1;
           y = frame[num].starty + frame[num].cury + 1;
           goto_xy(x,y);
           }


          Как вы можете видеть, данная функция очень похожа на функцию
     menu(),  показанную  в  предыдущей  главе.   Переменная   vid-mem
     является глобальным указателем типа char far.

          Функция display_header(),  показанная ниже, используется для
     отображения в центре верхней границы окна его заголовка.  Если же
     заголовок не помещается в эту строку, то он не выводится.


         /* вывести текст заголовка начиная с определенной
         позиции */
         void display_header(num)
         int num;
         {
           register int y,len;

           y = frame[num].starty;
           /* Вычислить начальную позицию относительно центра текста
           заголовка, если отрицательная, то текст не подходит */
           len = strlen(frame[num].header);
           len = (frame[num].endy - y - len) / 2;
           if(len<0) return; /* не выводить на экран */
           y = y +len;

           write_string(frame[num].startx, y,
                        frame[num].header,NORM_VID);
         }


          Если вы  хотите,  чтобы  заголовок  выводился  в   инверсном
     изображении,  то  вместо NORМ_VID (имеющем значение 7) подставьте
     REV_VID (со значением 70Н).

          Для деактивации окна используется  показанная  ниже  функция
     deactivate(), которой передается номер удаляемого окна.


         /* Деактивировать окно и удалить его с экрана */
         deactivate(num)
         int num;
         {
           /* установить курсор в левый верхний угол */
           frame[num].curx = 0;
           frame[num].cury = 0;
           restore_video(num);
         }


          Как вы видите,  функция устанавливает позицию курсора в 0,0.
     Однако,  поскольку вам могут встретиться  некоторые  ситуации,  в
     которых  более  желательно  не  устанавливать  курсор  в  нулевую
     позицию,  то  вы  можете   изменить   поведение   этой   функции,
     сообразуясь со своими намерениями.



               Оконные функции ввода/вывода.
     -----------------------------------------------------------------

          Перед использованием     окна     необходимо     разработать
     значительное   число  консольных  оконно-ориентированных  функций
     ввода/вывода.  Чтобы понять,  почему требуется так много функций,
     вспомните  о  том,  сколько  консольных  функций  ввода/вывода  в
     стандартной  библиотеке  Си.  Функции,  представленные  в  данной
     главе,  в  действительности  составляют  лишь  минимальный набор,
     необходимый для использования окон.  Хотя они не включают в  себя
     ориентированные  на  использование  окон  версии  всех консольных
     Си-функций, но все же имеют большой объем. Как вы убедитесь, даже
     простейшие  операции,  такие  как чтение символа с клавиатуры или
     вывод его на экран,  реализуются  программами  большого  объеема,
     поскольку  необходимо  отслеживать  и  сохранять  текущую позицию
     курсора и не допускать выхода за границы окна.  Помните,  что для
     манипулирования  экраном  нельзя использовать никаких стандартных
     возможностей,  предоставляемых DOS.  Например,  при необходимости
     выполнить    "возврат    каретки"   это   должно   быть   сделано
     самостоятельно,  внутри функции;  нельзя просто вызвать  DOS  для
     вывода соответствующей последовательности.

          Для облегчения    идентификации    все    оконные    функции
     ввода/вывода начинаются со слова  window.  Кроме  того,  все  эти
     функции в качестве своего первого аргумента принимают номер окна,
     к которому осуществляется доступ.



                  Функция позиционирования курсора в окне.
     -----------------------------------------------------------------

          Возможно, кому-то это покажется странным, но первая функция,
     в которой возникает потребность,  это оконный эквивалент  функции
     goto_xy().  Объяснение  этому  очень  простое.  Поскольку оконные
     функции  ввода/вывода   должны   самостоятельно   позиционировать
     курсор, то должен существовать некоторый способ установки курсора
     в  нужную  позицию.  Функция  window_xy(),  представленная  ниже,
     делает  именно  это.  (Для представленных здесь программ работы с
     окнами позиция 0,0 соответствует левому верхнему углу окна).


         /* Установить курсор в определенную позицию окна.
            Возвратить 0 при выходе за границу и не ноль -
            в противном случае */

         window_xy(num, x, y,)
         int num, x, y;
         {
           if(x<0 || x+frame[num].startx>=frame[num].endx-1)
             return 0;
           if(x<0 || y+frame[num].starty>=frame[num].endy-1)
             return 0;
           frame[num].curx = x;
           frame[num].cury = y;
           goto_xy(frame[num].startx+x+1, frame[num].starty+y+1);
           return 1;
           }


          Ключом к  пониманию функции window_xy() является напоминание
     о  том,  что  значения  координат  X,Y   внутри   окна   остаются
     неизменными,  независимо от расположения окна на экране.  То есть
     координаты X,Y вычисляются относительно окна,  а не  относительно
     экрана.  Другими  словами,  если  вы  установите  курсор в окне в
     позицию с координатами 2,2,  то он  всегда  будет  находиться  во
     второй   строке  сверху  и  второй  позиции  относительно  левого
     верхнего угла окна, независимо от положения окна на экране.

          Фактически функция  window_xy()  производит   преобразование
     координат   курсора   относительно  окна  в  реальные  координаты
     относительно  экрана.  Кроме  этого,   функция   window_xy()   не
     позволяет курсору выйти за пределы окна.



                  Функция window_getche()
     -----------------------------------------------------------------

          При  работе  с  окнами  вы  не  можете  использовать функцию
     getche(), которая  считывает  введенный  с  клавиатуры  символ  и
     отображает его на экране,  поскольку это может привести к  выходу
     за пределы окна.  Поэтому должна быть использована альтернативная
     оконная функция window_getche().  Эта функция  считывает  символ,
     который вводится в текущую позицию окна.


        /*  Ввести  с  клавиатуры  символ  в   окно.   Возвратить
            полный 16-разрядный скан-код. */
         window_getche(num)
         int num;
           {
           union inkey
              {
              char ch[2];
              int i;
              } c;

           if(!frame[num].active) return 0; /* окно не активное */

           window_xy(num, frame[num].curx, frame[num].cury);

           c.i = bioskey(0);    /* принять символ от клавиатуры */

           if(c.ch[0])
              {
              switch(c.ch[0])
                 {
                 case '\r':     /* нажата клавиша ENTER */
                    break;
                 case BKSP;     /* возврат              */
                    break;
                 default:
                 if(frame[num].cury+frame[num].starty < frame[num].endy-1)
                    {
                    write_char(frame[num].startx = frame[num].curx=1,
                      frame[num].starty+frame[num].cury+1,c.ch[0],NORM_VID);
                    frame[num].cury++;
                    }
                 }
              if(frame[num].curx < 0) frame[num].curx = 0;
              if(frame[num].curx+frame[num].startx > frame[num].endx-2)
                 frame[num].curx--;
              window_xy(num, frame[num].curx, frame[num].cury);
              }
           return c.i;
           }

          В отличие   от  функции  getche(),  функция  window_getche()
     возвращает полный 16-разрядный скан-код.  Это  означает,  что  вы
     имеете  доступ  как к стандартным кодам символов в младших восьми
     разрядах,  так и к позиционным кодам символов  в  старших  восьми
     разрядах. Если вам не нужны позиционные коды, то вы можете просто
     назначить   возвращаемое   функцией   window_getche()    значение
     символьной переменной.

          Функция работает  следующим  образом.  Если окно не является
     активным  (т.е.  его  нет  на  экране),  функция  возвращает   0.
     Поскольку  код  0 не может соответствовать символу,  введенному с
     клавиатуры,  то ваша программа сможет  обнаружить  эту  ситуацию.
     Затем  курсор  устанавливается  в свою текущую позицию в окне,  и
     считывается код нажатой клавиши.  Если это обычная клавиша,  а не
     клавиша  типа  RETURN  или  BACKSPASE,  инкрементируется  текущее
     значение  переменной  Y,  соответствующее  положению  курсора,  и
     соответствующий символ выводится на экран.  Если курсор находится
     на границе окна, значение Y декрементируется. Последнее обращение
     к  функции  window_xy() используется для того,  чтобы переместить
     курсор в следующую позицию экрана.

          Функция window_getche не позволит  вам  вводить  символы  за
     границей  окна.  Следует  помнить,  что  все  окна имеют границы,
     которые могут и не отображаться явно в виде линий.  Если  граница
     не  отображается,  это  значит,  что  для  этой цели используется
     символ пробела.  Это имеет смысл,  если окно отображается на фоне
     изображения,  имеющего  другой  цвет.  Даже  если  граница  и  не
     обозначена явно,  то символы все равно не могут  отображаться  за
     пределами окна.

          Как утверждается в разделе 1,  функция bios_key() cпецифична
     для Турбо Си.  Если вы используете другой компилятор  Си,  то  вы
     можете  использовать версию функции bios_key(),  представленную в
     главе 1.



               Функция window_gets()
     -----------------------------------------------------------------

          Для чтения  строки,  введенной  в  окне,  можно использовать
     представленную  ниже  функцию   window_gets().   Она   не   такая
     изощренная, как большинство функций gets(),  но может служить для
     многих  целей.  Вы  всегда  можете  расширить  ее  функциональные
     возможности, если пожелаете.


         /* Считать строку из окна */
         void window_gets(nums, s)
         int num;
         char *s;
         {
           char ch, *temp;

           temp = s;
           for(;;) {
             ch = window_getche(num);
             switch(ch) {
               case '\r': /* нажата клавиша ENTER */
               *s='\0';
               return;
             case BKSP:   /* возврат */
               if(s>temp) {
                 s--;
                 frame[num].cury--;
                 if(frame[num].cury<0) frame[num].cury = 0;
                 window_xy(num, frame[num].curx, frame[num].cury);
                 write_char(frame[num].startx+ frame[num].curx+1'
                   frame[num].starty+frame[num].cury+1, ' ',NORM_VID);
               }
               break;
             default: *s = ch;
               s++;
             }
           }
         }


          При нажатии клавиши ВАСКSPASE,  необходимо вернуть курсор на
     одну позицию влево,  стереть записанный там символ и на его место
     записать пробел.



               Функция window_putchar()
     -----------------------------------------------------------------

          При выводе символа в окно необходимо проверять,  является ли
     окно  активным  и  не  выходит  ли символ за границу окна.  После
     вывода символа курсор продвигается на одну позицию. Выполняет эти
     действия представленная ниже функция window_putchar().


         /* Вывести символ в текущую позицию курсора в созданном окне.
         Возвратить  0, если окно не активное, и 1 - в противном
         случае */
         window_putchar(num, ch)
         int num;
         char ch;
         {
           register int x, y;
           char far *v;

           /* убедиться, что окно активное */
           if(!frame[num].active) return 0;

           x = frame[num].curx = frame[num].startx + 1;
           y = frame[num].cury = frame[num].starty + 1;

           v = vid_mem;
           v += (x*160) + y*2;  /* вычисляется адрес */
           if(y>=frame[num].endy)
              return 1;
           if(x>=frame[num].endx)
              return 1;

           if(ch=='\n')         /* символ перехода на следующую строку */
              {
              x++;
              y = frame[num].startx+1;
              v = vid_mem;
              v += (x*160) = y*2;  /* вычислить адрес */
              frame[num].curx++;   /* нарастить x */
              frame[num].cury = 0; /* нарастить y */
              }
           else
              {
              frame[num].cury++;
              *v++ = ch;           /* вывести символ */
              *v++ =NORM_VID;      /* нормальные атрибуты символа */
              }
           window_xy(num, frame[num].curx, frame[num].cury);
           return 1;
           }

          Эта функция  не занимается обнаружением ошибочнных ситуаций,
     когда символ выходит за границу окна.  Смысл этого состоит в том,
     что  размер  окна  может  динамически  изменяться и то сообщение,
     которое помещалось в окно в следующий  момент  времени  может  не
     помещаться.  В  этом  случае  функция  просто  не  отображает  те
     символы, которые выходят за границу окна.

          Обратите внимание,  что  нажатие  клавиши  возврата  каретки
     требует  перевода  курсора  к левой границе окна и на одну строку
     вниз, если это возможно.



               Функция window_puts
     -----------------------------------------------------------------

          Функция window_puts выводит заданную строку в активное окно,
     используя при этом функцю window_putchar().


      /* Вывести строку, начиная с текущей позиции курсора в окне.
                                                        /* 60 */
         Возвратить 0, если окно не активное и 1 в противном случае */

         window_puts(num, str)
         int num;
         char *str;
         {
           /* убедиться, что окно активное */
           if(!frame[num].active) return 0;

           for( ; *str; str++)
             window_putchar(num, *str);
           return 1;
         }


               Дополнительные функции управления экраном.
     -----------------------------------------------------------------

          При работе  с  окнами  также  используются следующие функции
     управления экраном:

          Функция             Назначение
         ---------            ------------
        window_cls()          очищает окно
        window_cleol()        очищает часть окна от текущей позиции
                              до конца строки
        window_upline()       перемещает курсор на одну строку вверх
        window_downline()     перемещает курсор на одну строку вниз
        window_bksp()         перемещает курсор на одну позицию влево

          Эти функции  представлены  ниже.  Следуя  используемым в них
     общим  принципам,  вы  можете  создать  свои  функции  управления
     экраном.


         /* Очистить окно */
         void window_cls(num)
         int num;
         {

           register int i,j;
           char far *v, far *t;

           v = vid_mem;
           t = v;
           for(i=frame[num].starty+1; i<frame[num].endy; i++)
             for(j=frame[num].startx+1; j<frame[num].endx; j++) {
               v = t;
               v += (j*160) + i*2;
               *v++ = ' ';     /* вывести пробел */
               *v =  NORM_VID; /* нормальные видеоатрибуты */
             }
             frame[num].curx = 0;
             frame[num].cury = 0;
           }

           /* очистить до конца строки */
           void window_cleol(num)
           int num;
           {
             register int i, x, y;

             x = frame[num].curx;
             y = frame[num].cury;
             window_xy(num, frame[num].curx, frame[num].cury);

             for(i=frame[num].cury; i<frame[num].endy-1; i++)
               window_putchar(num,' ');
             window_xy(num, x, y);
           }

     /* Переместить курсор на одну строку вверх. Возвратить ненулевой
        код в случае успеха и 0 - в противном случае */
           window_upline(num)
           int num;
           {
             if(frame[num].curx>0)
                {
                frame[num].curx--;
                window_xy(num, frame[num].curx, frame[num].cury);
                return 1;
                }
             return 0;
           }

           window_downline(num)
           int num;
           {
             if(frame[num].curx<frame[num].endx-frame[num].startx-1)
                {
                frame[num].curx++;
                window_xy(num, frame[num].curx, frame[num].cury);
                return 1;
                }
             return 1;
           }

           /* стереть предыдущий символ */
           window_bksp(num)
           int num;
           {
             if(frame[num].cury>0)
                {
                frame[num].cury--;
                window_xy(num, frame[num].curx, frame[num].cury);
                window_putchar(num, ' ');
                frame[num].cury--;
                window_xy(num, frame[num].curx, frame[num].cury);
                }
           }



            Изменение размера и положения  окна  во  время
            выполнения  программы
     -----------------------------------------------------------------

          Хотя функция  make_window()  и  используется  для  установки
     начальных  размеров  и  положения  окна  на  экране,  однако  эти
     параметры   могут  динамически  изменяться  во  время  выполнения
     программы.   Изменение   одного   или   более   параметров   окна
     производится по командам,  поступающим от пользователя.  При этом
     текущее  окно  уничтожается   и   воссоздается   уже   с   новыми
     параметрами.  Представленные  ниже  программы size() и move() как
     раз и используются для изменения размеров и положения  окна.  Для
     изменения   формы   и  положения  окна  используются  клавиши  со
     стрелками, а также клавиши HOME, END, PGDN и PGUP.

         /* Интерактивное изменение размера окна */
         void size(num)
         int num;
         {
           char ch;
           int x, y, startx, starty;

           /* активировать, если необходимо */
           if(!frame[num].active) window(num);
           startx = x = frame[num].startx;
           starty = y = frame[num].starty;
           window_xy(num, 0, 0);

           do
              {
              ch = get_special();
              switch(ch)
                 {
                 case 75:     /* влево */
                    starty--;
                 break;
                 case 77:     /* вправо */
                    starty++;
                 break;
                 case 72:     /* вверх */
                    startx--;
                 break;
                 case 80:     /* вниз */
                    startx++;
                 break;
                 case 71:     /* влево вверх */
                    startx--;starty--;
                 break;
                 case 73:     /* вправо вверх */
                    startx--;starty++;
                 break;
                 case 79:     /* влево вниз */
                    startx++;starty--;
                 break;
                 case 81:     /* вправо вниз */
                    startx++;starty++;
                 break;
                 case 60:
                    /* F2: отменить и вернуться к исходному размеру */
                    startx = x;
                    starty = y;
                    ch = 59;
                 }

              /* смотри при выходе за диапазон */
              if(startx<0) startx++;
              if(startx>=frame[num].endx) startx--;
              if(starty<0) starty++;
              if(starty>=frame[num].endy) starty--;
              deactivate(num);  /* стереть окно старого размера */
              frame[num].startx = startx;
              frame[num].starty = starty;
              window(num);      /* вывести окно с новым размером */
           }
           while(ch!=59);  /* F1 для подтверждения нового размера */
           deactivate(num);
         }


         /* Интерактивное перемещение окна */
         void move(num)
         int num;
         {
           char ch;
           int x, y, ex, ey, startx, starty, endx, endy;

           /* активировать, если необходимо */
           if(!frame[num].active) window(num);
           startx = x = frame[num].startx;
           starty = y = frame[num].starty;
           endx = ex = frame[num].endx;
           endy = ey = frame[num].endy;
           window_xy(num, 0, 0);

           do {
             ch = get_special();
             switch(ch) {
               case 75:     /* влево */
                 starty--;
                 endy--;
                 break;
               case 77:     /* вправо */
                 starty++;
                 endy++;
                 break;
               case 72:     /* вверх */
                 startx--;
                 endx--;
                 break;
               case 80:     /* вниз */
                 startx++;
                 endx++;
                 break;
               case 71:     /* влево вверх */
                 startx--;starty--;
                 endx--;endy--;
                 break;
               case 73:     /* вправо вверх */
                 startx--;starty++;
                 endx--;endy++;
                 break;
               case 79:     /* влево вниз */
                 startx++;starty--;
                 endx++;endy--;
                 break;
               case 81:     /* вправо вниз */
                 startx++;starty++;
                 endx++;endy++;
                 break;
       case 60:     /* F2: отменить и вернуться к исходному размеру */
                 startx = x;
                 starty = y;
                 endx = ex;
                 endy = ey;
                 ch = 59;
             }

             /* смотри при выходе за диапазоном */
             if(startx<0) {
               startx++;
               endx++;
             }
             if(endx>=25) {
               startx--;
               endx--;
             }
             if(starty<0) {
               starty++;
               endy++;
             }
             if(endy>=79) {
               starty--;
               endx--;
             }
             /* стереть окно в старой позиции */
             deactivate(num);
             frame[num].startx = startx;
             frame[num].starty = starty;
             frame[num].endx = endx;
             frame[num].endy = endy;
             /* вывести окно в новую позицию */
             window(num);
             } while(ch!=59);  /* F1 для подьверждения изменения */
           deactivate(num);
         }

          При использовании как функции size(),  так и функции  move()
     после  завершения  изменения  параметров окна нажмите клавишу F1.
     Окно будет иметь установленные размеры  и  положение  при  каждой
     последующей активации и до тех пор, пока вы не измените их снова.
     Для прерывания выполнения обеих функций используется  клавиша F2,
     при этом окно сохраняет старые значения размеров и положения. При
     использовании этих функций  допускается,  чтобы  окна,  в  момент
     изменения их размеров или положения необязательно были активными.



          Создание прикладных программ, использующих всплывающие окна
     -----------------------------------------------------------------

          Работая с окнами очень важно помнить,  что при  вводе-выводе
     должны  использоваться специальные оконные функции. Использование
     для этих целей стандартных  функций  Си  чревато  неприятностями,
     потому  что  создает возможность нарушения границы окна.  Оконной
     функции,  аналогичной по выполняемым действиям  функции  prinf(),
     разработано не было,  и вы,  возможно,  захотите создать для этих
     целей свою собственную функцию.  Но простейший  способ  вывода  в
     окно данных, тип которых отличен от символов и строк, заключается
     в   использовании   стандартной    Си-функции    sprintf()    для
     преобразования любых типов данных в строку определенного формата,
     а затем в выводе этой строки в окно с помощью функции window_puts
     ().  Аналогичный  способ  позволяет  вводить данные,  отличные от
     символов  и  строк.  При  этом  функция  window_gets()  считывает
     данные,   а  приводит  их  к  соответствующему  типу  стандартная
     Си-функция sscanf(), которая выполняет преобразование поступающих
     от клавиатуры данных.

          Изображение в   окне   обычно   формируется   другой  частью
     программы,  не той,  которая содержит функции управления  окнами.
     Обычно это делается в функции main() или в функции инициализации,
     которая вызывается в начале программы. Предлагаем вашему вниманию
     три простые программы, использующие окна.



                 Программа  преобразования  из  десятичной
                 в шестнадцатиричную систему счисления.
     -----------------------------------------------------------------

         /* Десятично-шестнадцатиричный преобразоваель */
         void dectohex()
         {
           char in[80], out[80]
           int n;

           window(1);
           do {
             window_xy(1, 0, 0)  /* перейти к первой строке */
             window_cleol(1);    /* очистить строку */

             window_puts(1, "dec: ");  /* промптер */
             window_gets(1, in);       /* считать число */
             window_putchar(1,  '\n'); /* перейти к следующей строке */
             window_cleol(1);          /* очистить ее */
          sscanf(in,"%d", &n);         /* преобразовать во внутрений формат */
             sprintf(out, "%s%X", "hex: ",n);  /* преобразовать в
                                  шестнадцатиричное представление */
            window_puts(1, out); /* вывести шестнадцатиричное число */
           } while(*in);
           deactivate(1);
         }

          Функция активирует  свое  окно,  а  затем  в цикле принимает
     десятичные числа и выводит их шестнадцатиричные  эквиваленты,  до
     тех пор,  пока  пользователь  не  нажмет  Ввод  в ответ на запрос
     десятичного  числа.  Перед   возвратом   из   функции   ее   окно
     деактивируется.





               Калькулятор с четырьмя функциями.
     -----------------------------------------------------------------
          Очень подходящей   и   популярной   областью   использования
     всплывающих   окон   являются   программы   калькуляторов.  Здесь
     представлена программа стекового калькулятора.  Это означает, что
     при работе с ним вы должны сначала вводить операнды, а затем знак
     операции (т.н. постфиксная запись). Операнды помещаются в стек. В
     каждый  момент времени выполняется операция над двумя операндами.
     При  этом  операнды  извлекаются  из  стека,  результат  операции
     отображается и помещается в стек.  Например,  для того, вычислить
     результат выражения (10+5)/5,  вы сначала должны ввести 10, затем
     5, затем знак +. Результат этой операции, число 15, будет выведен
     на дисплей и помещен в вершину стека.  Затем вы вводите 5 и  знак
     /.  Отображается  результат  3.  Стек рассчитан на 100 элементов.
     Можно вводить несколько операндов перед знаком  операции. Функция
     calc(),  а также подпрограммы push() и pop() для работы со стеком
     приводятся ниже.  Хотя эта версия  программы  работает  только  с
     целыми числами,  вы легко можете изменить ее таким образом, чтобы
     она работала с действительными числами.

         #define MAX 100
         int *p;  /* указатель стека */
         int *tos;  /* указатель вершины стека */
         int *bos;  /* указатель дна стека */

     /* стековый, с постфиксной записью калькулятор с четырьмя
        функциями */
         void calc()
         {
           chra in[80], out[80];
           int answer, stack[MAX];
           int a,b;

           p = stack;
           tos = p;
           bos = p+MAX-1;

           window(2);
           do {
              window_xy(2, 0,0);
              window_cleol(2);
              window_puts(2, ": "); /* промптер калькулятора */
              window_gets(2, in);
              window_puts(2, "\n ");
              window_cleol(2);
              switch(*in) {
                case '+':
                  a = pop();
                  b = pop();
                  answer = a+b;
                  push(a+b);
                  break;
                case '-':
                  a = pop();
                  b = pop();
                  answer = b-a;
                  push(b-a);
                  break;
                case '*':
                  a = pop();
                  b = pop();
                  answer = b*a;
                  push(b*a;
                  break;
                case '/':
                  a = pop();
                  b=pop();
                  if(a==0) {
                      window_putch("divide by 0\n");
                      break;
                    }
                    answer = b/a;
                    break;
                  default:
                    push(atoi(in));
                    continue;
                  }
                  sprintf(out, "%d", answer);
                  window_puts(2, out);
                } while(*in);
                deactivate(2);
              }

            /* Поместить число в стек.  Возвратить 1 в случае успеха и
               0, если стек переполнен */
              push(i)
              int i;
              {
                if(p>bos) return 0;

                *p=i;
                p++;
                return 1;
              }

              /* Извлечь верхний элемент из стека.  Возвратить 0, если
                 стек переполнен */

              pop()
              {
                p--;
                if(p<tos) {
                  p++;
                  return 0;
                }
                return *p;
             }



               Всплывающая записная книжка
     -----------------------------------------------------------------

          Другой очень подходящей областью применения всплывающих окон
     являются программы типа "записная книжка". При использовании этих
     программ  у вас может возникнуть потребность внести новую запись.
     Все, что от вас потребуется, это активизировать программу, внести
     новую  запись  и  вернуться  к  тому,  что вы делали ранее.  Ниже
     представлен  пример  очень  простой  программы   типа   "записная
     книжка".


         #include "ctype.h"

         /* Всплывающая записная книжка */
         #define MAX_NOTE 10
         #define BKSP 8
         char notes[MAX NOTE][80];

         void notepad()
         {
           static firs=1;
           register int i, j;
           union inkey {
             char ch[2];
             int i;
           } c;
           char ch;

           /* Инициализировать массив записей, если это необходимо */
           if(frist) {
             for(i=0; i<MAX_note; i++)
               *note[i] = '\0';
             frist = !frist;
           }

           window(3);

           /* вывести на экран существующие записи */
           for(i=0; i<MAX_note; i++)  {
             if(*notes[i]) window_puts(3, notes[i]);
             window_putcar(3, '\n');
           }
           i=0;
           window_xy(3, 0, 0);

           for(;;) {
             c.i = window_getche(3);  /* считать символ, введенный с
                                                         клавиатуры */
             if(tolower(c.ch[1])==59 {  /* по F1 - завершение */
               deactivate(3);
               break;
             }

             /* если обычный символ, то внести его в запись */
             if(isprint(c.ch[0]) || c.ch[0]==BKSP) {
               window_cleol(3);
               notes[i][0] = c.ch[0];
               j = 1;
               window_putchar(3, notes[i][0]);
               do {
                 ch = window_getche(3);
                 if(ch==BKSP) {
                   if(j>0) {
                     j--;
                     window_bksp(3);
                   }
                 }
                 else {
                   notes[i][j] = ch;
                   j++;
                 }
                 } while(notes[i][j-1]!='\r');
                 notes[i][j-1] = '\0';
                 i++;
                 window_putchar(3, '\n');
               }
               else {             /* это специальная клавиша */
                 switch(c.ch[1]) {
                   case 72:       /* стрелка вверх */
                     if(i>0) {
                       i--;
                       window_upline(3);
                     }
                     break;
                   case 80:       /* стрелка вниз */
                     if(i<MAX_NOTE-1) {
                       i++;
                       window_dowline(3);
                     }
                     break;
                   }
                 }
               }
             }


          Функция notepad()  позволяет  вводить  до  десяти  строк.  С
     помощью клавиш UP ARROW и DOWN ARROW  вы  можите  перемещаться  к
     нужной вам строке.  Старое содержимое строки,  в которую вносится
     новая  запись,  при  этом  стирается.  Для  выхода  из  программы
     "записная книжка" используется клавиша F1.



               Совместное использование всех программ
     -----------------------------------------------------------------

          В этом разделе приводится программа,  в которой используются
     все    программы   управления   окнами   и   функции   управления
     изображением,  представленные в разделе 1, а также три прикладных
     программы,   использующие   окна.   Программа   имитирует  работу
     редактора  и  позволяет  вам  с  помощью  функциональных   клавиш
     активировать   окна  различного  назначения  или  демонстрировать
     различные особенности  работы  с  окнами.  Вы  можете  немедленно
     ввести эту программу в вашу ЭВМ.


         /* Подпрограмма управления окнами и простая демонстрационная
         программа. Имитируется работа редактора. Три специальные
         оконные утилиты иллюстрируют мощь и очарование программ,
         использующих всплывающие окна. Этими утилитами являются:
         калькулятор с 4-мя функциями, десятично-шестнадцатиричный
         преобразователь и всплывающая записная книжка.    */
         #include "stdio.h"
         #include "dos.h"
         #include "stdlib.h"

         #define BORDER 1
         #define ESC 27
         #define MAC_FRAME 10
         #define REV_VID 0x70
         #define NORM_VID 7
         #define BKSP 8

         void save_video(), restore_video(), pd_driver();
         void goto_xy(, cls(), write_string(), write_char();
         void display_header(), draw_border();
         void window_gets(), size(), move(), window_cls();
         void window_cleol(), window();
         void dectohex(), notepad(), calc();

         char far *vid_mem;

         struct window_frame {
           int startx, endx, starty, endy;
           int curx, cury;
           unsigned char *p;
           char *header;
           iht border;
           int active;
         } frame[MAX_FRAME];


         main()
         {
           union inkey {
           char ch[2];
           int i;
         } c;
         int i;
         char ch;

         cls();
         goto_xy(0,0);

         /* первым делом, создать рамки окна */
      make_window(0, " Editor [Esc to exit] ", 0, 0, 24, 78, BORDER);
      make_window(1, " Decimal to Hex ", 7, 40, 10, 70, BORDER);
      make_window(2, " Calculator ", 8, 20, 12, 60, BORDER);
      make_window(3, " Notepad [F1 to exit] ", 5, 20, 17, 60, BORDER);

         /* использовать window() для активации описанного окна */
         window(0);
         do {
           c.i = window_getche(0);
           ch = c.i;      /* использовать только младший байт */
           if(ch=='\r')   /* должен выполнять переход к началу
                                            следующей строки */
               window_putchar(0, '\n');

           switch(c.ch[1]) {   /* см. при использовании стрелок или
                                  функциональных клавиш */
             case 59: /* F1 демонстрирует работу функции window() */
               window(1);
               for(i=0; i<10; i++)
                 if(window_xy(1, i, i)) window_putchar(1,'X');
                 getch();
                 deactivate(1);
                 break;
                 case 60: /* F2 демонстрирует изменение размера и
                                                   положения окна */
                 size(1);
                 move(1);
                 break;
               case 61:  /* F3 вызывает калькулятор */
                 calc();
                 break;
               case 62:    /* F4 вызывает десятично-шестнадцатиричный
                               преобразователь */
                 dectohex();
                 break;
               case 63:  /*  F5 вызывает записную книжку */
                 notepad();
                 break;
                 case 72:  /* вверх */
                 window_upline(0);
                 break;
               case 80:    /* вниз */
                 window_downline(0);
                 break;

               }
             } while (ch!=ESC);
             deactivate(0);  /* удалить окно */
           }


         /***********************************************************/
         /*  Оконные функции                                        */
         /***********************************************************/

         /* Вывести на экран спускающееся окно */
         void window(num)
         int num;  /* номер окна */
         {
           int vmode, choice;
           int x, y;

           vmode = video_mode();
           if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
             printf("video must be in 80 column text mode");
             exit(1);
           }
           /* установить соответствующий адрес видеопамяти */
           if(vmode==7) vid_mem = (char far *) 0xb0000000;
           else vid_mem = (char far *) 0xb0000000;

           if(!frame[num].active) {  /* используется непостоянно */
             save_video(num);/* сохранить текущее содержимое экрана */
             frame[num].active = 1;  /* установить флаг активности */
           }

           if(frame[num].border) draw_border(num);
           dispay_header(num);     /* вывести окно на экран */

           x = frame[num].startx + frame[num].curx + 1;
           y = frame[num].starty + frame[num].cury + 1;
           goto_xy(x, y);

         }


         /* Создать рамку спускающегося окна. Возвратить 1, если рамка
         окна может быть создана и 0 в противном случае */

         make_window(num, header, startx, starty, endx, endy, border)
         int num;         /* номер окна */
         char *header;    /* текст заголовка */
         int startx, starty; /* координаты x,y верхнего левого угла */
         int endx, endy;     /* координаты x,y нижнего правого угла */
         int border;           /* без бордюра, если 0 */
         {
           unsigned char *p;

           if(num>MAX_FRAME) {
             printf("Too many windows\n");
             return 0;
           }

         if((startx>24) || (startx<0) || (starty>78) || (starty<0)) {
             printf("range error");
             return 0:
           }

           if((endx>24) || (endy>79)) {
             printf("window won't fit");
             return 0;
           }

           /* отвести достаточное количество памяти */
      p = (unsigned char *) malloc(2*(endx-startx+1)*(endy-starty=1));
     if(!p) exit(1);/* используйте ваш собственный обработчик ошибок*/

           /* создать рамку */
           frame[num].startx = startx; frame[num].endx = endx;
           frame[num].starty = starty; frame[num].endy = endy;
           frame[num].p = p;
           frame[num].header = header;
           frame[num].border = border;
           frame[num].active = 0;
           frame[num].curx = 0; frame[num].cury = 0;
           return 1;
         }

         /* редактировать окно и удалить его с экрана */
         deactivate(num)
         int num;
         {

           /* установить курсор в левый верхний угол */
           frame[num].curx = 0;
           frame[num].cury = 0;
           restore_video(num);
         }

         /* Интерактивное изменение размеров окна */
         void size(num)
         int num;
         {
           char ch;
           int x, y, startx, starty;

           /* активировать, если необходимо */
           if(!frame[num].active) window(num);

           startx = x = frame[num].startx;
           starty = y = frame[num].starty;
           window_xy(num, 0, 0);

           do {
             ch = get_special();
             switch(ch) {
               case 75:    /* влево */
                 starty--;
                 break;
               case 77:    /* вправо */
                 starty++;
                 break;
               case 72:    /* вверх */
                 startx--;
                 break;
               case 80:    /* вниз */
                 startx++;
                 break;
               case 71:    /* влево вверх */
                 startx--; starty--;
                 break;
               case 73:    /* вправо вверх */
                 startx--; starty++;
                 break;
               case 79:    /* влево вниз */
                 startx++; starty--;
                 break;
               case 81:    /* вправо вниз */
                 startx++; starty++;
                 break;
               case 60:    /* F2: отменить и вернуться к исходным
                                                         размерам */
                 startx = x;
                 starty = y;
                 ch = 59;
             }

             if(startx<0) startx++;
             if(startx>=frame[num].endx) startx--;
             if(starty<0) starty++;
             if(starty>=frame[num].endy) starty--;
             deactivate(num);
             frame[num].startx = startx;
             frame[num].starty = starty;
             window(num);
           } while(ch!=59);
           deactivate(num);
         }


         /* Интерактивное перемещение окна */
         void move(num)
         int num;
         {
           char ch;
           int x, y, ex, ey, startx, starty, endx, endy;

           /* активировать, при необходимости */
           if(!frame[num].active) window(num);

           startx = x = frame[num].startx;
           starty = y = frame[num].starty;
           endx = ex = frame[num].endx;
           endy = ey = frame[num].endy;
           window_xy(num, 0, 0);

           do {
             ch = get_special();
             switch(ch) {
               case 75:   /* влево */
               starty--;
               endy--;
               break;
               case 77:   /* вправо */
               starty++;
               endy++;
               break;
               case 72:   /* вверх */
               startx--;
               endx--;
               break;
               case 80:   /* вниз */
               startx++;
               endx++;
               break;
               case 71:   /* влево вверх */
               startx--; starty--;
               endx--; endy--;
               break;
               case 73:   /* вправо вверх */
               startx--; starty++;
               endx--; endy++;
               break;
               case 79:   /* влево вниз */
               startx++; starty--;
               endx++; endy--;
               break;
               case 81:   /* вправо вниз */
               startx++; starty++;
               endx++; endy++;
               break;
               case 60:    /* F2: отменить и вернуться к исходным
                                                         размерам */
                 startx = x;
                 starty = y;
                 endx = ex;
                 endy =ey;
                 ch = 59;
         }

         /* см. при выходе за диапазон */
         if(startx<0) {
           startx++;
           endx++;
         }
         if(endx>=25) {
           startx--;
           endx--;
           }
           if(starty<0) {
             starty++;
             endy++;
           }
           if(endy>=79) {
             starty--;
             endy--;
           }
           deactivate(num);
           frame[num].startx = startx;
           frame[num].starty = starty;
           frame[num].endx = endx;
           frame[num].endy = endy;
           window(num);
         } while(ch!=59);
         deactivate(num);
       }


         /* Вывести текст заголовка, начиная с определенной позиции */
         void display_header(num)
         int num;
         {
           register int y, len;

           y = frame[num].starty;

           /* Вычислить начальную позицию относительно центра текста
           заголовка, если отрицательная, то текст не подходит */
           len = strlen(frame[num].header);
           len = (frame[num].endy - y - len) / 2;
           if(len<0) return;  /* не выводить на экран */
           y = y + len;

           write_string(frame[num].startx, y,
                      frame[num].header, NORM_VID);
         }

         void draw_border(num)
         int num;
         {
           register int i;
           char far *v, far *t;

           v = vid_mem;
           t = v;
           for(i=frame[num].startx+1; i<frame[num].endx; i++) {
           v += (i*160) + frame[num].starty*2;
           *v++ = 179;
           *v = NORM_VID;
           v = t;
           v += (i*160) + frame[num].endy*2;
           *v++ = 179;
           *v = NORM_VID;
           v = t;
         }
         for(i=frame[num].starty+1; i<frame[num].endy; i++) {
            v += (frame[num].startx*160) + i*2;
            *v++ = 196;
            *v = NORM_VID;
            v = t;
            v+ =(frame[num].endx*160) + i*2;
            *v++ = 196;
            *v = NORM_VID;
            v = t;
         }
      write_char(frame[num].startx, frame[num].starty, 218, NORM_VID);
      write_char(frame[num].startx, frame[num].endy, 191, NORM_VID);
      write_char(frame[num].endx, frame[num].starty, 192, NORM_VID);
         write_char(frame[num].endx, frame[num].endy, 217, NORM_VID);

         }


     /***************************************************************/
     /*   Оконные функции ввода/вывода                              */
     /***************************************************************/

     /* Вывести символ в текущую позицию курсора в созданном окне.
        Возвратить 0, если окно не активное и 1 в противном случае. */
         window_puts(num, str)
         int num;
         char *str;
         {

           /* убедиться, что окно активное */
           if(!frame[num].activite) return 0;

           for( ; *str; str++)
             window_putchar(num, *str);
           return 1;
         }

      /* Вывести символ в текущую позицию курсора в созданном окне.
         Возвратить 0, если окно не активное и 1 в противном случае */
         window_putchar(num, ch)
         int num;
         char ch;
         {
           register int x, y;
           char far *v;

           /* убедиться, что окно активное */
           if(!frame[num].active) return 0;

           x = frame[num].curx + frame[num].startx + 1;
           y = frame[num].cury + frame[num].starty + 1;

           v = vid_mem;
           v += (x*160) + y*2;  /* вычислить адрес */
           if(y>=frame[num].endy) {
             return 1;
           }
           if(x>=frame[num].endx) {
             return 1;
           }
           if(ch=='\n') {   /* символ перехода на следующую строку */
             x++;
             y = frame[num].startx+1;
             v = vid_mem;
             v += (x*160) + y*2;  /* вычислить адрес */
             frame[num].curx++;   /* нарастить x */
             frame[num].cury = 0; /* спросить y */
           }
           else {
             frame[num].cury++;
             *v++ = ch;  /* вывести символ */
             *v++ = NORM_VID; /* нормальные видеоатрибуты */
           }
           window_xy(num, frame[num].curx, frame[num].cury);
           return 1;
         }


         /* Установить курсор в оределенной позиции окна.
            Возвратить 0 при выходе за границу, не ноль в противном
            случае */
         window_xy(num, x, y)
         int num, x, y;
         {
           if(x<0 || x+frame[num].startx>=frame[num].endx-1)
             return 0;
           if(y<0 || y+frame[num].starty>=frame[num].endy-1)
             return 0;
           frame[num].curx = x;
           frame[num].cury = y;
           goto_xy(frame[num].startx+x+1, frame[num].starty+y+1);
           return 1;
         }

         /* Считать строку из окна */
         void window_gets(num, s)
         int num;
         char *s;
         {
           char ch, *temp;

           temp = s;
           for(,,) {
             ch = window_getche(num);
             switch(ch) {
               case '\r':  /* нажата клавиша ENTER */
                 *s='\0';
                 return;
               case BKSP:  /* возврат */
                 if(s>temp) {
                   s--;
                   frame[num].cury--;
                   if(frame[num].cury<0) frame[num].cury = 0;
                     window_xy(num, frame[num].curx, frame[num].cury);
                      write_char(frame[num].startx+ frame[num].curx+1;
                  frame[num].starty+frame[num].cury+1, ' ', NORM_VID);
                 }
                 break;
               default: *s = ch;
                 s++;
             }
           }
         }



         /* Ввести символ в окно с клавиатуры.
            Возвратить полный 16-ти разрядный скан-код */
         window_getche(num)
         int num;
         {
            union inkey {
              char ch[2];
              int i;
             } c;

             if(!frame[num].active) return 0;  /* окно не активное */

             window_xy(num, frame[num].curx, frame[num].cury);

             c.i = bioskey(0);   /* ввести символ с клавиатуры */

             if(c.ch[0]) {
               switch(c.ch[0]) {
                 case '\r':    /* нажата клавиша ENTER */
                   break;
                 case BKSP:   /*возврат */
                   break;
                 default:
           if(frame[num].cury+frame[num].starty < frame[num].endy-1) {
           write_char(frame[num].startx+ frame[num].curx+1,
           frame[num].starty+frame[num].cury+1, c.ch[0], NORM_VID);
                     frame[num].cury++;
                   }
               }
            if(frame[num].curx < 0) frame[num].curx = 0;
            if(frame[num].curx+frame[num].startx > frame[num].endx-2)
                 frame[num].curx--;
               window_xy(num, frame[num].curx, frame[num].cury);
             }
             return c.i;
           }

           /* Очистить окно */
           void window_cls(num)
           int num;
           {
             register int i,j;
             char far *v, far *t;

             v = vid_mem;
             t = v;
             for(i=frame[num].starty+1; i<frame[num].endy; i++)
               for(j=frame[num].startx+1; j<frame[num].endy; j++) {
                 v = t;
                 v += (j*160) + i*2;
                 *v++ = ' ';    /* вывести пробел */
                 *v = NORM_VID; /* нормальные видеоатрибуты */
             }
             frame[num].curx = 0;
             frame[num].cury = 0;
           }

           /* Очистить до конца строки */
           void window_cleol(num)
           int (num);
           {
           register int i, x, y;

           x = frame[num].curx;
           y = frame[num].cury;
           window_xy(num, frame[num].curx, frame[num].cury);

           for(i=frame[num].cury; i<frame[num].endy-1; i++)
             window_putchar(num,' ');
           window_xy(num, x, y);
         }


         /* Переместить курсор на одну строку вверх.
            Возвратить ненулевой код в случае успеха, 0 - в пртивном
            случае. */
         window_upline(num)
         int num;
         {
           if(frame[num].curx>0) {
             frame[num].curx--;
             window_xy(num, frame[num].curx, frame[num].cury);
             return 1;
           }
           return 0;
         }


         /* Переместить курсор на одну строку вниз.
            Возвратить ненулевой код в случае успеха, 0 - в противном
            случае. */

         window_dowline(num)
         int num,
         {
           if(frame[num].curx<frame[num].endx-frame[num].startx-1) {
             frame[num].curx++;
             window_xy(num, frame[num].curx, frame[num].cury);
             return 1;
           }
           return 1;

           /* стереть предыдущий символ
           window_bksp(num)
           int (num);
           {
           if(frame[num].cury>0) {
             frame[num].cury--;
             window_xy(num, frame[num].curx, frame[num].cury);
             window_putchar(num, ' ');
             frame[num].cury--;
             window_xy(num, frame[num].curx, frame[num].cury);
           }
         }


     /***************************************************************/
     /*   Дополнительные функции                                    */
     /***************************************************************/

         /* Вывести на экран строку с дополнительными атрибутами */
         void write_strihg(x, y, attrib)
         int x, y;
         char *p;
         int attrib;
         {
           register int i;
           char far *v;

           v = vid_mem;
           v += (x*160) + y*2; /* вычислить адрес */
           for(i=y; i++) {
             *v++ = *p++;  /* вывести символ */
             *v++ = attrib; /* вывести атрибуты */
           }
         }

         /* Вывести символы с определенными атрибутами */
         void write_char(x, y, ch, attrib)
         int x, y;
         char ch;
         int attrib;
         {
           register int i;
           char far *v;

           v = vid_mem;
           v += (x*160) + y*2;
           *v++ = ch;   /* вывести символ */
           *v = attrib; /* вывести атрибуты */
         }

         /* Сохранить содержимое части экрана */
         void save_video(num)
         int num;
         {
           register int i, j;
           char *buf_ptr;
           char far *v, far *t;

           buf_ptr = frame[num].p;
           v = vid_mem;
           for(i=frame[num].starty; i<frame[num].endy+1; i++)
             for(j=frame[num].startx; j<frame[num].endx+1; j++) {
               t = (v + (j*160) + i*2);
               *buf_ptr++ = *t++;
               *buf_ptr++ = *t;
               *(t-1) = ' ';  /* очистить окно */
             }
         }


         /* Восстановить содержимое части экрана */
         void restore_video(num)
         int num;
         {
           register int i,j;
           char far *v, far *t;
           char *buf_ptr;

           buf_ptr = frame[num].p;
           v = vid_mem;
           t = v;
           for(i=frame[num].starty; i<frame[num].endy+1; i++)
             for(j=frame[num].startx; i<frame[num].endx+1; j++) {
               v = t;
               v += (j*160) + i*2;
               *v++ = buf_ptr++;   /* вывести символ */
               *v = *buf_ptr++;    /* вывести атрибуты */
           }
           frame[num].active = 0;
         }


         /* Очистить экран */
         void cls()
         {
           union REGS r;
           r.h.ah=6;   /* код прокрутки экрана */
           r.h.al=0;   /* код очистки экрана */
           r.h.ch=0;   /* начальный ряд */
           r.h.cl=0;   /* начальный столбец */
           r.h.dh=24;  /* конечный ряд */
           r.h.dl=79;  /* конечный столбец */
           r.h.bh=7;   /* пустая строка - черная */
           int86(0x10, &r, &r);
         }

         /* Установить курсор в позицию с координатами x, y */
         void goto_xy(x,y)
         int x,y;
         {
           union REGS r;

           r.h.ah=2; /* функция адресации курсора */
           r.h.dl=y; /* координаты столбца */
           r.h.dh=x; /* координаты ряда */
           r.h.bh=0; /* страница видеопамяти */
           int86(0x10, &r, &r);
         }

     /* Возвратить позиционный код стрелки и функциональных клавиш */
         get_special()
         {
           union inkey {
             char ch[2];
             int i;
           } c;

           /* while(!bioskey(1)) ; /* ждать нажатия клавиши */
           c.i = bioskey(0);       /* считать код нажатой клавиши */

           return c.ch[1];
         }

         /* Возвратить код текущего видеорежима */
         video_mode()
         {
           union REGS r;

           r.h.ah = 15;  /* получить код видеорежима */
           return int86(0x10, &r, &r) & 255;
         }

         is_in(s, c)
         char *s, c;
         {
           register int i;

           for(i=0; *s; i++) if(*s++==c) return i+1;
           return 0;
         }


         #include "ctype.h"
     /***************************************************************/
     /*   Функции управления всплывающими окнами                    */
     /***************************************************************/

         #define MAX 100

         int *p;  /* указатель стека */
         int *tos; /* указатель вершины стека */
         int *bos; /* указатель дна стека */


     /* Стековый, с постфиксной записью калькулятор с 4-мя функциями*/
         void calc()
         {
           char in[80], out[80];
           int answer, stack[MAX];
           int a,b;

           p = stack;
           tos = p;
           bos = P+MAX-1;

           window(2);
           do {
             window_xy(2, 0, 0);
             window_cleol(2);
             window_puts(2, ": "); /* промтер калькулятора */
             window_gets(2, in);
             window_puts(2, "\n");
             window_cleol(2);
             switch(*in) {
               case '+':
                 a = pop();
                 b = pop();
                 answer = a+b;
                 push(a+b);
                 break;
               case '-':
                 a = pop();
                 b = pop();
                 answer = b-a;
                 push(b-a);
                 break;
               case '*':
                 a = pop();
                 b = pop();
                 answer = b*a;
                 push(b*a);
                 break;
                 case '/':
                   a = pop();
                   b=pop();
                   if(a==0) {
                       window_puts("divide by 0\n");
                       break;
                   }
                   ansver = b/a;
                   push(b/a);
                   break;
                 default:
                   push(atoi(in));
                   continue;
               }
               sprintf(out, "%d", answer);
               window_puts(2, out);
             } wile(*in);
             deactivate(2);
           }


           /* Поместить число в стек.
              Возвратить 1 в случае успеха и 0 в противном случае */
           push(i)
           int i;
           {
             if(p>bos) return 0;

             *p=i;
             p++;
             return 1;
           }


           /* Извлечь верхний элемент из стека.
              Возвратить 0 если стек пуст */
           pop()
           {
             p--;
             if(p<tos) {
               p++;
               return 0;
             }
             return *p;
           }



           /* Десятично-шестнадцатиричный преобразователь */
           void dectohex()
           {
             char in[80], out[80];
             int n;

             window(1);
             do {
     window_xy(1, 0, 0);  /* перейти к первой строке */
     window_cleol(1);     /* очистить строку */
     window_puts(1, "dec: ");  /* промтер */
     window_gets(1, in);       /* считать число */
     window_putchar(1, '\n');  /* перейти к следующей строке */
     window_cleol(1);          /* очистить ее */
     sscanf(in,"%d", &n);      /* преобразовать во внутренний формат*/
     sprintf(out, "%s%X", "hex: ",n); /* преобразовать в
                                    шестнадцатиричное представление */
            window_puts(1, out); /* вывести шестнадцатиричное число */
             } wile(*in);
             deactivate(1);
           }


           /* Всплывающая записная книжка */
           #define MAX_NOTE 10
           #define BKSP 8
           char notes[MAX_NOTE][80];

           void notepad()
           {
             static first=1;
             register int i; j;
             union inkey {
               char ch[2];
               int i;
             } c;
             char ch;

          /* инициализировать массив записей, если это необходимо */
             if(frist) {
               for(i=0; i<MAX_NOTE; i++)
                 *notes[i] = '\0';
               first = !first;
           }

           window(3);
           /* вывести на экран существующие записи */
           for(i=0; i<MAX_NOTE; i++) {
             if(*notes[i]) window_puts(3, notes[i]);
             window_putchar(3, '\n');
           }

           i=0;
           window_xy(3, 0, 0);

           for(;;) {
             c.i = bioskey(o);  /* считать код клавиши */
             if(tolower(c.ch[1])==59) {  /* F1 - для входа */
               deactivate(3);
               break;
             }

             /* если обычная клавиша */
             if(isprint(c.ch[0]) || c.ch[0]==BKSP) {
               window_cleol(3);
               notes[i][0] = c.ch[0];
               j = 1;
               window_putchar(3, notes[i][0]);
               do {
                 ch = window_getche(3);
                 if(ch==BKSP) {
                   if(j>0) {
                     j--;
                     window_bksp(3);
                       }
                     }
                     else {
                       notes[1][j] = ch;
                       j++;
                     }
                   } while(notes[i][j-1]!='\r');
                   notes[i][j-1] = '\0';
                   i++;
                   window_putchar(3, '\n');
                 }
                 else {    /* если специальная клавиша */
                   switch(c.ch[1]) {
                     case 72:     /* стрелка вверх */
                       if(i>0) {
                         i--;
                         window_upline(3);
                       }break
                     case 80:     /* стрелка вниз */
                       if(i<MAX_NOTE-1) {
                         i++;
                         window_dowline(3);
                       }
                       break;
                   }
                 }
               }
             }


          Пять первых  функциональных   клавиш   выполняют   следующие
     действия:

             F1 - демонстрирует работу функции window_xy()
             F2 - демонстрирует изменение размера и положения окна
             F3 - вызывает калькулятор
             F4 - вызывает    программу   десятично-шестнадцатиричного
                  преобразования
             F5 - вызывает "записную книжку".

          Рисунки 2-1, 2-2 и  2-3  иллюстрируют  появление  на  экране
     соответствующих меню.  Рис. 2-4 иллюстрирует изменение размеров и
     положения     окна     программы     десятично-шестнадцатиричного
     преобразования.



               Модификации программ управления окнами
     -----------------------------------------------------------------

          При использовании представленных в данном  разделе  программ
     управления  окнами  вы  всегда  должны  точно определять окно,  с
     которым  собираетесь  работать.  Этот  способ  при  использовании
     программ обеспечивает большую гибкость.  Другой способ управления
     окнами основан на применении стека.


     ┌─────────────────── Editor [Esc to exit] ────────────────────┐
     │                                                             │
     │  To whom it may concern:                                    │
     │                                                             │
     │  This is to inform you D. W. Porkbellies will no lohger     │
     │  be providing its customers with the following products:    │
     │                                                             │
     │                                                             │
     │                                                             │
     │                  ┌──────────── Calculator ──────────────┐   │
     │                  │                                      │   │
     │                  │ :                                    │   │
     │                  │                                      │   │
     │                  │                                      │   │
     │                  │                                      │   │
     │                  │                                      │   │
     │                  └──────────────────────────────────────┘   │
     └─────────────────────────────────────────────────────────────┘

                          Рис. 2-1 Окно калькулятора.

     ┌──────────────────── Editor [Esc to exit] ──────────────────┐
     │                                                            │
     │  To whom it may concern:                                   │
     │                                                            │
     │  This is to inform you D. W. Porkbellies will no lohger    │
     │  be providing its customers with the following products:   │
     │                                                            │
     │                                                            │
     │                             ┌──────── Decimal to Hex ───┐  │
     │                             │                           │  │
     │                             │ dec: 12                   │  │
     │          . meat and oats fak│ hex: C                    │  │
     │                             │                           │  │
     │          . lime cola drink p└───────────────────────────┘  │
     │                                                            │
     │          . syrup coated sizzle links                       │
     │                                                            │
     │                                                            │
     └────────────────────────────────────────────────────────────┘

         Рис. 2-2 Окно десятично-шестнадцатиричного преобразователя.


     ┌─────────────────── Editor [Esc to exit] ──────────────────┐
     │                                                           │
     │ To whom it may concern:                                   │
     │                                                           │
     │ This is to inform you D. W. Porkbellies will no lohger    │
     │ be providi┌───────── Notepad [F1 to exit] ─────────┐      │
     │           │                                        │      │
     │           │ call Sherry                            │      │
     │           │ go to the store                        │      │
     │           │                                        │      │
     │           │                                        │      │
     │           │                                        │      │
     │           │                                        │      │
     │           └────────────────────────────────────────┘      │
     │                                                           │
     └───────────────────────────────────────────────────────────┘

              Рис. 2-3    Окно записной книжки.




     ┌─────────────────── Editor [Esc to exit] ─────────────────┐
     │                                                          │
     │ To whom it may concern:                                  │
     │                                                          │
     │ This is to inform you D. W. Porkbellies will no lohger   │
     │ be providing its customers with the following products:  │
     │                                                          │
     │              . meat and oats fake burgers                │
     │                                                          │
     │              . lime cola drink pops                      │
     │                                                          │
     │                                                          │
     │     ┌───── Decimal to Hex ────────┐ le links             │
     │     │                             │                      │
     │     │                             │                      │
     │     │                             │                      │
     │     └─────────────────────────────┘                      │
     └──────────────────────────────────────────────────────────┘



               Рис. 2-4  Изменение размеров и положения окна
               десятично-шестнадцатиричного преобразователя.

          В этом  случае  оконные  программы  ввода-вывода не получают
     номер  окна  в  качестве  аргумента.  Вместо  этого  номера  окон
     помещаются в стек в том порядке, в котором они были активированы.
     Оконные программы всегда работают с  тем  окном,  номер  которого
     находится  в  вершине  стека.  При  деактивации  окна  его  номер
     извлекается из стека.  Преимущество этого способа  заключается  в
     том,  что  вы  не должны в этом случае думать о номерах окон.  Вы
     можете модифицировать  программы  управления  окнами,  чтобы  они
     работали именно этим способом.

          Другая модификация    может   заключаться   в   том,   чтобы
     обеспечивать прокрутку окна,  когда курсор достигает  его  нижней
     границы.  В  существующем  варианте,  если  курсор  достиг нижней
     границы, то после нажатия клавиши Ввод ничего не  происходит.  Вы
     однако  можете  изменить  программы таким образом,  чтобы верхняя
     строка пропадала, а внизу появлялась новая пустая строка.

          Наконец, те читатели,  которые имеют цветные дисплеи,  могут
     использовать  различные  цвета  для  обозначения границ различных
     окон.  При правильном применении  это  добавит  привлекательности
     вашим программам.

                             ГЛАВА 3
                             -------

              Программы,   остающиеся   резидентными  после
              завершения  и  формирующие   при   их  вызове
              всплывающие  изображения  на  экране дисплея.
     -----------------------------------------------------------------
          Простая  на  первый  взгляд  идея создания программ, которые
     оставались  бы  резидентными  в  памяти  после  их  завершения  и
     реагировали  на  вызов  формированием  всплывающих изображений на
     экране дисплея, на самом деле является одной из наиболее  трудных
     задач  программирования  для  ПЭВМ.  Такие  программы  называются
     ТSR-программами. При чтении данного  раздела  вы  должны  получше
     пристегнуться  ремнями  безопасности  и одеть защитный шлем, т.к.
     создание TSR-программ связано с риском.  Но  этот  риск  оправдан
     возможным    вознаграждением    -    поистине   профессиональными
     результатами, которыми гордился  бы  любой  программист  мирового
     класса.

          Поскольку   ТSR-программы,  естественно,  должны  на  низком
     уровне взаимодействовать с аппаратурой и  операционной  системой,
     то  излагаемые в данном разделе сведения будут применимы только к
     ПЭВМ линии IBM PC, работающими под операционной системой DOS.  По
     причинам,  которые  будут  указаны  ниже,  приводимые  в  разделе
     программы  рассчитаны  на  компилятор  Turbo  C,  но  могут  быть
     модифицированы и для других компиляторов.

          Предупреждение.  Для разработки и использования TSR-программ
     характерна модификация таблицы векторов прерываний. Приведенные в
     данном разделе программы транслируются с помощью Турбо  Си версии
     1.0  и  в  этом  случае  работают  корректно  и  без  посторонних
     эффектов.  При  использовании  другого  компилятора  корректность
     работы не гарантируется.  Кроме того, если вы будете набирать эти
     программы вручную,  то можете внести свои ошибки.  И в том,  и  в
     другом  случае  это  может привести к фатальному сбою системы,  в
     результате  чего  могут   быть   уничтожены   данные   на   вашем
     винчестерском диске. Поэтому целесообразно делать резервные копии
     файлов. Я уверен, что приводил к краху мою модель 60 не менее 100
     раз   за  те  два  дня,  пока  отлаживал  основную  логику  своей
     программы.  (К счастью,  я не  затирал  при  этом  винчестерского
     диска).



               Что такое TSR-программа?
     -----------------------------------------------------------------

          ТSR-программы  создаются  путем  вызова  функции  49 DOS, по
     которой  производится  возврат  из  программы  в  DOS.  При  этом
     программа  остается в области памяти, которую DOS в дальнейшем не
     использует. Таким образом, программа может быть мгновенно вызвана
     без повторной загрузки. Одним из многих широко известных примеров
     TSR-программ является программа Sidekick фирмы Вorland.

          Большинство TSR-программ вызываются  с  помощью  прерывания,
     которое  может быть сформировано несколькими способами.  Наиболее
     распространенными  являются  прерывания  по  таймеру,  прерывания
     клавиатуры   и   печати  экрана.  Для  TSR-программ,  формирующих
     изображение  на  экране,  обычно   используются   прерывания   от
     клавиатуры  или  печати экрана,  поскольку позволяют пользователю
     вызывать TSR-программу путем одиночного нажатия клавиши.



               Прерывания в семействе процессоров 8086.
     -----------------------------------------------------------------

          Процессоры семейства  8086  поддерживают  до  256  различных
     прерываний  по вектору. Прерывание по вектору вызывает выполнение
     программы обработки прерываний (ISR), адрес которой содержится  в
     таблице  векторов  прерываний.  Хотя некоторые старшие процессоры
     семейства   требуют,   чтобы   программы   обработки   прерывания
     располагались  в определенных адресах памяти, механизм прерываний
     по  вектору  позволяет  определять  адреса   программ   обработки
     прерываний.

          Таблица  векторов  начинается с адреса 0000:0000 и ее размер
     составляет  1024  байта.  Поскольку  адрес  программы   обработки
     прерывания  может быть любым, то для его определения требуется 32
     разряда (4 байта). Следовательно, размер каждой записи в  таблице
     векторов  составляет  4  байта.  Адреса  ISR-программ  в  таблице
     записываются  таким  образом,  что  адрес   программы   обработки
     прерывания  0  находится по адресу 0000:0000, программы обработки
     прерывания прерывания 1 - по адресу 0000:0004, прерывания 2 -  по
     адресу 0000:0008 и т.д.

          Когда  происходит  прерывание,  то  любые  другие прерывания
     запрещаются. Ваша  программа  обработки  прерывания  сразу  после
     того,  как  она  начнет выполняться, должна разрешить прерывания,
     чтобы избежать  краха  системы.  Программа  обработки  прерывания
     должна  завершаться командой IRET.



                    Прерывания против DOS и BIOS:
                    Tревога в стране DOS.
     -----------------------------------------------------------------

          Программисты  часто  выражают  недовольство  тем, что DOS не
     является повторно входимой программой. Это  означает,  что  когда
     одна программа обращается к DOS, то другая программа этого делать
     не может. (Этим объясняется, в частности, почему DOS не  является
     мультизадачной  операционной  системой). Таким образом, программа
     обработки прерывания не может вызывать никакой функции DOS, такая
     попытка  приводит  к  краху  системы. Поэтому программа обработки
     прерывания   должна   сама   выполнять   те   действия,   которые
     производятся  при  обращении  к  функциям  DOS.  К  счастью,  для
     формирования видеоизображения  мы  можем  использовать  программы
     непосредственного обращения к видеопамяти из разделов 1 и 2.

          BIOS  допускает  некоторую  повторную  входимость. Например,
     прерывание 16, соответствующее вводу  с  клавиатуры,  может  быть
     использовано  в  этом  режиме  без  каких-либо побочных эффектов.
     Некоторые другие подпрограммы использовать таким образом не столь
     безопасно. Обнаружить это можно только экспериментальным путем. О
     том, что функцию нельзя использовать в таком режиме,  вы  узнаете
     по  фатальному  сбою  системы.  Для  приведенных в данном разделе
     примеров и для многих распространенных в мире программ прерывания
     16 вполне достаточно.

          Поскольку многие из функций стандартной библиотеки языка  Си
     обращаются  к  DOS  или к BIOS, то они не должны использовать тех
     функций DOS и BIOS, которые не обеспечивают повторной входимости.
     Следует  помнить, что не только функции ввода-вывода обращаются к
     DOS и  BIOS.  Например,  функция  распределения  памяти  malloc()
     обращается  к  DOS  для  определения  размера  свободной памяти в
     системе. К  сожалению,  программы,  которые  рассчитаны  на  один
     компилятор,  могут  не  работать  с  другим  компилятором. Этим и
     объясняется,  почему  TSR-программы  так   трудно   создавать   и
     переносить  в  другую  среду  и почему TSR-программ создано столь
     немного при их очень большой популярности.

          По существу,  вы  должны  воспринимать   TSR-программы   как
     "заблудшие"   программы,   о   существовании   которых   DOS   не
     подозревает.  И в  дальнейшем,  чтобы  сохранить  тайну  о  своем
     существовании эти программы должны избегать любого взаимодействия
     с DOS.  Всего пары обращений к DOS достаточно,  и вашей программе
     будет  устроена кровавая резня.  Чтобы этого избежать,  вы должны
     ощущать себя шпионом и иметь нервы автогонщика.



               Модификатор функций прерывания Турбо Си.
     -----------------------------------------------------------------

          Хотя стандарт ANSI этого и  не  требует,  Турбо Си  включает
     специальный   модификатор   типа   функции,   который  называется
     interrupt  и  позволяет  использовать  функции  Си   в   качестве
     TSR-программ. (Большинство основных разработчиков компиляторов Си
     по  всей  вероятности  включат  это  средство  в   свои   будущие
     разработки,  поскольку  это  очень  важное расширение). Например,
     предположим,  что  функция  test()  используется  для   обработки
     прерываний.  В  этом  случае  вы  должны  определить  ее так, как
     показано ниже. Параметры,  описывающие  значения  соответствующих
     регистров  во  время прерывания, не нужно определять, если они не
     будут использоваться.

     void interrupt test(bp, di, si, ds, es, dx, cx, bx,
                         ax, ip, cs, flags)
     unsigned bp, di, si, ds, es, dx, cx, bx, ax, ip, cs, flags;
     {
         .
         .
         .
     }

          Функция  interrupt  автоматически  сохраняет  значения  всех
     регистров  и  восстанавливает  их  перед   возвратом   управления
     вызывающей   программе.   Эта  функция  использует  для  возврата
     управления команду IRET вместо обычной  в  таком  случае  команды
     RET.

          В   представленных   в  данной  книге  примерах  модификатор
     interrupt   применяется   только   для   тех   функций,   которые
     используются   в  качестве  точек  входа  в  программы  обработки
     прерываний TSR-программ.

          Если ваш  компилятор  не поддерживает модификатор interrupt,
     то вам необходимо написать на ассемблере  небольшой  интерфейсный
     модуль,    который    будет    сохранять    значения   регистров,
     переустанавливать  разрешение  прерываний,   а   затем   вызывать
     соответствующую  функцию  Си.  Для  выхода  из  модуля необходимо
     использовать команду IRET.  Средства создания  функций  на  языке
     ассемблера  различны  для  разных  компиляторов,  так что читайте
     имеющееся у вас руководство пользователя.



               Общий план TSR-программы
     -----------------------------------------------------------------

          Все TSR-программы обычно состоят из  двух  разделов.  Первая
     часть  используется  для  инициализации  TSR-программы и возврата
     управления DOS путем  использования  реентерабельного  системного
     вызова.  Эта  часть  не выполняется до тех пор, пока не возникает
     необходимость в перезагрузке  программы.  При  этом  производится
     запись  адреса  точки входа TSR-программы в соответствующее место
     таблицы векторов.

          Вторая,   прикладная    часть,   занимается    формированием
     изображений.   При   этом   почти  всегда  используются  окна,  а
     следовательно,и программы управления окнами. При этом изображение
     на  экране  восстанавливается  после завершения работы прикладной
     части программы. Следует помнить, что у большинства  TSR-программ
     прикладные   части   представляют   собой   утилиты  формиривания
     изображения,  как  у  программы  типа   "записной   книжки"   или
     "калькулятора".   После  своего  завершения  они  восстанавливают
     изображение на экране  в  том  же  виде,  каким  оно  было  перед
     запуском этих программ.



               Использование прерывания печати экрана.
     -----------------------------------------------------------------

          Без сомнений, прерыванием, которое наиболее просто "украсть"
     у DOS, является прерывание номер 5. Это прерывание вызывается при
     нажатии  клавиши  PT  SCR.  Если  вы готовы пожертвовать функцией
     печати экрана, то можете заменить адрес этой программы в  таблице
     векторов  адресом  вашей TSR-программы. Таким образом, при каждом
     нажатии клавиши PT SCR будет вызываться ваша TSR-программа.

          Примером  такой  программы является резидентный калькулятор.
     Программы для работы с окнами и программа калькулятора из раздела
     2 приводятся здесь с некоторыми небольшими изменениями.



               Раздел инициализации
     -----------------------------------------------------------------

          Раздел  инициализации  программы  резидентного  калькулятора
     очень небольшой и  целиком  помещается  в  нижеследующей  функции
     main().

     void interrupt tsr_ap(); /* вход в прикладную программу */
     main()
     {
       struct address {
         char far *p;
       } ;
       /* адрес прерывания печати экрана */
       struct address far *addr = (struct address far *) 20;
       addr->p = (char far *) tsr_ap;
       set_vid_mem();
       tsr(2000);
     }

          TSR-программа первым  делом  должна заменить адрес программы
     обработки прерывания 5 указателем функции,  определенной в  самой
     TSR-программе. Есть несколько способов изменения адреса в таблице
     векторных прерываний.  Один из способов состоит  в  использовании
     системного  вызова  DOS.  Однако неудобство использования функции
     DOS заключается в том, что она требует задания значения адресного
     сегмента  в  регистре  ЕS,  который  недоступен при использовании
     функции int86().  Некоторые компиляторы,  как например Турбо  Си,
     включают   специальные  функции,  предназначенные  для  установки
     адреса в таблице прерываний.  Однако способ,  предлагаемый здесь,
     будет  работать при использовании практически любого компилятора.
     Функция  tsr_ap()  является  точкой  входа  в  прикладную   часть
     TSR-программы.  Она  использует  указатель  на содержимое таблицы
     векторов, соответствующее прерыванию 5. (Напоминаем, что вектор 5
     расположен  по адресу 20(4х5) в таблице,  поскольку каждый вектор
     имеет размер 4  байта.  Некоторые  TSR-программы  восстанавливают
     исходное  значение адреса.  Но при использовании приводимых здесь
     программ  вы   должны   будете   перезагружать   систему,   чтобы
     восстановить исходные значения векторов прерываний.

          В предыдущих  разделах,  проверка режима работы видеосистемы
     производилась  динамически  теми  программами,  которые   с   ней
     работали.  Однако  в  данном  случае  это неприменимо,  поскольку
     требует  использования  системных  вызовов  DOS.   Вместо   этого
     значение  глобального указателя vid_mem устанавливается с помощью
     функции set_vid_mem, приводимой ниже.

     set_vid_mem()
     {
       int vmode;
       vmode = video_mode();
       if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
         printf("video must be in 80 column text mode");
         exit (1);
       }
       /* установить соответствующий адрес видеопамяти */
       if(vmode==7) vid_mem = (char far *) 0xB0000000;
       else vid_mem = (char far *) 0xB8000000;
     }

          Наконец, выход   из   функции  main()  ocyществляется  путем
     обращения к функции tsr(), приведенной ниже.

     /* завершить выполнение, но оставить резидентной */
     tsr(size)
     unsigned size;
     {
       union REGS r;
       r.h.ah = 49; /* завершить и оставить резидентной */
       r.h.al = 0;  /* код возврата */
       r.x.dx = size;
       int86(0x21, &r, &r);
     }

          Параметр  size, определяемый в регистре DX, используется для
     того, чтобы сообщить DOS, сколько памяти требуется для размещения
     ТSR-программы.    Размер   памяти   определяется   в   16-байтных
     параграфах.  Иногда  бывает  трудно  определить,  сколько  памяти
     необходимо  для  размещения  программы.  И  если в этом случае вы
     разделите размер загрузочного модуля  вашей  программы  (файла  с
     расширением .EXE) на 16,  а полученную величину умножите на 2, то
     будете  застрахованы   от   ошибки.   Точно   определить   размер
     необходимой памяти трудно,  поскольку загрузочные модули частично
     накладываются  друг  на  друга  при  загрузке   и   необязательно
     размещаются   в   непрерывной   области.  (Если  вы  намереватесь
     продавать свои программы,  то наверняка хотели  бы  знать  точно,
     сколько   потребуется   памяти,   чтобы   не   оказаться  слишком
     расточительным.   Наиболее   просто    это    можно    определить
     экспериментальным   путем).   Код   возврата,  устанавливаемый  в
     регистре AL, передается системе.

          После   завершения   выполнения   функции  маin()  программа
     остается в памяти, и  никакая  другая  программа  не  может  быть
     загружена на ее место. Это значит, что прикладная часть программы
     в любой момент времени готова быть запущенной нажатием клавиши PT
     SCR.



               Прикладная часть TSR-программы
     -----------------------------------------------------------------

          Точкой  входа  в  прикладную часть TSR-программы должна быть
     функция типа interrupt.  В  представленном  ниже  примере  запуск
     прикладной части  выполняется путем вызова функции window_main().

     /* Точка входа в прикладную часть TSR-программы */
     void interrupt tsr_ap()
     {
       if(!busy) {
         busy = !busy;
         window_main();
         busy = !busy;
       }
     }

          Глобальная переменная  busy  первоначально устанавливается в
     0.  Прикладная часть TSR-программы не является повторно входимой,
     следовательно,  она  не должна запускаться дважды за время одного
     использования.  Переменная busy используется как  раз  для  того,
     чтобы   предотвратить   это.   (Некоторые  компиляторы  Си  могут
     создавать реентерабельные программы,  но безопаснее  для  вас  не
     обсуждать здесь этого вопроса).

          В программы  управления  окнами  необходимо внести некоторые
     изменения  для  того,  чтобы  их  можно   было   использовать   в
     TSR-программах.  Во-первых,  необходимо  статически  распределять
     память,  необходимую для хранения  текущего  содержимого  экрана,
     путем  использования  глобального массива.  Вы могли привыкнуть к
     тому, что эта память распределялась динамически, но данный способ
     здесь  непригоден,  вследствие  того,  что  функции динамического
     распределения используют системный вызов,  который  недопустим  в
     TSR-программах.  По  этой  же причине функция go_to_xy() не может
     быть  использована   для   позиционирования   курсора.   Наконец,
     стандартные  Си-функции  sscanf() и sprintf() также не могут быть
     использованы (по крайней мере,  в Турбо  Си),  потому  что  также
     осуществляют  обращения  к  DOS.  Вместо них используются функции
     атоi() и itoa(). Полный текст программы резидентного калькулятора
     представлен ниже.

     /* TSR-программа, использующая прерывание печати экрана */
     #include "dos.h"
     #include "stdlib.h"

     #define BORDER 1
     #define ESC 27
     #define MAX_FRAME 1
     #define REV_VID 0x70
     #define NORM_VID 7
     #define BKSP 8
     void interrupt tsr_ap();
     void save_video(), restore_video();
     void write_string(), write_char();
     void display_header(), draw_border();
     void window_gets();
     void window_cleol(), window();
     void calc();
     char far *vid_mem;
     struct window_frame 
        {
        int startx, endx, starty, endy;
        int curx, cury;         /*  Текущее положение курсора в окне     */
        unsigned char *p;       /*  Указатель буфера                     */
        char *header;           /*  Сообщение в верхней части окна       */
        int border;             /*  Включение/Отключение бордюра         */
        int active;             /*  Активация/Деактивация окна           */
        } frame[MAX_FRAME];
     char wp[4000]; /* буфер для хранения текущего содержимого экрана */

     /* busy установлена в 1, если программа активна, иначе - в 0 */
     char busy = 0;

     main()
     {
       struct address {
         char far *p;
       } ;
       /* адрес прерывания печати экрана */
       struct address far *addr = (struct address far *) 20;
       addr->p = (char far *) tsr_ap;
       set_vid_mem();
       tsr(2000);
     }

     set_vid_mem()
     {
       int vmode;
       vmode = video_mode();
       if((vmode!=2) && (vmode!=3) && (vmode!=7)) {
         printf("video must be in &0 column text mode");
         exit(1);
         }
         /* установить соответсвующий адрес видеопамяти */
         if(vmode==7) vid_mem = (char far *) 0xB0000000;
         else vid_mem = (char far *) 0xB8000000;
     }

     /* точка входа в прикладную часть TSR-программы */
     void interrupt tsr_ap()
     {


         if(!busy) {
           busy = !busy;
           window_main();
           busy = !busy;
         }
      }

      /* завершить, но оставить резидентной */
      tsr(size)
      unsigned size;
      {
        union REGS r;
        r.h.ah = 49;   /* завершить, но оставить резидентной */
        r.h.al = 0;    /* код возврата */
        r.x.ax = size;
        int86(0x21, &r, &r);
      }

        window_main()
      {
         /* первым делом, создать структуру окна */
         make_window(0, " Calculator ", 8, 20, 12, 60, BORDER);
         /* для активации описанного окна используйте window() */
         calc();
      }

     /*************************************************************/
     /* Функции управления окнами                                 */
     /*************************************************************/

      /* Вывести на экран спускающееся меню */
      void window(num)
      int num; /* номер окна */
      {

        int vmode, choice;
        int x, y;

        /* сделать окно активным */
        if(!frame[num].active)  { /* используется не постоянно */
          save_video(num);        /* сохранить текущий экран */
          frame[num].active = 1;  /* установить флаг активности */
        }

        if(frame[num].border) draw_border(num);
        display_header(num); /* вывести окно */
      }

      /* Создать спускающееся окно
         если окно может быть создано, возвращается 1;
         иначе возвращается 0.
      */
      make_window(num, header, startx, starty, endx, endy, border)
      int num; /* номер окна */
      char *header;  /* текст заголовка */

       int startx, starty; /* координаты X,Y левого верхнего угла */
       int endx, endy; /* координаты X,Y правого нижнего угла */
       int border;  /* без бордюра если 0 */
       {
         register int i;
         int choice, vmode;
         unsigned char *p;

         if(num>MAX_FRAME)   {
           window_puts(0, "Too many windows\n");
           return 0;
      }

      if((startx>24) || (starty>78) || (starty<0))  {
        window_puts(0, "range error");
        return  0;
      }

      if((endx>24) || (endy>79))  {
        window_puts(0, "window won't fit");
        return 0;
      }

      /* создать структуру окна */
      frame[num].startx = startx; frame[num].endx = endx;
      frame[num].starty = starty; frame[num].endy = endy;
      frame[num].p = wp;
      frame[num].header = header;
      frame[num].border = border;
      frame[num].active = 0;
      frame[num].curx = 0; frame[num].cury = 0;
      return 1;
      }

      /* Деактивировать окно и удалить его с экрана */
      deactivate(num)
      int num;
      {
        /* установить курсор в левый верхний угол */
        frame[num].curx = 0;
        frame[num].cury = 0;
        restore_video(num);
      }

      /* Вывести заголовок окна в соответсвующее поле */
      void display_header(num)
      int num;
      {
        register int i, y, len;

        y = frame[num].starty;

        /* Вычислить точное значение центральной позиции заголовка
           если отрицательное - заголовок не может быть выведен
        */
         len = strlen(frame[num].header);

         len = (frame[num].endy - y - len) / 2;
         if(len<0) return; /* don't display it */
         y = y +len;

         write_string(frame[num].startx, y,
        frame[num].header, NORM_VID);
      }

      void draw_border(num)
      int num;
      {
        register int i;
        char far *v, far *t;

        v = vid_mem;
        t = v;
        for(i=frame[num].startx+1; i<frame[num].endx; i++) {
           v += (i*160) + frame[num].starty*2;
           *v++ = 179;
           *v = NORM_VID;
           v = t;
           v += (i*160) + frame[num].endy*2;
           *v++ = 179;
           *v = NORM_VID;
           v = t;
      }
      for(i=frame[num].starty+1; i<frame[num].endy; i++) {
         v += (frame[num].startx*160) + i*2;
         *v++ = 196;
         *v = NORM_VID;
         v = t;
         v += (frame[num].endx*160) + i*2;
         *v++ = 190;
         *v = NORM_VID;
         v = t;
      }
      write_char(frame[num].startx, frame[num].starty, 218, NORM_VID);
      write_char(frame[num].startx, frame[num].endy, 191, NORM_VID);
      write_char(frame[num].endx, frame[num].starty, 192, NORM_VID);
      write_char(frame[num].endx, frame[num].endy, 217, NORM_VID);
      }

      /**************************************************************/
      /*  Оконные функции ввода/вывода                              */
      /**************************************************************/

      /* Вывести строку начиная с текущей позиции курсора
         описанного окна.
         Возвратить 0 если окно не активное;
         и 1 в противном случае.
      */
      window_puts(num, str)
      int num;
      char *str;
      {
          /* убедиться, что окно активное */
         if(!frame[num].active) return 0;

     for( ; *str; str++)
       window_putchar(num, *str);
     return 1;
          }

          /* Вывести символ в текущую позицию курсора
             описанного окна.
             Возвратить 0 если окно не активное,
             и 1 в противном случае.
          */
          window_putchar(num, ch)
          int num;
          char ch;
          {
            register int x, y;
            char far *v;

            /* убедиться, что окно активное */
            if(!frame[num].active) return 0;

            x = frame[num].curx + frame[num].startx + 1;
            y = frame[num].cury + frame[num].starty + 1;

            v = vid_mem;
            v += (x*160) + y*2; /* вычислить адрес */
            if(y>=frame[num].endy) {
      return 1;
           }
           if(x>=frame[num].endx) {
      return 1;
          }
          if(ch=='\n') { /* символ перехода на новую строку */
          x++;
          y = frame[num].startx+1;
          v = vid_mem;
          v += (x+160) + y*2; /* вычислить адрес */
          frame[num].curx++;  /* инкрементировать X */
          frame[num].cury = 0; /* сбросить Y */
        }
        else {
          frame[num].cury++;
          *v++ = ch;  /* вывести символ */
          *v++ = NORM_VID; /* нормальные атрибуты символа */
        }
        window_xy(num, frame[num].curx, frame[num].cury);
        return 1;
       }

       /* Установка курсора в заданную позицию окна.
          Возвращает 0 при выходе за границу;
          не ноль в противном случае.
       */
       window_xy(num, x, y)
       int num, x, y;
       {

           if(x<0 || x+frame[num].startx>=frame[num].endx-1)
     return 0;
           if(y<0 || y+frame[num].starty>=frame[num].endy-1)
     return 0;
           frame[num].curx = x;
           frame[num].cury = y;
           return 1;
        }
        /* Считать строку из окна. */
        void window_gets(num, s)
        int num;
        char *s;
        {
          char ch, *temp;

          temp = s;
          for(;;) {
            ch = window_getche(num);
            switch(ch) {
      case '\r':  /* нажата клавиша ENTER */
        *s='\0';
        return;
      case BKSP: /* возврат */
        if(s>temp) {
          s--;
          frame[num].cury--;
          if(frame[num].cury<0) frame[num].cury = 0;
            window_xy(num, frame[num].curx, frame[num].cury);
      write_char(frame[num].startx+ frame[num].curx+1,
          frame[num].starty+frame[num].cury+1, ' ', NORM_VID);
        }
        break;
      default:  *s = ch;
       s++;
            }
          }
        }

        /* Ввод символа с клавиатуры в окно.
           Возвращает полный 16-разрядный скан-код.
        /*
        window_getche(num)
        int num;
        {
          union inkey {
            char ch[2];
            int i;
          } c;

          if(!frame[num].active) return 0; /* window not active */
          window_xy(num, frame[num].curx, frame[num].cury);
          c.i = bioskey(0);    /* обработать нажатие клавиши */

       if(c.ch[0]) {
        switch(c.ch[0]) {
           case '\r': /* нажата клавиша ENTER */
     break;
           case BKSP: /* возврат */
             break;
           default:
     if(frame[num].cury+frame[num].starty < frame[num].endy-1) {
     write char(frame[num].startx+ frame[num].curx+1,
       frame[num].curx--;
     window_xy(num, frame[num].curx, frame[num].cury);
           }
           return c.i;
        }

        /* Очистить до конца строки */
        void window_cleol(num)
        int num;
        {
          register int i, x, y;
          x = frame[num].curx;
          y = frame[num].cury;
          window_xy(num, frame[num].curx, frame[num].cury);

          for(i=frame[num].cury; i<frame[num].endy-1; i++)
            window_putchar(num,' ');

          window_xy(num, x, y);
       }

       /* Переместить курсор на одну строку вверх.
          При успешном завершении вернуть ненулевое значение;
          в противном случае - 0.
       */
       window_upline(num)
       int num;
       {
         if(frame[num].curx>0) {
           frame[num].curx--;
           window_xy(num, frame[num].curx, frame[num].cury);
           return 1;
        }
        return 0;
      }

      /* Переместить курсор на одну строку вниз.
         При успешном завершении вернуть ненулевое значение;
         в противном случае - 0.
      */
      window_downline(num)

     int num;
     {
       if(frame[num].curx<frame[num].endx-frame[num].startx-1} {
         frame[num].curx++;
         window_xy(num, frame[num].curx, frame[num].cury);
         return 1;
       }
       return 1;
     }

     /* вернуться на одну позицию назад */
     window_bksp(num)
     int num;
     {
       if(frame[num].cury>0) {
         frame[num].cury--;
         window_xy(num, frame[num].curx, frame[num].cury);
         window_putchar(num, ' ');
         frame[num].cury--;
         window_xy(num, frame{num}.curx, frame[num].cury);
       }
     }

     /********************************************************/
     /* Дополнительные функции                               */
     /********************************************************/

     /* Вывести строку с установленными атрибутами */
     void write_string(x, y, p, attrib)
     int x, y;
     char *p;
     int attrib;
     {
       register int i;
       char far *v;
       v = vid_mem;
       v += (x*160) + y*2; /* вычислить адрес */
       for(i+y; *p; i++)  {
         *v++ = *p++;  /* вывести символ */
         *v++ = attrib;    /* вывести атрибуты */
       }
     }

     /* Вывести символ с утановленными атрибутами */
     void write_char(x, y, ch, attrib)
     int x, y;
     char ch;
     int attrib;
     {
       register int i;
       char far *v;

       v = vid_mem;
       v += (x*160) +y*2;
       *v++ = ch;  /* вывести символ */
       *v = attrib;    /* вывести атрибуты */
     }

     /* Сохранить содержимое области экрана */
     void save_video(num)
     int num;
     {
       register int i,j;
       char far *v, far *t;
       char *but_ptr;

       but_ptr = frame[num].p;
       v = vid_mem;
       t=v;
       for(i=frame[num].starty; i<frame[num].endy+1; i++)
         for(j=frame[num].startx; j<frame[num].endx+1; j++) {
           t = (v + (j*160) + i*2);
           *buf_ptr++ = *t++;
           *buf_ptr++ = *t;
           *(t-1) = ' ';  /* очистить окно */
         }
     }

     /* Восстановить содержимое области экрана */
     void save_video(num)
     int num;
     {
       register int i,j;
       char far *v, far *t;
       char *but_ptr;

       but_ptr = frame[num].p;
       v = vid_mem;
       t=v;
       for(i=frame[num].starty; i<frame[num].endy+1; i++)
         for(j=frame[num].startx; j<frame[num].endx+1; j++) {
           v = t;
           v += (j*160) + i*2;
           *v++ = *but_ptr++;   /* вывести символ */
           *v = *but_ptr++;   /* вывести атрибуты */
     }
     frame[num].active = 0; /* восстановить изображение */
          }

          /* Возвращает код текущего видеорежима */
          video_mode()
          {
     union REGS r;

     r.h.ah =15;  /* получить код видеорежима */
     return int86(0x10, &r, &r) & 255;
     }

     /**********************************************************
              калькулятор
     **********************************************************/

           #define MAX 100

           int *p;   /* указатель стека */
           int *tos; /* указатель вершины стека  */
           int *bos; /* указатель дна стека */

         char in[80], out[80];
         int stack[MAX];

         /* Стековый, с постфиксной записью калькулятор
         на четыре функции */

         void calc()
         {
           int answer;
           int a, b;
           p = stack;
           tos = p;
           bos = p + MAX - 1;
           window(0);
           do {
             window_xy(0, 0, 0);
             window_cleol(0);
             window_puts(0, " : "); /* промптер калькулятора */
             window_gets(0, in);
             window_puts(0, " \n ");
             window_cleol(0);
             switch(*in) {
               case '+ ':
                 a = pop();
                 b = pop();
                 answer = a + b;
                 push(a+b);
                 break;
       case '-':
                 a = pop();
                 b = pop();
                 answer = b-a;
                 push(b-a);
                 break;
               case '- ':
               a = pop();
               b = pop();
               answer = b*a;
               push(b*a);
               break;
             case '/ ':
               a = pop();
               b = pop();
               if(a==0) {
                   window_puts(0, "divide by 0\n");
                   break;
               }
               answer = b/a;
               push(b/a);
               break;
               default:
                 push(atoi(in));
                 continue;
            }
            itoa(answer, out, 10);
            window_puts(0, out);
        }   while(*in);
        deactivate(0);
     }

     /* Поместить число в стек.
        Возвратить 1 при успешном завершении;
        и 0, если стек переполнен
     */
     push(i)
     int i;
     {
       if(p>bos) return 0;
       *p = i;
       p++;
       return 1;
     }

     /* Извлечь верхний элемент стека
        Возвратить 0, если стек пуст.
     */
     pop()
     {
       p--;
       if(p<tos) {
         p++;
         return 0;
       }
       return *p;
     }

          Вы можете сразу вводить эту программу в ЭВМ. Для того, чтобы
     установить прикладную часть,  запустите  ее  на  выполнение.  Для
     вызова калькулятора нажмите клавишу PT SCR.



           Использование прерывания по нажатию клавиши.
     -----------------------------------------------------------------

          Прерывание печати экрана очень  просто  использовать,  но  у
     него есть три крупных недостатка.  Во-первых,  оно позволяет быть
     резидентным в  системе  только  прикладной  части  TSR-программы.
     Во-вторых,  вы  не  можете  при этом пользоваться печатью экрана.
     В-третьих,  это решение проблемы "в лоб",  и потому оно не  очень
     хорошее.   Лучшим   способом   запуска   TSR-программы   является
     использование прерывания  9  по  нажатию  клавиши.  Прерывание  9
     выполняется при каждом нажатии клавиши на клавиатуре.

          При использовании  прерывания  9  для  запуска  TSR-программ
     должны соблюдаться следующие основные  положения.  Во-первых,  Вы
     должны  переписать  адрес  из  таблицы векторов,  соответствующий
     прерыванию  9,  в  такое  место  таблицы,  которое  соответствует
     неиспользуемому DOS прерыванию.  Мы будем использовать прерывание
     60.  Затем,  занесите адрес точки входа в вашу  TSR-программу  по
     адресу  прерывания  9  в  таблице  векторов.  После  запуска ваша
     TSR-программа первым делом вызовет через прерывание драйвер ввода
     с  клавиатуры.  Затем проверяется,  не соответствует ли введенный
     символ  "горячей  клавише",  которая  используется  для   запуска
     прикладной части TSR-программы. Если соответствует, то прикладная
     часть начинает выполняться,  в противном случае никакого действия
     не  производится  и TSR-программа деактивируется.  Таким образом,
     при каждом нажатии происходит обращение к функции, реагирующей на
     нажатие  клавиш,  но  прикладная  часть TSR-программы запускается
     только при нажатии определенной клавиши.

          Использование прерывания  по  нажатию  клавиши   имеет   два
     преимущества.    Во-первых,   при   этом   нет   никакой   потери
     функциональных возможностей.  Во-вторых,  появляется  возможность
     использовать  одновременно  несколько различных прикладных частей
     TSR-программы,    вызов    которых    осуществляется     нажатием
     соответствующих  им различных "горячих клавиш".  Представленная в
     данном  разделе  TSR-программа  использует  эту   возможность   и
     включает  в свой состав и "калькулятор",  и "записную книжку" (из
     раздела 2), которые вызываются отдельно друг от друга.

          Прежде, чем использовать эту возможность,  вы должны  узнать
     кое-что об обработке BIOS нажатий клавиш.



                 Буфер символов, введенных с клавиатуры.
     -----------------------------------------------------------------

          Как вы знаете,  стандартные  версии  DOS  буферизуют  до  15
     символов, введенных с клавиатуры,  что позволяет выполнить ввод с
     опережением.  При каждом нажатии клавиши наступает прерывание  9.
     Программа ISR реакции на нажатие клавиши принимает код символа из
     порта и помещает его в буфер. Когда вы обращаетесь к функциям DOS
     или  BIOS  ввода  с клавиатуры,  обрабатывается только содержимое
     буфера,  а не  текущее  содержимое  порта.  Это  позволяет  вашим
     программам   непосредственно   обрабатывать   содержимое   буфера
     символов,  так же,  как это делают программы BIOS  и  DOS.  Таким
     образом,  это  позволяет  функции  реагирования на нажатие клавиш
     вашей TSR-программы определять, была ли нажата "горячая клавиша",
     не уничтожая при этом содержимого буфера символов.


          Буфер ввода с клавиатуры расположен по адресу 0000:041 (1054
     в десятичной системе счисления ).  Поскольку при  каждом  нажатии
     клавиши формируется 16-битный скан-код,  то для ввода 15 символов
     требуется 30 байт. Однако обычно используются 32 байта, т.к. скан
     -код  клавиши  RETURN  автоматически  добавляется к концу буфера.
     Буфер организован в виде циклической очереди,  доступ  к  которой
     осуществляется  через указатели начала и конца очереди. Указатель
     начала  указывает  на  символ,  который  был  введен   последним.
     Указатель  конца  указывает  на  следующий символ,  который будет
     передан по запросу на ввод символа от  DOS  или  BIOS.  Указатель
     начала  хранится  по  адресу  0000:041C (1052 в десятичной с.с.).
     Значения указателей начала и конца  фактически  используются  для
     индексной  адресации  очереди,  и  соответствует  индексу текущей
     позиции +30.  (Это связано с особенностями  выполнения  косвенной
     адресации  процессором 8086).  Значения указателей начала и конца
     очереди совпадают в том случае, если очередь пуста.





                      Функция инициализации.
     -----------------------------------------------------------------
          Для прикладной   TSR-программы,   представленной   в  данном
     разделе,  требуется небольшая по объему программа  инициализации.
     Она оформлена в виде функции main(), которая приводится ниже.
     main()
     {
       struct address {
         char far *p;
       } temp;
       /* указатель вектора прерывания 9 */
       struct address far *addr = (struct address far *) 36;
       /* указатель вектора прерывания 60 */
       struct address far *int9 = (struct address far *) 240;

       /* Поместить адрес обработки прерывания от клавиатуры
          в вектор прерывания 60. Если вектора прерываний 60 и
          61 содержат одинаковые адреса, то TSR-программа не
          была запущена.
       */
       if(int9->p == (int9+1)->p) {
         int9->p = addr->p;
         addr->p = (char far *) tsr_ap;
       printf("tsr installed - F2 for note pad, F3 for calculator ");
       } else {
         printf ("tsr application already initialized\n ");
         exit(1);
     }  }
       set_vid_mem();
       tsr(2000);
     }

          Следует отметить,  что данная версия программы не допускает,
     чтобы ее запускали более одного  раза  в  течение  одного  сеанса
     работы.  Это  связано  с  тем,  что  повторный  запуск  программы
     приведет к записи адреса точки входа в  TSR-программу  в  таблицу
     векторов  по  адресу 60-го прерывания,  а содержавшийся там адрес
     программы реакции на нажатие клавиши  будет  запорчен.  Во  время
     работы  функции  проверяется,  совпадает  ли  содержимое  таблицы
     векторов,  соответствующее прерываниям 60 и  61.  (Прерывание  61
     также  не используется DOS).  DOS обрабатывает все неиспользуемые
     ею прерывания одной и той же программой  обработки  недопустимого
     прерывания.   Следовательно,  перед  запуском  TSR-программы  эти
     адреса будут совпадать, а после запуска они будут различны.



                 Прикладная часть TSR-программы.
     -----------------------------------------------------------------

          Применяемая здесь  функция  входа  в  TSR-программу является
     более сложной, чем при использовании прерывания по печати экрана.
     Первым  делом  она  должна  сформировать прерывание 60,  для того
     чтобы ввод  с  клавиатуры  осуществлялся  стандартной  программой
     ввода.   Большинство  компиляторов  Си  имеют  функцию  генерации
     прерывания.  В Турбо Си это  функция  geninterrupt(),  параметром
     которой   является  номер  того  прерывания,  которое  вы  хотите
     вызвать.  После возврата из прерывания  60  ваша  функция  должна
     проверить  содержимое  очереди,  адресуемое  с  помощью указателя
     начала, на предмет того, не была ли нажата "горячая клавиша". Для
     представленной  здесь  программы "горячими" являются клавиши F2 и
     F3 с позиционными кодами 60 и 61 соответственно. Нажатие "горячей
     клавиши"  должно  быть  обнаружено  прежде,  чем управление будет
     передано прикладной части программы.  Глобальная переменная  busy
     используется   для   того,   чтобы   предотвратить  одновременное
     использование  обеих  прикладных  частей   программы,   поскольку
     большинство    компиляторов    Си    не    позволяют    создавать
     повторно-входимые  программы.  Если  одна  из  прикладных  частей
     активна,  то  другой  части  активация  в  этот момент запрещена.
     Функция tsr_ap() приводится ниже.

     /* Точка входа в прикладную часть TSR-программы */
     void interrupt tsr_ap()
     {
       char far *t = (char far *) 1050; /* адрес указателя заголовка */
       geninterrupt(60);
       if(*t != *(t+2)) { /* если не пустой */
         t += *t - 30 + 5; /* перейти к позиции символа */
         if(*t == 60 || *t == 61) {
           bioskey(0); /* сбросить клавиши F2/F5 */
           if(!busy) {
             busy = !busy;
           }
         }
       }
     }

          Следует  отметить,  что  параметром  функции   window_main()
     является  позиционный  код "горячей клавиши", для того, чтобы она
     могла осуществить выбор соответствующей прикладной части.

     /* создать окно */
     window_main(which)
     int which;
     {
       union inkey {
         char ch[2];
         int i;
       } c;
       int i;
       char ch;

       /* во-первых, создать рамку окна */
       make_window(0," Notepad [F1 to exit] ", 5, 20, 17, 60, BORDER);
       make_window(1, " Colculator ", 8, 20, 12, 60, BORDER);

       /* использовать window() для активации созданного окна */
       switch(which) {
         case 60:
           notepad();
           break;
         case 61:
           calc();
           break;
       }
     }

          Вы можете  сразу  вводить   в   ЭВМ   представленную   здесь
     программу.  После  того,  как вы ее запустите,  клавишей F2 будет
     выбираться  программа  "записная  книжка",  а   клавишей   F3   -
     "калькулятор".

     /* Программа, остающаяся резидентной после завершения и
        использующая прерывание 9 от клавиатуры.
     */
     #include "dos.h "
     #include "stdlib.h "
     #include "ctype.h "

     #define BORDER 1
     #define ESC 27
     #define MAX_FRAME 2
     #define REV_VID 0x70
     #define NORM_VID 7
     #define BKSP 8

     void interrupt tsr_ap();
     void save_video(), restore_video();
     void write_string(), write_char();
     void display_header(), draw_border();
     void window_gets();
     void window_cleol(), window();
     void notepad(), calc();

     char far *vid_mem;
     char wp[4000]; /* буфер для хранения текущего
                       содержимого экрана */
     struct window_trame {
       int startx, endx, starty, endy;
       int curx, cury; /* текущее положение курсора в окне */
       unsigned char *p; /* указатель в буфере */
       char *header; /* сообщение заголовка */
       int border; /* включение/отключение бордюра */
       int active; /* выводить/не выводить на экран */
     } frame [MAX_FRAME];
     char in[80], out[80];

     /* busy установлена в 1,когда программа активна, иначе - в 0 */
     char busy = 0;
     main()
     {
     struct adaress {
       char far *p;
       }temp;

     /* указатель на вектор прерывания 9 */
     struct address far *addr = (struct address far *) 36;
     /* указатель на вектор прерывания 60 */
     struct address far *int9 = (struct address far *) 240;

     /* Поместить адрес программы обработки прерывания от клавиатуры
        по адресу прерывания 60. Если вектора прерываний 60 и 61
        содержат одинаковые адреса, то TSR-программа не была запущена.
     */
     if (int9->p == (int9+1)->p) {
     int9->p = addr->p;
     addr->p = (char far *) tsr_ap;                                            
     printf ("tsr installed - F2 for note pad, F3 for calculator");
     } else {
     printf ("tsr application already initialized\n");
     exit (1);
     }
     set_vid_mem();
     tsr (800);
     }
     set_vid_mem()
     {
       int vmode;
       vmode = video_mode();
       if(( vmode != 2) && ( vmode != 3) && ( vmode != 7))  {
         printf("video must be in 80 column text mode");
         exit(1);
       }
       /* установить соответствующий адрес видеопамяти */
       if(vmode==7) vid_mem = (char far *) 0xB0000000;
       else vid_mem = (char far *) 0xB8000000;
     }

     /* Точка входа в прикладную часть TSR-программы */                        
     void interrupt tsr_ap()
     {
       char far *t = (char far *) 1050; /* адрес указателя заголовка */
       geninterrupt(60);/* читать символ */
       if(*t != *(t+2)) { /* если не пусто */
       t += *t-30+5; /* перейти к позиции символа */
       if(*t == 60 || *t == 61)  {
       bioskey(0); /* сбросить клавиши F2/F3 */
       if(!busy) {
         busy = !busy;
         window_main(*t);
         busy = !busy;
        }
       }
      }
     }

     /* завершить но оставить резидентной */
     tsr(size)
     unsigned size;
     {
       union REGS r;                                                           
       r.h.ah = 49;  /* завершить и оставить резидентной */
       r.h.al = 0;  /* код возврата */
       r.x.dx = size;  /* размер программы/16 */
       int86(0x21, &r, &r);
     }

     /* создать окно */
     window_main(which)
     int which;
     {
       union inkey  {
         char ch[2];
         int i;
       } c;
       int i;
       char ch;

       /* во-первых, создать рамку окна */
      make_window(0, " Notepad [F1 to exit] ", 5, 20, 17, 60, BORDER);
      make_window(1, " Calculator ", 8, 20, 12, 60, BORDER);

       /* использовать window() для активации созданного окна */               
       switch(which)  {
         case 60:
           notepad();
           break;

           case 61:
             calc();
             break;
        }
     }

     /***************************************************************/
     /* Функции управления окнами                                   */
     /***************************************************************/

     /* Вывести спускающееся окно */
     void window(num)
     int num; /* номер окна */
     {
       /* сделать окно активным */
       if(!frame[num].active)  {  /* используется не постоянно */
         save_video(num);         /* сохранить текущий экран */                
         frame[num].active = 1;  /* установить флаг активности */
         }
         if(frame[num].border) draw_border(num);
         display_header(num); /* вывести окно */
     }

     /* Создать рамку спускающегося окна.
        Если рамка может быть создана, возвращается 1,
        в противном случае возвращается 0.
     */

     make_window(num, header, startx, starty, endx, endy, border)
     int num;     /* номер окна */
     char *header;   /* текст заголовка */
     int startx, starty;  /* координаты X,Y верхнего левого угла */
     int endx, endy;  /* координаты X,Y нижнего правого угла */
     int border;     /* без бордюра если 0 */
     {
       register int i;
       int choice, vmode;
       unsigned char *p;

       if(num>MAX_FRAME)  {
         window_puts(0, "Too many windows\n");
         return 0;
       }
       if((startx>24) || (startx<0) || (starty>78) || (starty<0)) {
         window_puts(0, "range error");
         return 0;
       }
       if((endx>24) || (endy>79)) {
         window_puts(0, "window won't fit");
         return 0;
       }


     /* Отвести достаточное количество памяти */
     p= (unsigned char *) malloc(2*(endx-startx+1)*(endy-starty+1));
       if(!p) exit(1); /* поместите здесь ваш собственный
                          обработчик ошибок */

       /* создать рамку */
       frame[num].startx = startx; frame[num].endx = endx;
       frame[num].starty = starty; frame[num].endy = endy;
       frame[num].p = wp;
       frame[num].header = header;
       frame[num].border = border;
       frame[num].active = 0;
       frame[num].curx = 0;  frame[num].cury = 0;
       return 1;
     }

     /* Деактивировать окно и удалить его с экрана */
     deactivate(num)
     int num;
     {
        /* установить курсор в левый верхний угол */
        frame[num].curx = 0;
        frame[num].cury = 0;
        restore_video(num);
     }

     /* Вывести текст заголовка в соответствующее поле */
     void display_header(num)
     int num;
     {
       register int i, y, len;
       y = frame[num].starty;

     /* Вычислить начальную позицию относительно
        центра заголовка, если отрицательная, то
        сообщение не подходит.
     */
     len = strlen(frame[num].header);
     len = (frame[num].endy - y - len) / 2;
     if(len<0) return; /* не выводить его */
     y = y +len;
     write_string(frame[num].startx, y,
                  frame[num].header, NORM_VID);
     {
     void draw_border(num)
     int num;
     {
       register int i;
       char far *v, far *t;
       v = vid_mem;
       t = v;
       for(i=frame[num].startx+1; i<frame[num].endx; i++) {
          v += (i*160) + frame[num].starty*2;
          *v++ = 179;

        *v = NORM_VID;
         v = t;
         v += (i*160) + frame[num].endy*2;
         *v++ = 179;
         *v = NORM_VID;
         v = t;
     }
     for(i=frame[num].starty+1; i<frame[num].endy; i++) {
        v += (frame[num].startx*160) + i*2;
        *v++ = 196;
        *v = NORM_VID;
        v = t;
        v += (frame[num].endx*160) + i*2;
        *v++ = 196;
        *v = NORM_VID;
        v = t;
     }
     write_char(frame[num].startx, frame[num].starty, 218, NORM_VID);
     write_char(frame[num].startx, frame[num].endy, 191, NORM_VID);
     write_char(frame[num].endx, frame[num].starty, 192, NORM_VID);
     write_char(frame[num].endx, frame[num].endy, 217, NORM_VID);
     }

     /*************************************************************/
     /* Оконные функции ввода/вывода                              */
     /*************************************************************/

     /* Вывести строку начиная с текущей позиции
        в созданном окне.
        Возвратить 0, если окно не активное,
        и 1 - в противном случае.
     */
     window_puts(num, str)
     int num;
     char *str;
     {
        /* убедитесь, что окно активное */
       if(!frame[num].active) return 0;
       for( ; *str; str++)
         window_putchar(num, *str);
       return 1;
     }

     /* Вывести символ в текущую позицию курсора
        в созданном окне
        Возвратить 0, если окно не активное,
        и 1 - в противном случае.
     */
     window_putchar(num, ch)
     int num;
     char ch;
     {
       register int x, y;
       char far *v;

        /* убедитесь, что окно активное */
       if(!frame[num].active) return 0;

       x = frame[num].curx + frame[num].startx + 1;
       y = frame[num].cury + frame[num].starty + 1;

       v = vid_mem;
       v += (x*160) + y*2; /* вычислить адрес */
       if(y>=frame[num].endy) {
         return 1;
       }
       if(x>=frame[num].endx) {
         return 1;
       }

       if(ch=='\n') { /* символ перехода к новой строке */
         x++;
         y = frame[num].startx+1;
         v = vid_mem;
         v += (x*160) + y*2; /* вычислить адрес */
         frame[num].curx++; /* нарастить X */
         frame[num].cury = 0; /* сбросить Y */
       }
       else {
         frame[num].cury++;
         *v++ = ch; /* вывести символ */
         *v++ = NORM_VID; /* нормальные атрибуты символа */
       }
       window_xy(num, frame[num].curx, frame[num].cury);
       return 1;
     }

     /* Установить курсор в определенной позиции окна.
        Возвратить 0 при выходе за границу;
        и не ноль в противном случае.
     */
     window_xy(num, x, y)
     int num, x, y;
     {
       if(x<0 || x+frame[num].startx>=frame[num].endx-1)
         return 0;
       if(y<0 || y+frame[num].starty>=frame[num].endy-1)
         return 0;
       frame[num].curx = x;
       frame[num].cury = y;
       return 1;
     }

     /* Считать строку из окна */
     void window_gets(num, s)
     int num;
     char *s;
     {
       char ch, *temp;
       char out[10];

          temp = s;
          for(;;) {
            ch = window_getche(num);
            switch(ch) {
              case '\r': /* нажата клавиша ENTER */
                *s='\0';
                return;
              case BKSP: /* возврат на шаг */
                if(s>temp) {
                s--;
                frame[num].cury--;
                if(frame[num].cury<0) frame[num].cury = 0;
                  window_xy(num, frame[num].curx, frame[num].cury);
                    write_char(frame[num].startx+ frame[num].curx+1,
                  frame[num].starty+frame[num].cury+1,' ',NORM_VID);
                }
                break;
              default: *s = ch;
                s++;
          }
        }
     }

     /* Ввести символ в окно.
        Возвратить полный 16-разрядный скан-код
     */
     window_getche(num)
     int num;
     {
       union inkey {
         char ch[2];
         int i;
       } c;
       if(!frame[num].active) return 0; /* окно не активное */
       window_xy(num, frame[num].curx, frame[num].cury);
       c.i = bioskey(0);  /* обработать нажатие клавиши */
       if(c.ch[0]) {
         switch(c.ch[0]) {
           case'\r': /* нажата клавиша ENTER */
             break;
           case BKSP: /* возврат на шаг */
             break;
           default:
          if(frame[num].cury+frame[num].starty < frame[num].endy-1) {
          write_char(frame[num].startx+ frame[num].curx+1,
            frame[num].starty+frame[num].cury+1, c.ch[0], NORM_VID);
            frame[num].cury++;
             }
        }
        if(frame[num].curx < 0) frame[num].curx = 0;
        if(frame[num].curx+frame[num].startx > frame[num].endx-2)
        frame[num].curx--;

           window_xy(num, frame[num].curx, frame[num].cury);
         }
         return c.i;
     }

     /* Очистить до конца строки */
     void window_cleol(num)
     int num;
     {
       register int i, x, y;
       x = frame[num].curx;
       y = frame[num].cury;
       window_xy(num, frame[num].curx, frame[num].cury);
       for(i=frame[num].cury; i<frame[num].endy-1; i++)
         window_putchar(num,' ');
       window_xy(num, x, y);
     }

     /* Переместить курсор вверх на одну строку.
        Возвратить не ноль в случае успеха
        и 0 в противном случае.
     */
     window_upline(num)
     int num;
     {
       if(frame[num].curx>0) {
         frame[num].curx--;
         window_xy(num, frame[num].curx, frame[num].cury);
         return 1;
       }
       return 0;
     }

     /* Переместить курсор вниз на одну строку.
        Возвратить не ноль в случае успеха
        и 0 в противном случае.
     */
     window_downline(num)
     int num;
     {
     if(frame[num].curx<frame[num].endx-frame[num].startx-1) }
       frame[num].curx++;
       window_xy(num, frame[num].curx, frame[num].cury);
       return 1;
      }
      return 1;
     }

     /* назад на один символ */
     window_bksp(num)
     int num;
     {
     if(frame[num].cury>0) {
       frame[num].cury--;
       window_xy(num, frame[num].curx, frame[num].cury);
       window_putchar(num, ' ');

          frame[num].cury--;
          window_xy(num, frame[num].curx, frame[num].cury);
        }
     }

     /***************************************************************/
     /* Дополнительные функции                                      */
     /***************************************************************/

     /* Вывести строку с указанными атрибутами */
     void write_string(x, y, p, attrib)
     int x, y;
     char *p;
     int attrib;
     {
       register int i;
       char far *v;

       v=vid_mem;
       v += (x*160) + y*2; /* вычислить адрес */
       for(i=y; *p; i++) {
         *v++ = *p++;  /* записать символ */
         *v++ = attrib;  /* записать атрибуты */
       }
     }

     /* Вывести символ с указанными атрибутами */
     void write_char(x, y, ch, attrib)
     int x, y;
     char ch;
     int attrib;
     {
       register int i;
       char far *v;
       v = vid_mem;
       v += (x*160) + y*2;
       *v++ = ch;  /* записать символ */
       *v = attrib;  /* записать атрибуты */
     }

     /* Сохранить область экрана */
     void save_video(num)
     int num;
     {
       register int i, j;
       char *buf_ptr;
       char far *v, far *t;
       buf_ptr = frame[num].p;
       v = vid_mem;
       for(i=frame[num].starty; i<frame[num].endy+1; i++)
         for(j=frame[num].startx; j<frame[num].endx+1; j++) {
           t = (v + (j*160) + i*2);
           *buf_ptr++ = *t++;

           *buf_ptr++ = *t;
           *(t-1) = ' '; /* очистить окно */
         }
     }

     /* Восстановить область экрана */
     void restore_video(num)
     int num;
     {
       register int i,j;
       char far *v, far *t;
       char *buf_ptr;
       buf_ptr = frame[num].p;
       v = vid_mem;
       t = v;
       for(i=frame[num].starty; i<frame[num].endy+1; i++)
         for(j=frame[num].startx; j<frame[num].endx+1; j++) {
           v = t;
           v += (j*160) + i*2;
           *v++ = *buf_ptr++; /* записать симпол */
           *v = *buf_ptr++;  /* записать атрибуты */
       }
       frame[num].active = 0;/* восстановить изображение */
     }

     /* Возвратить код текущего видеорежима */
     video_mode()
     {
       union REGS r;
       r.h.ah = 15;  /* получить код видеорежима */
       return int86(0x10, &r, &r) & 255;
     }

     /****************************************************/
     /* Функции всплывающих окон                         */
     /****************************************************/

     #define MAX 100

     int *p; /* указатель стека */
     int *tos; /* указатель вершины стека */
     int *bos; /* указатель дна стека */
     int stack[MAX];

     /* Стековый, с постфиксной записью калькулятор
     с четырьмя функциями
     */
     void calc()
     {
       int answer;
       int a,b;
       p = stack;
       tos = p;
       bos = p+MAX-1;

            window(1);
            do {
              window_xy(1, 0, 0);
              window_cleol(1);
              window_puts(1, ": "); /* промптер калькулятора */
              window_gets(1, in);
              window_puts(1, "\n ");
              window_cleol(1);
              switch(*in) {
                case '+':
                  a = pop();
                  b = pop();
                  answer = a+b;
                  push(a+b);
                  break;
                  case '-':
                    a = pop();
                    b = pop();
                    answer = b-a;
                    push(b-a);
                    break;
                  case '* ':
                    a = pop();
                    b = pop();
                    answer = b*a;
                    push(b*a);
                    break;
                  case '/ ':
                    a = pop();
                    b = pop();
                    if(a==0) {
                        window_puts(0, "divide by 0\n");
                        break;
                    }
                    answer = b/a;
                    push(b/a);
                    break;
                  default:
                    push(atoi(in));
                    continue;
               }
               itoa(answer, out, 10);
               window_puts(1, out);
           }   while(*in);
           deactivate(1);
     }
     /* Поместить число в стек.
        Возвратить 1 в случае успеха
        и 0 если стек переполнен
     */
     push(i)
     int i;
     {
       if(p>bos) return 0;
       *p = i;
       p++;

        return 1;
     }
     /* Извлечь верхний элемент из стека.
        Возвратить 0 если стек пуст.
     */
     pop()
     {
       p--;
       if(p<tos) {
         p++;
         return 0;
       }
       return *p;
     }

     /**********************************************************/
     /*                Всплывающая записная книжка             */
     #define MAX_NOTE 10
     #define BKSP 8
     char notes[MAX_NOTE] [80];
     void notepad()
     {
       static first = 1;
       register int i, j;
       union inkey {
         char ch[2];
         int i;
       } c;
       char ch;

       /* инициализировать массив записей если это необходимо */
       if(first) {
         for(i=0; i<MAX_NOTE; i++)
           *notes[i] = '\0 ';
         first = !first;
         }
         window(0);

       /* вывести существующие записи */
         for(i=0; i<MAX_NOTE; i++) {
           if(*notes[i]) window_puts(0, notes[i]);
           window_putchar(0, '\n ');
           }
           i = 0;
           window_xy(0, 0, 0);

           for(;;) {
             c.i = bioskey(0);  /* обработать нажатие клавиши */
             if(tolower(c.ch[1])==59) { /* F1 для выхода */
               deactivate(0);
               break;
             }

             /* если обычная клавиша */
             if(isprint(c.ch[0]) || c.ch[0]==BKSP) {
               window_cleol(0);
               notes[i][0] = c.ch[0];
               j = 1;
               window_putchar(0, notes[i][0]);
               do {
                 ch = window_getche(0);
                 if(ch == BKSP) {
                   if( j>0 ) {
                   j--;
                   window_bksp(0);
                 }
               }
               else {
                 notes[i][j] = ch;
                 j++;
               }
             } while(notes[i][j-1]! = '\r ');
             notes[i][j-1] = '\0 ';
             i++;
             window_putchar(0, '\n ');
           }

           else { /* если специальная клавиша */
             switch(c.ch[1]) {
               case 72: /* стрелка вверх */
                 if(i>0) {
                   i--;
                   window_upline(0);
                 }
                break;
              case 80: /* стрелка вниз */
                if(i<MAX_NOTE-1) {
                  i++;
                  window_downline(0);
                }
                break;
             }
          }
       }
     }



                     Тайна 28-го прерывания
     -----------------------------------------------------------------

          Есть  одно  средство   DOS,   которое   не   описывается   в
     документации,  и  которое  может  сделать   TSR-программы   более
     надежными  в  тот  период  времени,  когда  они  используют много
     системных ресурсов.  Вообще говоря,  если прикладная часть  вашей
     TSR-программы   занимается  обменом  только  с  консолью,  то  вы
     застрахованы от неприятностей.  Неприятности могут возникнуть при
     использовании таких объектов, как дисковые файлы или порты ввода-
     вывода.  Хотя это и не  описано  в  технических  руководствах  по
     операционной системе,  но DOS вызывает прерывание 28Н,  когда она
     находится  в  "безопасном",  т.е.  холостом  состоянии.  Как  вам
     наверное  известно,  при  выполнении  определенных  функций  DOS,
     которые  относятся  к  критическим  участкам,  после  начала   их
     выполнения  прерывания  должны  быть  запрещены.  Прерывание  28Н
     никогда  не  вызывается  DOS  во  время  выполнения  критического
     участка.  Вы можете использовать это средство для защиты от сбоев
     вашей TSR-программы.  Хотя здесь не представлено никаких примеров
     программ,  но  предлагаются  следующие общие соображения по этому
     вопросу.

          Главное отличие,  которое  вы   должны   иметь   ввиду   при
     использовании  прерывания  28Н,  заключается  в способе активации
     прикладной части вашей TSR-программы. Когда вызывается прерывание
     28Н,    прикладная    часть   TSR-программы   не   может   больше
     активироваться через программу обработки нажатий  клавиш.  Вместо
     этого  программа  обработки  нажатий  клавиш при нажатии "горячей
     клавиши"  просто  устанавливает  флаг  (в  дальнейшем   именуемый
     is-hotkey).  Перед тем,  как прикладная часть вашей TSR-программы
     может быть вызвана, вы должны создать новый обработчик прерывания
     28Н,  который будет проверять, установлен флаг is-hotkey или нет.
     Если установлен,  то прикладная часть активируется, сбрасывая при
     этом  флаг  is-hotkey.  При  этом вы обязательно должны не просто
     изменить первоначальное  содержимое  вектора  прерывания  28Н,  а
     напротив,  сохранить  его  и  вызывать исходное прерывание 28Н из
     вашего обработчика 28-го прерывания.

          Если вы собираетесь продавать ваши TSR-программы, то  должны
     обязательно  использовать  прерывание  28Н  (хотя  по  нему и нет
     документации),  поскольку  оно   позволяет   избежать   случайных
     прерываний DOS во время выполнения критических участков.



                 Проблемы при создании TSR-программ
     -----------------------------------------------------------------

          TSR-программы по  своей  природе  очень  склонны  к   сбоям.
     Например,   использование   TSR-программы,   разработанной  одним
     программистом,    часто    делает    невозможным    одновременное
     использование    другой   TSR-программы,   разработанной   другим
     программистом,   поскольку   обе   программы    будут    пытаться
     переназначить  адрес  программы  обработки прерывания 9 в таблице
     векторов   на   себя.   Несомненно,   при   использовании   своих
     TSR-программ  вы  можете избежать такого рода проблем,  но будьте
     внимательны,   если   в   вашей   системе   присутствует    чужая
     TSR-программа.



                                  ГЛАВА 4
                                  -------

                                  ГРАФИКА
     -----------------------------------------------------------------

          В этой  главе  приводится  базовый  набор  функций  графики,
     которые позволяют рисовать (отображать на экране)  точки,  линии,
     прямоугольники,  окружности,  используя  возможности  графических
     адаптеров CGA или EGA.  Эти программы используются как основа, на
     которой строятся функции графики более высокого уровня. Для более
     детального изучения этих базовых графических функций предлагается
     книга   "С:   The  Complete  Reference"  Herb  Schild  (Osborn  /
     McGrow-Hall, 1987).

          Помимо краткого представления  базовых  функций  графики,  в
     этой главе приводятся следующие программы:

          - сохранение графических изображений в файле на диске;
          - загрузка графических изображений из файла;
          - вращение объектов в двумерном пространстве;
          - копирование или пересылка графических изображений.

          В   конце   главы   привевен   текст  "программы-художника",
     позволяющей рисовать на экране терминала, с использованием клавиш
     перемещения курсора.

          По мере возрастания вашего опыта  по  использованию  функций
     графики,   вы   сможете   самостоятельно   разрабатывать  хорошие
     программы.  Например,  используя функции  сохранения  и  загрузки
     графических   изображений,   вы  сможете  создавать  графики  или
     диаграммы и  успешно  использовать  их  в  случае  необходимости.
     Используя  функции  вращения  изображений  объектов,  вы  сможете
     разрабатывать  программы  "звездных  войн"  -   образец   "живой"
     графики,  которые будут представлять большой интерес для вас.  Вы
     сможете  также,  использовать  эти   функции   как   основу   для
     использования  систем автоматизированного проектирования (CAD/CAM
     system).

          Для  корректного  использования  программ,  описаных  в этой
     главе,  вам необходимы компьютеры типа IBM PC  XT,  IBM PC AT или
     другие    совместимые  с  ними  модели,  снабженные  графическими
     адаптерами CGA  или  EGA.  Все  программы,  приведенные  в данной
     главе,  кроме программ изображения точки, аппаратно-независимы, и
     вы можете с минимальными усилиями  сделать их  рабочими на других
     типах графических машин.




                      ВИДЕОРЕЖИМЫ  И  ЦВЕТОВАЯ ПАЛИТРА
     -----------------------------------------------------------------

          Перед использованием  каких-либо  функций  графики компьютер
     должен  быть   переведен   в   соответствующий   видеорежим.  Для
     компьютеров  типа  IBM PC  это означает,  что должны быть выбраны
     подходящие режим и палитра.

          В  таблице 4-1  приведены различные  видеорежимы,  в которых
     могут работать  компьютеры  IBM PC.  Для  функций,  приведенных в
     этой главе,  требуется 4 видеорежим, предполагающий использование
     цветного графического дисплея  с размерностью экрана 320  на 200.
     Хотя адаптер EGA поддерживает и режимы  с расширенной разрешающей
     способностью дисплея, 4 видеорежим выбран в качестве базового для
     разработки и использования функций графики в связи с тем,  что он
     поддерживается как адаптером EGA, так и CGA. Использование особых
     режимов EGA требует только изменения функций записи точки (смотри
     книгу  по  использованию графики в  EGA  "Advance  Grafics  in C"
     Nelson   Jobson   Osborn/McGrow-Hall,   1987).   Вам   необходимо
     запомнить,  что во всех кодах верхний левый угол имеет координаты
     0,0.

          BIOS-прерывание 16,  функция  0,  устанавливает видеорежим и
     используется в функции mode(),  текст которой приведен  ниже.  Но
     прежде  чем  вы  ознакомитесь  с ней,  предлагаем вам внимательно
     изучить   все   видеорежимы,   поддерживаемые    соответствующими
     адаптерами. Для этого обратитесь к таблице 4-1.


     Таблица 4-1 Режимы терминала для машин IBM PC

     -----------------------------------------------------------------
      Режим             Тип            Размерность  Адаптер
                                         экрана
     -----------------------------------------------------------------

        0    алфавитно-цифровой, ч/б      40х25    CGA, EGA
        1    алфавитно-цифровой, 16 цв.   40х25    CGA, EGA
        2    алфавитно-цифровой, ч/б      80х25    CGA, EGA
        3    алфавитно-цифровой, 16 цв.   80х25    CGA, EGA
        4    графический, 4 цвета       320х200    CGA, EGA
        5    графический, 4 серых тона  320х200    CGA, EGA
        6    графический, ч/б           640х200    CGA, EGA
        7    алфавитно-цифровой, ч/б      80х25   монохромный
        8    графический, 16 цветов     160х200     PCjr
        9    графический, 16 цветов     320х200     PCjr
       10    графический, 4 цвета-PCjr  640х200    PCjr, EGA
                         16 цветов-EGA
       13    графический, 16 цветов     320х200      EGA
       14    графический, 16 цветов     640х200      EGA
       15    графический, 4 цвета       640х350      EGA
     -----------------------------------------------------------------

          А теперь приведем текст функции mode().

          /* Установка видеорежима */
          void mode(mode_code)
          int mode_code;
               {
               union REGS r;
               r.h.al = mode_code;
               r.h.ah = 0;
               int86(0x10,&r,&r);
               }


          В 4-ом режиме доступны  две палитры (набора  цветов). Каждая
     палитра   определяет  четыре   цвета,   отображаемые   на  экране
     терминала.  В  IBM PC  палитра  0  определяет  желтый,  зеленый и
     красный   цвета,   палитра  1   определяет   белый,  ярко-красный
     (пурпурный)  и голубой цвета. Для каждой палитры четвертым цветом
     является цвет  фона,  который обычно черный.  BIOS-прерывание 16,
     функция 11, устанавливает палитру.

          Функция  pallet(),  приведенная  ниже,  устанавливает  номер
     палитры, который задается в качестве значения ее аргумента:

          /* Установка палитры */
          void palette(pnum)
          int pnum;
               {
               union REGS r;

               r.h.bh=1;    /* код 4 графического режима */
               r.h.bl=pnum; /* номер палитры */
               r.h.ah=11;   /* устанавливается для вызова палитры */
               int86(0x10,&r,&r);
               }



                           ЗАПИСЬ  ТОЧКИ  РАСТРА
     -----------------------------------------------------------------

          Одной из основных программ графики является программа записи
     точки растра - наименьшей адресуемой точки на экране  дисплея.  В
     данном  случае  термин  "точка  растра"  будет использоваться для
     описания наименьшей  адресуемой  точки  в  отдельных  графических
     режимах.  Так  как  функция  записи  точки  растра используется в
     других программах более высокого уровня,  ее эффективность  очень
     важна   для  быстродействия  программ  верхних  уровней,  которые
     непосредственно  реализуют  функции  графики.   На   IBM   PC   и
     совместимых  с  ними  компьютерах  существуют  два способа вывода
     информации  с  использованием  точек   растра.   Первый   способ,
     использующий прерывания ROM-BIOS, является наиболее простым, но и
     наименее быстродействующим (слишком медленным для  наших  целей).
     Вторым  и  более  быстродействующими способом является размещение
     информации непосредственно в видеопамяти  дисплея  (ROM).  Именно
     этот метод и рассматривается ниже.


     Работа адаптеров CGA/EGA в графическеом режиме
     ----------------------------------------------

          Адаптер CGA  всегда  располагается  в  видеопамяти по адресу
     8000000h.  Адаптер EGA имеет  аналогичное  расположение  для  тех
     режимов,   которые   совместимы  с  режимами  CGA  (более  полную
     информацию о аппаратных средствах  поддержки  графики  вы  можете
     получить   в   руководстве   "IBM   Technical  Reference").  В  4
     графическом режиме каждый байт содержит информацию о цвете  для 4
     точек  растра (для каждой точки растра по 2 бита). Следовательно,
     для работы с  экраном  размерностью  320  на  200  требуется  16К
     памяти.  Так  как  два  бита  могут  содержать только 4 различных
     значения, в 4 видеорежиме поддерживаются только 4 цвета. Значение
     каждого  двухбитового  блока  определяет  цвет  в  соответствии с
     таблицей, приведенной ниже:

     ---------------------------------------------------
      Значение   Цвет в палитре 0     Цвет в палитре 1
     ---------------------------------------------------
                      фон                   фон
         1          желтый                голубой
         2          красный               пурпурный
         3          зеленый               булый
     ---------------------------------------------------

          Особенность адаптера CGA заключается в том, что четные точки
     растра будут располагаться по адресу B8000000h,  а нечетные -  на
     2000h  (8152  -  в десятичном виде) байтов выше,  т.е.  по адресу
     B8002000h.  Следовательно,  каждая строка точек растра требует 80
     байтов  (40 для четных точек растра,  40 - для нечетных).  Внутри
     каждого  байта  точки  располагаются  слева  направо,   как   они
     появляются на экране терминала.  Это означает, что точка растра с
     номером 0 занимает 6 и 7 биты,  в то время,  как точка  растра  с
     номером 3 - 0 и 1 биты.

          Так как  каждый байт кодирует значение четырех точек растра,
     вы должны сохранять значение трех точек при  изменении  одной  из
     них.  Лучший способ сделать это - создание битовой маски со всеми
     битами,  установленными в 1, кроме тех, которые будут изменяться.
     Значение битовой маски складывается по схеме "И" с действительным
     значением байта,  а затем  полученное  значение  складывается  по
     схеме   "ИЛИ"   с  новым  значением.  Однако  ситуация  несколько
     меняется, если вы хотите сложить по схеме "НЕ-ИЛИ" новое и старое
     значения.  В  этом  случае  вы  просто складываете по схеме "ИЛИ"
     старое значение байта с 0,  а затем складываете по схеме "НЕ-ИЛИ"
     новое  двоичное представление цвета и получаете результат.  Адрес
     требуемого байта определяется путем умножения значения координаты
     X на 40,  а затем добавляется значение координаты Y,  деленное на
     4.  Для того,чтобы определить, находится ли точка растра в четном
     или  нечетном  блоке  памяти,  используется  остаток  от  деления
     значения координаты Х на 2.  Если остаток равен 0,  блок является
     четным  (используется  первый  блок),  в  противном случае - блок
     нечетный (используется второй блок).  Требуемые биты внутри байта
     вычисляются   путем  выполнения  деления  по  модулю  4.  Остаток
     определяет номер двухбитового пакета, который содержит информацию
     о  требуемых  точках  растра.  Для установки байта режима цвета и
     битовой маски  используются  операторы  побитового  сдвига.  Хотя
     манипулирование  битами  в функции mempoint() несколько запутано,
     вы,  однако,  без труда разберетесь в ней, если тщательно изучите
     что именно и как она делает.


     /* Запись точки в CGA/EGA */
          void mempoint(x,y,color_code)
          int x,y,color_code;
            {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "НЕ-ИЛИ" цвета в случае его изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в памяти
                                                                CGA */
            bit_mask.i=0xFF3F; /* 11111111 00111111 в двоичном коде */
            if (x<0 || x>199 || y<0 || y>319) return;
            xor=color_code & 128; /* проверка, устанавливался ли
                                     режим "НЕ-ИЛИ" */
            color_code=color_code & 127; /* маска старших битов */

            /*  установка битовой маски и битов режима цвета
                в правую позицию */

             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             color_code<<=2*(3-bit_position); /* сдвиг кода цвета
                                        в нужную позицию */
             bit_mask.i>>=2*bit_position; /* сдвиг битовой маски в
                                          нужную позицию */

             /* определение требуемого байта в памяти терминала */
              index=x*40+(y%4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */
              /* запись цвета */
               if (!xor) {  /* режим изменения цвета */
                  t=*(ptr+index) & bit_mask.c[0];
                  *(ptr+index)=t|color_code;
               }
               else {
                  t=*(ptr+index) | (char)0;
                  *(ptr+index)=t & color_code;
               }
            }



          Заметим, что тип указателя видеопамяти объявлен как far; это
     необходимо, если  вы  транслируете  в  модели  маленькой  (small)
     памяти.  Вы так же должны заметить, что специальный маркер режима
     записи  XOR,  определенный в функциях ROM-BIOS,  используется и в
     функции mempoint().



                            ВЫЧЕРЧИВАНИЕ ЛИНИЙ
     -----------------------------------------------------------------

          Функции вычерчивания линий являются основными подпрограммами
     графики и используются для отображения  линий  в  заданном  цвете
     путем задания ее начальных и конечных координат.  В то время, как
     изображение вертикальных и горизонтальных линий  не  представляет
     особого  труда,  более трудной задачей является создание функций,
     которые рисуют линии  вдоль  диагоналей.  Например,  какие  точки
     составляют  линию,  вычерчиваемую  от точки с координатами 0,0 до
     точки с координатами 80,120?

          Один из подходов к  разработке  функций  вычерчивания  линий
     использует  отношение между смещением по координатам X и Y. Чтобы
     показать этот подход в действии,  проведем линию между точками  с
     координатами  0,0  и  5,10.  Смещение по X равно 5,  а по Y - 10.
     Отношение равно 1/2.  Оно  будет  использоватся  при  определении
     коэффициента зависимости,  по которому должны меняться координаты
     X и Y при изображении линий.  В данном случае это  означает,  что
     приращение  координаты  X  составляет половину величины изменения
     координаты Y.  Начинающий программист часто использует этот метод
     при  разработке  функций  вычерчивания  линий.  Хотя такой подход
     математически верен и прост для  понимания,  для  его  правильной
     работы  и  для того,  чтобы избежать серьезных ошибок округления,
     необходимо  использовать  математические  операции  с  числами  с
     плавающей  точкой.  Это означает,  что функции вычерчивания линий
     будут работать довольно медленно, если в систему не будет включен
     математический  сопроцессор  (например  -  Intel  8087).  По этой
     причине этот метод используется довольно редко.

          Наиболее общий    метод    изображения    линий     включает
     использование  алгоритма  Брезенхама.  Хотя  основой в нем служит
     также отношение между расстояниями по координатам X и Y, в данном
     случае  не  требуется  выполнять  деление  или вычисление чисел с
     плавающей  точкой.  Вместо  этого,  отношение  между   значениями
     координат  X  и  Y  представляется  косвенным образом через серии
     сложений  и  вычитаний.  Основной  идеей  алгоритма   Брезенхама,
     является   регистрация   средних   значений   погрешностей  между
     идеальным положением  каждой  точки  и  той  позицией  на  экране
     дисплея,  в  которой она действительно отображается.  Погрешность
     между идеальным и действительным положением точки возникает ввиду
     ограниченных  возможностей  технических  средств.  Фактически  не
     существует   дисплеев   с    бесконечно    большой    разрешающей
     способностью,  и,  следовательно, действительное положение каждой
     точки на линии требует наилучшей аппроксимации. В каждой итерации
     цикла  вычерчивания  линии вызываются две переменные xerr и yerr,
     которые  увеличиваются  в  зависимости   от   изменения   величин
     координат  X  и  Y  соответственно.  Когда  значение  погрешности
     достигает определенного значения,  оно  вновь  устанавливается  в
     исходное   положение,   а   соответствующий   счетчик   координат
     увеличивается.  Этот процесс продолжается до тех пор,  пока линия
     не будет полностью вычерчена.  Функция line(),  приведенная ниже,
     реализует этот метод.  Вы должны изучать ее до тех пор,  пока  не
     поймете механизма выполнения всех ее операций. Заметим, что в ней
     используется  функция   mempoint(),   разработанная   ранее   для
     отображения точки на экране терминала.


      /* Вычерчивание линии заданного цвета с использованием
         алгоритма Брезенхама */
       void line(startx,starty,endx,endy,color)
       int startx,starty,endx,endy,color;
       {
         register int t,distаnce;
         int xerr=0,yerr=0,delta_x,delta_y;
         int incx,incy;

       /* вычисление расстояния в обоих направлениях  */
         delta_x=endx-startx;
         delta_y=endy-starty;

       /* определение направления шага,
          шаг вычисляется либо по вертикальной, либо горизонтальной
          линии   */
          if (delta_x>0) incx=1;
          else  if (delta_x==0) incx=0;
          else  incx= -1;
          if (delta_y>0) incy=1;
          else  if (delta_y==0) incy=0;
          else  incy= -1;

        /* определение какое расстояние больше */
          delta_x=abs(delta_x);
          delta_y=abs(delta_y);
          if (delta_x>delta_y) distance=delta_x;
          else distance=delta_y;

        /* вычерчивание линии */
          for (t=0; t<=distance+1; t++) {
             mempoint(startx,starty,color);
             xerr+=delta_x;
             yerr+=delta_y;
             if (xerr>distance) {
                xerr-=distance;
                startx+=incx;
             }
             if (yerr>distance) {
                yerr-=distance;
                starty+=incy;
             }
          }
       }




                 ИЗОБРАЖЕНИЕ И ЗАКРАШИВАНИЕ ПРЯМОУГОЛЬНИКОВ
     -----------------------------------------------------------------

          Если у  вас есть функции вычерчивания линий,  то не составит
     особого  труда  создать  функции  вычерчивания   прямоугольников.
     Пример,  приведенный здесь, вычерчивает прямоугольники в заданном
     цвете путем задания координат двух противоположных углов.


         /*  Вычерчивание прямоугольника  */
        void box(startx,starty,endx,endy,color_code)
        int startx,starty,endx,endy,color_code;
        {
           line(startx,starty,endx,starty,color_code);
           line(startx,starty,startx,endy,color_code);
           line(startx,endy,endx,endy,color_code);
           line(endx,starty,endx,endy,color_code);
        }


          Для того,   чтобы   закрасить    прямоугольник,    требуется
     выполнить запись  в  каждую  точку  растра внутри прямоугольника.
     Программа    fill_box(),    приведенная     ниже,     закрашивает
     прямоугольник,  определенный  координатами  двух  противоположных
     углов,  заданным  цветом.  В  ней  используется  функция  line(),
     задающая цвет внутри прямоугольника.


        /* Закрашивание прямоугольника в заданный цвет */
        void fill_box(startx,starty,endx,endy,color_code)
        int startx,starty,endx,endy,color_code;
        {
           register int i,begin,end;

           begin=startx<endx ? startx:endx;
           end=startx>endx ? startx:endx;

           for (i=begin;i<=end;++i)
              line(i,starty,i,endy,color_code);
         }



                          ВЫЧЕРЧИВАНИЕ ОКРУЖНОСТЕЙ
     -----------------------------------------------------------------

          Самым быстрым и  легким  способом  вычерчивания  окружностей
     является способ, основанный на использовании опять таки алгоритма
     Брезенхама,  похожего на одноименный алгоритм вычерчивания линий.
     Данный  метод  также  не  требует  вычислений  чисел  с плавающей
     точкой,  кроме  вычисления  коэффициента   сжатия,   поэтому   он
     обеспечивает  достаточное быстродействие.  По существу,  алгоритм
     основан на приращении координат X и  Y  на  величину  погрешности
     между  ними.  Значение  погрешности содержится в переменой delta.
     Функция  plot_circle()  выполняет  запись  точек  по  окружности.
     Переменная asp_ratio является глобальной,  т.к.  она используется
     как в функции  circle(),  так  и  в  функции  plot_circle().  Эта
     переменная   может   быть  полезна  с  точки  зрения  возможности
     установления ее  значения  вне  функции  circle()  и  дальнейшего
     использования  внутри  функции.  Путем  изменения  значения  этой
     переменной   вы  можете  рисовать  эллипсы.  Параметрами  функции
     circle() является  центр  окружности,  ее  радиус и цвет.  Тексты
     функций приведены ниже.


         double asp_ratio;

        /* Вычерчивание окружности с использованием алгоритма
           Брезенхама */
         void circle(x_center,y_center,radius,color_code)
         int x_center,y_center,radius,color_code;
         {
            register x,y,delta;
            asp_ratio=1.0; /* это число может меняется в различных
                              случаях */
             y=radius;
             delta=3-2*radius;
             for (x=0;x<y; ) {
                 plot_circle(x,y,x_center,y_center,color_code);
                 if (delta<0)
                    delta+=4*x+6;
                 else {
                    delta+=4*(x-y)+10;
                    y--;
                 }
                 x++;
              }
              x=y;
              if (y) plot_circle(x,y,x_center,y_center,color_code);
           }

         /* Функция печатает точки, определяющие окружность */
           void plot_circle(x,y,x_center,y_center,color_code)
           int x,y,x_center,y_center,color_code;
           {
              int startx,starty,endx,endy,x1,y1;
              starty=y*asp_ratio;
              endy=(y+1)*asp_ratio;
              startx=x*asp_ratio;
              endx=(x+1)*asp_ratio;

              for (x1=startx;x1<endx;++x1) {
                 mempoint(x1+x_center,y+y_center,color_code);
                 mempoint(x1+x_center,y_center-y,color_code);
                 mempoint(x_center-x1,y+y_center,color_code);
                 mempoint(x_center-x1,y_center-y,color_code);
              }

              for (y1=starty;y1<endy;++y1) {
                 mempoint(y1+x_center,x+y_center,color_code);
                 mempoint(y1+x_center,y_center-x,color_code);
                 mempoint(x_center-y1,x+y_center,color_code);
                 mempoint(x_center-y1,y_center-x,color_code);
              }
           }


          Закрашивать окружность можно путем повторного вызова функции
     circle()  с заданием  все более и  более  меньшего  радиуса. Этот
     способ  используется  в  функции   fill_circle(),  текст  которой
     приведен ниже.


         /* Закрашивание окружности путем повторного вызова
            circle() с уменьшением радиуса */

            void fill_circle(x,y,r,c)
            int x,y,r,c;
            {
               while (r) {
                  circle(x,y,r,c);
                  r--;
               }
             }



                       ПРОСТЕЙШАЯ ТЕСТОВАЯ ПРОГРАММЫ
     -----------------------------------------------------------------

          Приведенные   здесь  программа  иллюстрируют   применение  и
     возможности ранее описанных функций поддержки  графики.

        /* Программа, иллюстрирующая работу графических
           функций */
         #include "dos.h"
         #include "stdio.h"

         void mode(),line(),box(),fill_box();
         void mempoint(),palette(),xhairs();
         void circle(),plot_circle(),fill_circle();

         double asp_ratio;

         main()
         {
         mode(4);
         palette(0);
         line(0,0,100,100,1);
         box(50,50,80,90,2);
         fill_box(100,0,120,40,3);
         circle(100,160,30,2);
         fill_circle(150,250,20,1);
         getchar();
         mode(2);
        }
             /* установка палитры */

         void palette(pnum)
         int pnum;
         {
            union REGS r;

            r.h.bh=1; /* код 4 режима графики */
            r.h.bl=pnum; /* номер палитры */
            r.h.ah=11; /* устанавливаетса для вызова палитры */
            int86(0x10,&r,&r);
         }

          /* Установка видеорежима */
            void mode(mode_code)
            int mode_code;
            {
                union REGS r;
                r.h.al = mode_code;
                r.h.ah = 0;
                int86(0x10,&r,&r);
             }

         /*  Вычерчивание прямоугольника  */
        void box(startx,starty,endx,endy,color_code)
        int startx,starty,endx,endy,color_code;
        {
           line(startx,starty,endx,starty,color_code);
           line(startx,starty,startx,endy,color_code);
           line(startx,endy,endx,endy,color_code);
           line(endx,starty,endx,endy,color_code);
        }

      /* Вычерчивание линии заданного цвета с использованием
         алгоритма Брезенхама */
       void line(startx,starty,endx,endy,color)
       int startx,starty,endx,endy,color;
       {
         register int t,distance;
         int xerr=0,yerr=0,delta_x,delta_y;
         int incx,incy;

       /* Вычисление расстояния в обоих направлениях         */
         delta_x=endx-startx;
         delta_y=endy-starty;

       /* Определение направления шага,
          шаг вычисляется либо по вертикальной, либо по горизонтальной
          линии                   */
          if (delta_x>0) incx=1;
          else  if (delta_x==0) incx=0;
          else  incx= -1;

          if (delta_y>0) incy=1;
          else  if (delta_y==0) incy=0;
          else  incy= -1;

        /* Определение какое расстояние больше */
          delta_x=abs(delta_x);
          delta_y=abs(delta_y);
          if (delta_x>delta_y) distance=delta_x;
          else distance=delta_y;

        /* Вычерчивание линии */
          for (t=0; t<=distance+1; t++) {
             mempoint(startx,starty,color);
             xerr+=delta_x;
             yerr+=delta_y;
             if (xerr>distance) {
                xerr-=distance;
                startx+=incx;
             }
             if (yerr>distance) {
                yerr-=distance;
                starty+=incy;
             }
          }
       }

        /* Закрашивание прямоугольника  заданным цветом */

        void fill_box(startx,starty,endx,endy,color_code)
        int startx,starty,endx,endy,color_code;
        {
           register int i,begin,end;

           begin=startx<endx ? startx:endx;
           end=startx>endx ? startx:endx;

           for (i=begin;i<=end;++i)
              line(i,starty,i,endy,color_code);
         }


        /* Вычерчивание окружности с использованием алгоритма
           Брезенхама */
         void circle(x_center,y_center,radius,color_code)
         int x_center,y_center,radius,color_code;
         {
            register x,y,delta;
            asp_ratio=1.0; /* это число может меняется в различных
                              случаях */
             y=radius;
             delta=3-2*radius;
             for (x=0;x<y; ) {
                 plot_circle(x,y,x_center,y_center,color_code);
                 if (delta<0)
                    delta+=4*x+6;
                 else {
                    delta+=4*(x-y)+10;
                    y--;
                 }
                 x++;
              }
              x=y;
              if (y) plot_circle(x,y,x_center,y_center,color_code);
           }

         /* Функция изображает точки, определяющие окружность */
           void plot_circle(x,y,x_center,y_center,color_code)
           int x,y,x_center,y_center,color_code;
           {
              int startx,starty,endx,endy,x1,y1;
              starty=y*asp_ratio;
              endy=(y+1)*asp_ratio;
              startx=x*asp_ratio;
              endx=(x+1)*asp_ratio;

              for (x1=startx;x1<endx;++x1) {
                 mempoint(x1+x_center,y+y_center,color_code);
                 mempoint(x1+x_center,y_center-y,color_code);
                 mempoint(x_center-x1,y+y_center,color_code);
                 mempoint(x_center-x1,y_center-y,color_code);
              }

              for (y1=starty;y1<endy;++y1) {
                 mempoint(y1+x_center,x+y_center,color_code);
                 mempoint(y1+x_center,y_center-x,color_code);
                 mempoint(x_center-y1,x+y_center,color_code);
                 mempoint(x_center-y1,y_center-x,color_code);
              }
           }


       /* Закрашивание окружности путем повторного вызова
            circle() с уменьшением радиуса */
            void fill_circle(x,y,r,c)
            int x,y,r,c;
            {
               while (r) {
                  circle(x,y,r,c);
                  r--;
               }
         }

        /* Запись точки в CGA/EGA */
         void mempoint(x,y,color_code)
         int x,y,color_code;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в памяти
                                                      CGA */
            bit_mask.i=0xFF3F;                 /* 11111111 00111111 в
                                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return;
            xor=color_code & 128;      /* проверка, устанавливался ли
                                          режим "исключающего ИЛИ" */
            color_code=color_code & 127;     /* маска старших битов */

            /*  Установка маски битов и битов режима цвета
                в правую позицию */

             bit_position=y%4; /* вычисление нужной позиции в байте */
             color_code<<=2*(3-bit_position); /* сдвиг кода цвета
                                        в нужную позицию */
             bit_mask.i>>=2*bit_position; /* сдвиг битовой маски в
                                          нужную позицию */

             /* определение требуемого байта в памяти терминала */

              index=x*40+(y%4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* Запись цвета */
               if (!xor) {  /* режим изменения цвета */
                  t=*(ptr+index) & bit_mask.c[0];
                  *(ptr+index)=t|color_code;
               }
               else {
                  t=*(ptr+index) | (char)0;
                  *(ptr+index)=t & color_code;
               }
            }



               СОХРАНЕНИЕ И ЗАГРУЗКА ГРАФИЧЕСКИХ ИЗОБРАЖЕНИЙ
     -----------------------------------------------------------------

          Сохранение и   загрузка   графических  изображений  является
     довольно  простым  делом,  т.к.  образ  изображений  находится  в
     видеопамяти дисплея, а ее содержимое легко копировать на дисковый
     файл.   Главной   проблемой   является   необходимость   введения
     пользователем  имени  файла,  ввиду  того,  что  запрос о вводе и
     введенное имя файла сотрут часть информации на экране.  Для того,
     чтобы   избежать   этого,   разработаны   функции   save_pic()  и
     load_pic(),  тексты которых приводятся в данном  разделе.  Первая
     функция  сохраняет  14  верхних  строк  изображения,  чистит  эту
     область,  запрашивает имя файла и,  после  того,  как  оно  будет
     введено, восстанавливает изображение.


        /* сохранение  графического изображения */
        void save_pic()
        {
          char fname[80];
          FILE *fp;
          register int i,j;
          char far *ptr=(char far *) 0xB8000000; /* точка в
                                                 памяти   CGA  */
          char far *temp;
          unsigned char buf[14][80]; /* содержит образ экрана */

          temp=ptr;
        /* сохранение верхних строк текущего содержимого экрана */
          for (i=0;i<14;++i)
             for (j=0;j<80;++j) {
                buf[i][j]=*temp; /* четный байт */
                buf[i][j+1]=*(temp+8152); /* нечетный байт */
                *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                temp++;
             }
           goto_xy(0,0);
           printf("Имя файла:");
           gets(fname);
           if (!(fp=fopen(fname,"wb"))) {
               printf("Фвайл не может быть открыт\n");
               return;
           }

           temp=ptr;
       /* восстановление содержимого экрана */
          for (i=0;i<14;++i)
             for (j=0;j<80;++j) {
                *temp= buf[i][j]; /* четный байт */
                *(temp+8125)=buf[i][j+1]; /* нечетный байт */
                *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                temp++;
             }
        /* копирование изображения в файл  */
           for (i=0;i<8152;i++) {
              putc(*ptr,fp); /* четный байт */
              putc(*(ptr+8125),fp); /* нечетный байт */
              ptr++;
           }

           fclose(fp);
        }

       /* загрузка изображения */
         void load_pic()
         {
            char fname[80];
            FILE *fp;
            register int i,j;

            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                   памяти   CGA  */
            char far *temp;
            unsigned char buf[14][80]; /* содержит образ экрана */

            temp=ptr;
        /* сохранение верхних строк текущего содержимого экрана */
            for (i=0;i<14;++i)
               for (j=0;j<80;j+=2) {
                  buf[i][j]=*temp;
                  buf[i][j+1]=*(temp+8152);
                  *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                  temp++;
               }
            goto_xy(0,0);
            printf("Имя файла:");
            gets(fname);
            if (!(fp=fopen(fname,"rb"))) {
               goto_xy(0,0);
               printf("Файл не может быть открыт\n");
               temp=ptr;
       /* восстановление содержимого экрана */
               for (i=0;i<14;++i)
                  for (j=0;j<80;j+=2) {
                     *temp= buf[i][j];
                     *(temp+8125)=buf[i][j+1];
                     temp++;
                  }
               return;
             }
      /* загрузка изображения из файла */
           for (i=0;i<8152;i++) {
              *ptr=getc(fp); /* четный байт */
              *(ptr+8125)=getc(fp); /* нечетный байт */
              ptr++;
           }

           fclose(fp);
        }

          Подпрограммы  начинают  обработку   видеопамяти,  начиная  с
     адреса,  содержащегося  в указателе temp  считывая  или записывая
     каждый четный и нечетный байты в порядке  возрастания их адресов.
     Такой   подход   позволяет   добиться   простоты   и  наглядности
     функционирования   рассмотренных   выше  подпрограмм.   В  случае
     обработки  видеопамяти  в  порядке  возрастания  адресов, вначале
     будет отображаться четная точка растра, а затем - нечетная.



                         ДУБЛИРОВАНИЕ ЧАСТИ ЭКРАНА
     -----------------------------------------------------------------

          Иногда бывает  полезным  скопировать  часть  экрана в другую
     область.  Это легко выполнить  используя  функцию  copy(),  текст
     которой приводится ниже.

          /* копирование части экрана в другую область */
          void copy(startx,starty,endx,endy,x,y)
          int startx,starty;      /* верхняя левая координата */
          int endx,endy;          /* нижняя правая координата области
                                     копирования */
          int x,y;      /* верхняя левая координата области,
                           куда будет проводится копирование */
          {
             int i,j;
             unsigned char c;

             for (;startx<endx;startx++,x++)
                for (i=starty,j=y;i<endy;i++,j++) {
                   c=read_point(startx,i); /* чтение точки */
                   mempoint(x,j,c); /* запись ее в новую область */
                 }
            }


          Как вы могли убедиться,  при обращении к функциим в качестве
     ее   аргументов   указываются   верхняя  левая  и  нижняя  правая
     координаты углов области,  которая будет копироваться,  и верхняя
     левая координаты, куда делается копия.

          Вы также  можете  убедится,  что  с  небольшими  изменениями
     функцию  copy()  можно  преобразовать  в  функцию move(). Функция
     move() пересылает  указанную  область  в другую и чистит исходное
     место. Текст функции приводится ниже.



       /* Пересылка части экрана в другую область */
          void move(startx,starty,endx,endy,x,y)
          int startx,starty; /* верхняя левая координата */
          int endx,endy; /* нижняя правая координата области
                            пересылки */
          int x,y; /* верхняя левая координата области,
                     куда будет проводится пересылка */
          {
             int i,j;
             unsigned char c;

             for (;startx<endx;startx++,x++)
                for (i=starty;j=y;i<endy;i++,j++) {
                   c=read_point(startx,i); /* чтение точки */
                   mempoint(startx,i,0); /* стирание старого
                                            изображения */
                   mempoint(x,j,c); /* запись точки в новую область */
                 }
            }



                     ВРАЩЕНИЕ ТОЧКИ В ПЛОСКОСТИ ЭКРАНА
     -----------------------------------------------------------------

          Вращение точки  в  плоскости экрана (двумерном пространстве)
     представляет собой довольно простую задачу в  декартовой  системе
     координат.  Вы можете вспомнить из курса аналитической геометрии,
     что вращение точки  вокруг  центра  на  угол  theta,  описывается
     формулой:

              new_x = old_x * cos(theta) - old_y * sin(theta)
              new_y = old_x * sin(theta) - old_y * cos(theta)

          Единственной сложностью при  употреблении  этих  формул  для
     графических дисплеев будет являтся тот факт, что экран дисплея не
     является декартовым пространством.  Декартовы  оси  определяют  4
     квадранта,   как  это  показано  на  рисунке  4-2.  Однако  экран
     терминала представляет собой один из квадрантов,  оси  X  и  Y  в
     котором   перевернуты.   Для  решения  этой  проблемы  необходимо
     определить новый центр и привести в соответствие координаты X и Y
     экрана  и координаты осей декартова пространства.  Любая точка на
     экране может быть использована в качестве центра, но обычно центр
     определяется  как  можно  ближе  к  центру  объекта,  который  мы
     собираемся вращать.  Функция  rotate_point(),  приведенная  ниже,
     вычисляет  величину  новых  значений  X  и  Y  для заданного угла
     вращения.


        /* Вращение точки вокруг центра с координатами
           x_org и y_org на угол theta */
          void rotate_point(theta,x,y,x_org,y_org)
          double theta,*x,*y;
          int x_org,y_org;
          {
             double tx,ty;

        /* нормализация X и Y к начальному адресу */
             tx=*x-x_org;
             ty=*y-y_org;

        /* вращение */
              *x=tx*cos(theta)-ty*sin(theta);
              *y=tx*sin(theta)-ty*cos(theta);

         /* возвращение значений координат */
              *x+=x_org;
              *y+=y_org;
           }


          Заметим, что  rotate_point()  изменяет параметры X и Y путем
     присвоения им требуемого значение для  получения  угла  вращения,
     заданного переменной theta. Угол вращения задается в радианах.


     ┌──────────────────────────────────────────────────────────────┐
     │                                                              │
     │  Декартова система координат                Y                │
     │                                    II       ^       I        │
     │                                     +,-     │     +,+        │
     │                                             │                │
     │                                             │0.0             │
     │                                    ─────────┼───────── X     │
     │                                             │                │
     │                                     -,-     │     -,+        │
     │                                             │                │
     │                                   III       ∙       IV       │
     │                                                              │
     │                                                              │
     │                                                    0.0       │
     │  Графический экран                          ┌────────── Y    │
     │                                             │                │
     │                                             │     +,+        │
     │                                             │                │
     │                                             ∙                │
     │                                             X                │
     └──────────────────────────────────────────────────────────────┘

     Рис. 4-2. Декартовы координаты на графическом экране.



     Вращение обьекта
     ----------------

          Хотя функция rotate_point(),  вычисляющая требуемые значения
     координат  X  и Y при вращении точки,  уже была нами рассмотрена.
     Однако,  она не может быть использована для вращения  (поворотов)
     объектов. Для этого необходима другая функция. Под объектом здесь
     и  далее  будем  понимать  набор   сегментов   прямых   отрезков.
     Координаты  крайних  точек каждого отрезка содержатся в двумерном
     массиве чисел с плавающей точкой.  Каждая строка массива содержит
     начальные  и  конечные координаты данного отрезка.  Это означает,
     что первая  размерность  массива  представляет  собой  количество
     отрезков,  входящих в состав объекта,  а вторая размерность будет
     равна  4  (число  координат  крайних  точек  отрезка).  Например,
     массив, приведенный ниже

          double object [10][4];

     определяет объект, состоящий из 10 отрезков.

          Как правило,   массив  организуется  так,  как  показано  на
     рисунке 4-3.

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │  Первый        Второй ────────>                               │
     │  индекс        индекс                                         │
     │                                                               │
     │    │             0           1            2           3       │
     │    │                                                          │
     │    │                                                          │
     │    V                                                          │
     │                                                               │
     │    0          start_X1     start_Y1     end_X1     end_Y1     │
     │                                                               │
     │    1          start_X2     start_Y2     end_X2     end_Y2     │
     │                                                               │
     │    2          start_X3     start_Y3     end_X3      end_Y3    │
     │                                                               │
     │    3          start_X4     start_Y4     end_X4      end_Y4    │
     │    .             .                                            │
     │    .             .                                            │
     │    .             .                                            │
     │    n          start_Xn     start_Yn     end_Xn      end_Yn    │
     └───────────────────────────────────────────────────────────────┘

     Рис. 4-3. Условная организация массива.


          Определить объект  -  это  значит   разместить   в   массиве
     координаты  начальных  и  конечных  точек отрезков,  составляющих
     объект.  Например,  если объект представляет собой  прямоугольник
     вида:

                         0.0┌─────────────────┐0.10
                            │                 │
                            │                 │
                            │                 │
                            │                 │
                        10.0└─────────────────┘10.10

     то в  массив,  определяющий   данный   прямоугольник,   заносятся
     следующие числа:

          object[0][0] = 0; object[0][1] = 0;
          object[0][0] = 0; object[0][3] = 10;

          object[1][0] = 0; object[1][1] = 10;
          object[1][0] = 10; object[1][3] = 10;

          object[2][0] = 10; object[2][1] = 10;
          object[2][0] = 10; object[2][3] = 0;

          object[3][0] = 10; object[3][1] = 0;
          object[3][0] = 0; object[3][3] = 0;

          После того,  как  объект  определен,  вы можете вращать его,
     используя функцию rotate_object(),  приведенную ниже,  по часовой
     стрелке  (клавиша  <R>)  или  в  противоположную сторону (клавиша
     <L>).


          /* Вращение заданных объектов */

          void rotate_object(ob, theta, x, y, sides)
          double ob[][4]; /* описание объекта */
          double theta;   /* угол поворота в радианах */
          int x, y;
          int sides;
            {
            register int i, j;
            double tempx, tempy;
            char ch;

            for(;;)
              {
              ch = getch(); /* ввод признака направления вращения */
              switch(tolower(ch))
                {
                case 'l': /* вращение против часовой стрелки */
                  theta = theta < 0 ? -theta : theta;
                  break;
                case 'r': /* вращение по часовой стрелке  */
                  theta = theta > 0 ? -theta : theta;
                  break;
                default: return;
                }
              for(j=0; j<=sides; j++) /* стирание старых линий  */
                {
                line((int) ob[j][0], (int) ob[j][1],
                     (int) ob[j][2], (int) ob[j][3], 0);
                rotate_point(theta, &ob[j][0],
                             &ob[j][1], x, y);
                rotate_point(theta, &ob[j][2], &ob[j][3], x, y);
                line((int) ob[j][0], (int) ob[j][1],
                     (int) ob[j][2], (int) ob[j][3], 2);
                }
              }
            }

          Как показано  в описании параметров функции rotate_object(),
     вращение осуществляется вокруг центра, заданного координатами X и
     Y, на угол, величина которого задана параметром theta в радианах.
     Минимальное значение параметра theta равно 0.01  радиан. Заметим,
     что  объект  сначала  стирается  из старой области размещения,  а
     затем перерисовывается вновь.  Если это  условие  не  может  быть
     выполнено,  то  экран  окрашивается  в голубой цвет.  Необходимым
     условием   выполнения    программы    rotate_object()    является
     обязательное задание параметра sides.

          Приведенная ниже функция display_object() не имеет отношения
     к вращению объектов,  но она может  быть  полезна  при  работе  с
     объектами.  Она рисует на экране объекты,  определенные в массиве
     ob.

          /* отображение объекта на экране */
          void display_object(ob, sides)
          double ob[][4];
          int sides;
          {
            register int i;

            for(i=0; i<sides; i++)
              line((int)ob[i][0], (int)ob[i][1],
                   (int)ob[i][2], (int)ob[i][3], 2);
            }

          В качестве  иллюстрации   удобства   использования   функций
     вращения  объектов ниже приводятся программы вращения изображения
     дома.  На рисунке 4-4 показано изображение  на  экране  терминала
     дома  при  различных  углах  поворота вокруг собственного центра.
     Прямоугольник,  обрамляющий изображение вращаемого дома,  поможет
     вам правильно оценить масштаб и перспективу.

     _________________________________________________________________

        Прим. пер.  Рисунок 4-4 не может быть воспроизведен имеющимися
                    средствами.
     _________________________________________________________________

     Рис. 4-4. Вращение объекта.


          /* Пример  вращения  изображения  объекта  с  использованием
             адаптера CGA/EGA в 4 графическом режиме
          */

          #include "dos.h"
          #include "stdio.h"
          #include "math.h"

          void mode(), line(), mempoint(), palette();
          void rotate_point(), rotate_object(), display_object();

          /* массив house определяет изображение дома */
          double house[][4] =
            {
       /*  startx,   starty,        endx,         endy  */
           120,         120,         120,          200,   /* дом */
           120,         200,          80,          200,
           80,          120,          80,          200,
           80,          120,         120,          120,
           60,          160,          80,          120,   /* крышa*/
           60,          160,          80,          200,
           120,         155,         100,          155,   /* двери*/
           100,         155,         100,          165,
           100,         165,         120,          165,
           90,          130,         100,          130,   /* окна */
           90,          130,          90,          140,
           100,         130,         100,          140,
           90,          140,         100,          140,
           90,          180,         100,          180,
           90,          180,          90,          190,
           100,         180,         100,          190
           };
          main()
            {
            union k
              {
              char c[2];
              int i;
              }  key;

            mode(4);    /* режим   = 4 */
            palette(0); /* палитра = 0 */

            /* рисунок рамки,обрамляющей дом */
            line (30, 70, 30, 260, 2);
            line (160, 70, 160, 260, 2);
            line (30, 70, 160, 70, 2);
            line (30, 260, 160, 260, 2);

            display_object(house, 17);
            getchar();
            rotate_object(house, 0.025, 90, 160, 17);
            mode(3);
            }

          /* Выбор палитры */
          void palette(pnum)
          int pnum;
            {
            union REGS r;

            r.h.bh = 1; /* код 4 графического режима */
            r.h.bl = pnum;
            r.h.ah = 11;
            int86(0x10, &r, &r);
            }

          /* Выбор режима */
          void mode(mode_code)
          int mode_code;
            {
            union REGS r;

            r.h.al = mode_code;
            r.h.ah = 0;
            int86(0x10, &r, &r);
            }

          /* Рисунок отрезка прямой заданного цвета */
          void line(start_x, start_y, endx, endy, color)
          int start_x, start_y, endx, endy, color;
            {
            register int t, distance;
            int x=0, y=0, delta_x, delta_y;
            int incx, incy;

            /* вычисление приращений по x и по y */
            delta_x = endx-start_x;
            delta_y = endy-start_y;

            /* вычисление признаков направлений отрезка */
            if(delta_x>0)
              incx=1;
            else
              if(delta_x==0)
                incx=0;
              else
                incx= -1;
            if(delta_y>0)
              incy=1;
            else
              if(delta_y==0)
                incy=0;
              else
                incy= -1;
            delta_x=abs(delta_x);
            delta_y=abs(delta_y);
            if(delta_x>delta_y)
              distance=delta_x;
            else
              distance=delta_y;

            /* рисунок отрезка */
            for(t=0; t<=distance; t++)
              {
              mempoint(start_x, start_y, color);
              x+=delta_x;
              y+=delta_y;
              if(x>distance)
                {
                x-=distance;
                start_x+=incx;
                }
              if(y>distance)
                {
                y-=distance;
                start_y+=incy;
                }
              }
            }

        /* запись точки в CGA/EGA */

         void mempoint(x,y,color_code)
         int x,y,color_code;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "НЕ-ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=0xFF3F; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return;
            xor=color_code & 128; /* проверка, устанавливался ли
                                     режим "НЕ-ИЛИ" */
            color_code=color_code & 127; /* маска старших битов */

            /*  установка битовой маски и битов режима цвета
                в правую позицию */

             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             color_code<<=2*(3-bit_position); /* сдвиг кода цвета
                                        в нужную позицию */
             bit_mask.i>>=2*bit_position; /* сдвиг битовой маски в
                                          нужную позицию */

             /* определение требуемого байта в памяти терминала */

              index=x*40+(y%4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */

               if (!xor) {  /* режим изменения цвета */
                  t=*(ptr+index) & bit_mask.c[0];
                  *(ptr+index)=t|color_code;
               }
               else {
                  t=*(ptr+index) | (char)0;
                  *(ptr+index)=t & color_code;
               }
            }


        /* вращение точки вокруг центра с координатами
           в x_org и y_org, на угол theta */

          void rotate_point(theta,x,y,x_org,y_org)
          double theta,*x,*y;
          int x_org,y_org;
          {
             double tx,ty;

        /* нормализация X и Y к начальному адресу */
             tx=*x-x_org;
             ty=*y-y_org;

        /* вращение */
              *x=tx*cos(theta)-ty*sin(theta);
              *y=tx*sin(theta)-ty*cos(theta);

         /* возвращение значений координат */
              *x+=x_org;
              *y+=y_org;
           }


          /* Вращение заданных объектов */

          void rotate_object(ob, theta, x, y, sides)
          double ob[][4]; /* описание объекта */
          double theta;   /* угол поворота в радианах */
          int x, y;
          int sides;
            {
            register int i, j;
            double tempx, tempy;
            char ch;

            for(;;)
              {
              ch = getch(); /* ввод признака направления вращения */
              switch(tolower(ch))
                {
                case 'l': /* вращение против часовой стрелки */
                  theta = theta < 0 ? -theta : theta;
                  break;
                case 'r': /* вращение по часовой стрелке  */
                  theta = theta > 0 ? -theta : theta;
                  break;
                default: return;
                }
              for(j=0; j<=sides; j++) /* стирание старых линий  */
                {
                line((int) ob[j][0], (int) ob[j][1],
                     (int) ob[j][2], (int) ob[j][3], 0);
                rotate_point(theta, &ob[j][0],
                             &ob[j][1], x, y);
                rotate_point(theta, &ob[j][2], &ob[j][3], x, y);
                line((int) ob[j][0], (int) ob[j][1],
                     (int) ob[j][2], (int) ob[j][3], 2);
                }
              }
            }


          /* отображение объекта на экране */

          void display_object(ob, sides)
          double ob[][4];
          int sides;
            {
            register int i;

            for(i=0; i<sides; i++)
              line((int) ob[i][0], (int) ob[i][1],
                   (int) ob[i][2], (int) ob[i][3], 2);
            }



               Сборка подпрограмм
     -----------------------------------------------------------------

          В этом,  последнем, параграфе, описывается простая программа
     рисования, использующая подпрограммы графики. Программы рисования
     часто  используют  "мышь",   позволяющую   пользователю   удобным
     способом  отображать линии на экране терминала.  Однако,  "мышью"
     комплектуются пока не все  компьютеры  поэтому,  описанная  здесь
     "программа-художник"   ориентирована   на  операции  с  клавишами
     перемещения курсора.

          В "рисующих"  программах   вам   необходимо   контролировать
     текущее  положение  координат X и Y (в графическом режиме текущие
     координаты индицируются курсором не совсем  обычной  формы).  Для
     простоты   дальнейшего   изложения   материала   будем   называть
     "графический" курсор "перекрестьем",  принимая во внимание и  тот
     факт, что в графическом режиме его форма действительно напоминает
     крест.  Функция xhairs() размещает графический курсор в  позиции,
     специфицированной значениями ее аргументов X и Y.

          Напоминаем, что  двоичный  код  цвета  складывается по схеме
     "ИЛИ" со 128 с целью установки 7 бита в 1.  Это позволяет функции
     mempoint()  складывать  по схеме "исключающего ИЛИ" двоичные коды
     старого и нового цвета на  экране  вместо  его  изменения.  Такая
     возможность  позволяет  достичь двух важных моментов.  Во-первых,
     графический курсор всегда видим, т.к. всегда имеет цвет, отличный
     от   окружающего.   Во-вторых,   значительно  упрощается  процесс
     возврата точки растра, занимаемой курсором, в исходное положение.
     Эта операция выполняется путем повторного обращения к этим точкам
     (напомним, что последовательное выполнение двух операций по схеме
     "исключающего  ИЛИ"  всегда приводит к первоначальному значению).
     Ниже приведен текст функции отображения графического курсора.

        /* отображение графического курсора */
         void xhairs(x,y)
         int x,y;
         {
            line(x-4,y,x+3,y,1|128);
            line(x,y+4,x,y-3,1|128);

          }


          Программа  рисования,  описанная в данном  разделе, позволит
     вам:

          - рисовать линии;
          - рисовать прямоугольники;
          - закрашивать прямоугольники;
          - рисовать окружности;
          - закрашивать окружности;
          - выбирать цвет;
          - выбирать палитру;
          - устанавливать скорость изменения параметров;
          - сохранять графические изображения;
          - загружать графические изображения;
          - вращать объекты вокруг любой точки;
          - копировать и пересылать графические изображения.


          Приведем ниже текст главной программы :

          main()
            {
            union k{
              char c[2];
              int i;
               } key ;

            int x=10, y=10; /* текущая позиция экрана */
            int cc=2;   /* текущий цвет */
            int on_flag=1; /* признак использования карандаша */
            int pal_num=1; /* номер палитры */
            /* конечная точка определения линий,
              прямоугольников, окружностей */
            int startx=0, starty=0, endx=0, endy=0;
            int first_point=1;
            int inc=1; /* шаг пересылки */
            int sides=0; /* количество сторон выбранного объекта */
            int i;

            mode(4); /* переключатель режима CGA/EGA */
            palette(0); /* палитра 0 */

            xhairs(x, y); /* указатель курсора */
             do
              {
              key.i = bioskey(0);
              xhairs(x, y); /* графический курсор */
              if(!key.c[0]) switch(key.c[1])
                {
                case 75: /* влево */
                  if(on_flag) line(x, y, x, y-inc, cc);
                  y -= inc;
                  break;
                case 77: /* вправо */
                  if(on_flag) line(x, y, x, y+inc, cc);
                  y += inc;
                  break;
                case 72: /* вверх */
                    if(on_flag) line(x, y, x-inc, y, cc);
                  x -= inc;
                  break;
                case 80: /* вниз */
                    if(on_flag) line(x, y, x+inc, y, cc);
                  x += inc;
                  break;
                case 71: /* вверх и влево */
                  if(on_flag) line(x, y, x-inc, y-inc, cc);
                  x -= inc;
                  y -= inc;
                  break;
                case 73: /* вверх и вправо */
                  if(on_flag) line(x, y, x-inc, y+inc, cc);
                  x -= inc;
                  y += inc;
                  break;
                case 79: /* вниз и влево */
                  if(on_flag) line(x, y, x+inc, y-inc, cc);
                  x += inc;
                  y -= inc;
                  break;
                case 81: /* вниз и вправо */
                  if(on_flag) line(x, y, x+inc, y+inc, cc);
                  x += inc;
                  y += inc;
                  break;
                case 59: /* F1 - медленно */             inc=1;
                  break;
                case 60: /* F2 - быстро   */
                  inc=5;
                  break;
                }
              else switch(tolower(key.c[0]))
                {
                case 'o': /* переключение шаблона */
                  on_flag = !on_flag;
                  break;
                case '1': cc=1; /* цвет 1 */
                  break;
                case '2': cc=2; /* цвет 2 */
                  break;
                 case '3': cc=3; /* цвет 3 */
                  break;
                case '0': cc=0; /* цвет 0 */
                  break;
                case 'b': box(startx, starty, endx, endy, cc);
                    break;
                case 'f':
                  fill_box(startx, starty, endx, endy, cc); break;
                case 'l':
                  line(startx, starty, endx, endy, cc);     break;
                case 'c':
                  circle(startx, starty, endy-starty, cc);  break;
                case 'h':
                  fill_circle(startx, starty, endy-starty, cc); break;
                case 's':
                  save_pic();                               break;
                case 'r':
                  load_pic();                               break;
                case 'm': /* пересылка фрагмента */
                  move(startx, starty, endx, endy, x, y);   break;
                case 'x': /* копирование фрагмента */
                  copy(startx, starty, endx, endy, x, y);   break;
                case 'd': /* определить поворот(cдвиг) объекта */

      /* Внимание!! Во время трансляции программы идентификатор object
          был помечен как "неопределенный". Его описание действительно
          отсутствует в этой программе. (Ред. пер. И.Бычковский)
      */

                  sides = define_objekt(object, x, y);      break;
                case 'a': /* поворот(сдвиг) объекта */
                  rotate_objekt(object, 0.05, x, y, sides); break;
                case '\r': /* набор конечных точек для линий, кругов
                            или прямоугольников */
                  if(first_point)
                    { startx = x, starty = y; }
                  else
                    { endx = x, endy = y; }
                  first_point = !first_point;break;
                case 'p':
                  pal_num = pal_num==1 ? 2:1;
                  palette(pal_num);
                }
              xhairs(x, y);
              }
            while (key.c[0]!='q');
            getchar();
            mode(2);
            }


          Опишем кратко алгоритм работы программы  рисования.  Вначале
     экран  терминала  устанавливается  в  4 графический режим.  Затем
     устанавливается палитра 0,  и графический курсор  перемещается  в
     верхний  левый угол.  Шаблон цвета по умолчанию устанавливается в
     соответствии с кодом 2 (красный в  палитре  0).  При  перемещении
     графического   курсора   на   экране   остается   след,   который
     окрашивается  в  соответствии  с  текущим  цветом  шаблона.  Если
     нажимать   клавиши   перемещения   курсора,   графический  курсор
     перемещается на одну точку растра в заданном  направлении.  Такая
     скорость перемещения может не удовлетворять пользователя, поэтому
     в программе предусмотрена возможность смещения на 5  точек растра
     путем нажатия клавиши F2.  Отменить режим ускоренного перемещения
     можно путем нажатия клавиши F1.  Изменение  цвета  осуществляется
     при  нажатии  цифровых  клавиш  от  0  до 3.  В палитре 0 цифра 0
     зарезервирована,  1 определяет зеленый цвет,  2 -  красный,  3  -
     желтый.  Шаблон цвета может быть изменен путем нажатия клавиши 0.
     Клавиши <Курсор в левый верхний угол> (<HOME>),  <Страница вверх>
     (<PGUP>),  <Страница  вниз>  (<PGDN>)  и <Кон> (<END>) перемещают
     графический курсор в указанном  направлении  и  под  углом  в  45
     градусов.

          Для анализа  кодов операций чтения в программах используется
     функция bioskey().  Порядок подключения этой функции к  программе
     при компиляции описан в главе 1. В программу включены обращения к
     функциям, позволяющим вам рисовать и закрашивать прямоугольники и
     окружности,  рисовать линии,  копировать и перемещать изображение
     на экране,  сохранять на диске  и  загружать  с  него  содержимое
     экрана, отображать и вращать объекты.

          При изображении  линий,  прямоугольников  и  окружностей вам
     необходимо определить координаты двух точек.  Для прямоугольников
     -  это координаты двух противоположных углов.  Для линий задается
     начальная и конечная точки,  а для окружности - координаты центра
     и точки, через которую она будет проходить.

          Процесс выбора  этих точек выполняется путем нажатия клавиши
     <ВВОД> в момент,  когда графический курсор находится в  требуемой
     области.   Например,   для   изображения   линии  вы  перемещаете
     графический курсор в точку, где она должна начинаться и нажимаете
     клавишу  <ВВОД>  .  Затем  вы устанавливаете курсор в точку,  где
     линия заканчивается,  и  нажимаете  <ВВОД>  снова.  При   нажатии
     клавиши  <ВВОД>  выполняется загрузка переменных startx,  starty,
     endx и endy,  которые потом используются  в  качестве  параметров
     вызываемых  функций.  После  того,  как  координаты  точек  будут
     определены,  при нажатии клавиши <В> рисуется квадрат,  а  <F>  -
     квадрат закрашивается,   при  нажатии  <L>  рисуется  линия,  при
     нажатии   <С>   рисуется   окружность,   а   <Н>   -   окружность
     закрашивается.

          Для копирования  или  перемещения  части  экрана  вы  должны
     определить верхний левый и нижний правый углы области, которую вы
     хотите   переместить   (нажатием   клавиши  <ВВОД>  ).  Затем  вы
     перемещаете курсор в верхний левый угол области,  куда вы  хотите
     переместить  изображение.  Для  пересылки  изображения  требуется
     нажать клавишу <М>,  а для  копирования  -  <Х>.  Запомните,  что
     старое  изображение  в области,  куда осуществляется копирование,
     будет уничтожено.

          Для вращения объекта вам необходимо определить  сам  объект,
     путем нажатия клавиши <D>.  Затем,  используя клавишу <ВВОД>,  вы
     должны определить  начальные  и  конечные  координаты  точек  для
     отрезков по периметру выбранного объекта.  Процесс выбора объекта
     вращения  и   определения   его   границ   реализуется   функцией
     define_object().   Вращение   объекта  начинается  после  нажатия
     клавиши <А>.  Для определения направления  вращения  используются
     клавиши   <L>  (по  часовой  стрелке)  или  <R>  (против  часовой
     стрелки).  Остановить  процесс  вращения  можно  нажатием   любой
     клавиши, кроме <L> или <А>.

          Для остановки работы программы используется клавиша <Q>. При
     желании вы можете включить  в  программу  функции  для  работы  с
     "мышью". Пример выходных данных программы показан на рисунке 4-5.

     _________________________________________________________________

     Рисунок 4-5 на стр. 163 не может быть воспроизведен имеющимися
     средствами. (Ред. пер. И.Бычковский)
     _________________________________________________________________

     Рис. 4-5. Простейшие результаты работы программы рисования.


          А теперь приведем всю программу рисования целиком.


     /* Программа    для    CGA/EGA,   позволяющая   рисовать   линии,
     прямоугольники и  окружности.  Вы  можете  нарисовать  какой-либо
     объект  и  вращать его по часовой или против часовой стрелки.  Вы
     так же  можете  копировать  графическое  изображение  на  диск  и
     загружать его с диска. */

          #define NUM_SIDES 20 /* число сторон объекта;
                                  при необходимости увеличивается */
          #include "dos.h"
          #include "stdio.h"
          #include "math.h"

          void mode(), line(), box(), fill_box();
          void mempoint(), palette(), xhairs();
          void circle(), plot_circle(), fill_circle();
          void rotate_point(), rotate_object(), goto_xy();
          void display_object(), copy(), move();
          void save_pic(), load_pic();
          unsigned char read_point();

          /*  Этот массив содержит динамически меняющиеся
              координаты объекта.
          */
          double object[NUM_SIDES][4];
          double asp_ratio; /* содержит коэффициент сжатия для
                               окружностей */

          main()
            {
            union k{
              char c[2];
              int i;
               } key ;

            int x=10, y=10; /* текущая позиция экрана */
            int cc=2;   /* текущий цвет */
            int on_flag=1; /* признак использования карандаша */
            int pal_num=1; /* номер палитры */

            int startx=0, starty=0, endx=0, endy=0;
            int first_point=1;
            int inc=1; /* шаг пересылки */
            int sides=0; /* количество сторoн выбранного объекта */
            int i;

            mode(4); /* переключатель режима CGA/EGA */
            palette(0); /* палитра 0 */

            xhairs(x, y); /* указатель курсора */
             do
              {
              key.i = bioskey(0);
              xhairs(x, y);
              if(!key.c[0]) switch(key.c[1])
                {
                case 75: /* влево */
                  if(on_flag) line(x, y, x, y-inc, cc);
                  y -= inc;
                  break;
                case 77: /* вправо */
                  if(on_flag) line(x, y, x, y+inc, cc);
                  y += inc;
                  break;
                case 72: /* вверх */
                    if(on_flag) line(x, y, x-inc, y, cc);
                  x -= inc;
                  break;
                case 80: /* вниз */
                    if(on_flag) line(x, y, x+inc, y, cc);
                  x += inc;
                  break;
                case 71: /* вверх и влево */
                  if(on_flag) line(x, y, x-inc, y-inc, cc);
                  x -= inc;
                  y -= inc;
                  break;
                case 73: /* вверх и вправо */
                  if(on_flag) line(x, y, x-inc, y+inc, cc);
                  x -= inc;
                  y += inc;
                  break;
                case 79: /* вниз и влево */
                  if(on_flag) line(x, y, x+inc, y-inc, cc);
                  x += inc;
                  y -= inc;
                  break;
                case 81: /* вниз и вправо */
                  if(on_flag) line(x, y, x+inc, y+inc, cc);
                  x += inc;
                  y += inc;
                  break;
                case 59: /* F1 - медленно */
                  inc=1;
                  break;
                case 60: /* F2 - быстро   */
                  inc=5;
                  break;
                }
              else switch(tolower(key.c[0]))
                {
                case 'o': /* переключение шаблона */
                  on_flag = !on_flag;
                  break;
                case '1': cc=1; /* цвет 1 */
                  break;
                case '2': cc=2; /* цвет 2 */
                  break;
                 case '3': cc=3; /* цвет 3 */
                  break;
                case '0': cc=0; /* цвет 0 */
                  break;
                case 'b':
                  box(startx, starty, endx, endy, cc);      break;
                case 'f':
                  fill_box(startx, starty, endx, endy, cc); break;
                case 'l':
                  line(startx, starty, endx, endy, cc);     break;
                case 'c':
                  circle(startx, starty, endy-starty, cc);  break;
                case 'h':
                  fill_circle(startx, starty, endy-starty, cc); break;
                case 's':
                  save_pic();                               break;
                case 'r':
                  load_pic();                               break;
                case 'm': /* пересылка фрагмента */
                  move(startx, starty, endx, endy, x, y);   break;
                case 'x': /* копирование фрагмента */
                  copy(startx, starty, endx, endy, x, y);   break;
                case 'd': /* определить объект вращения */
                  sides = define_objekt(object, x, y);      break;
                case 'a': /* вращение объекта */
                  rotate_objekt(object, 0.05, x, y, sides); break;
                case '\r': /* набор конечных точек для линий, кругов
                              или прямоугольников */
                  if(first_point)
                    { startx = x, starty = y; }
                  else
                    { endx = x, endy = y; }
                  first_point = !first_point;               break;
                case 'p':
                  pal_num = pal_num==1 ? 2:1;
                  palette(pal_num);
                }
              xhairs(x, y);
              }
            while (key.c[0]!='q');
            getchar();
            mode(2);
            }

          /* установка палитры */
          void palette(pnum)
          int pnum;
            {
            union REGS r;
            r.h.bh = 1; /* код 4 режима графики */
            r.h.bl = pnum;
            r.h.ah = 11; /* установка палитры */
            int86(0x10, &r, &r);
            }

          /* установка видео-режима */
          void mode (mode_code)
          int mode_code;
            {
            union REGS r;

            r.h.al = mode_code;
            r.h.ah = 0;
            int86(0x10,&r, &r);
            }

          /* изображение прямоугольника */
          void box(sx, sy, ex, ey, c)
          int sx, sy, ex, ey, c;
            {
            line(sx, sy, ex, sy, c);
            line(sx, sy, sx, ey, c);
            line(sx, ey, ex, ey, c);
            line(ex, sy, ex, ey, c);
            }

      /* изображение линии заданного цвета с использованием
         алгоритма Брезенхама */
       void line(startx,starty,endx,endy,color)
       int startx,starty,endx,endy,color;
       {
         register int t,distance;
         int xerr=0,yerr=0,delta_x,delta_y;
         int incx,incy;

       /* вычисление расстояния в обоих направлениях         */
         delta_x=endx-startx;
         delta_y=endy-starty;

       /* определение направления шага,
          шаг вычисляется либо по вертикальной, либо горизонтальной
          линии                   */
          if (delta_x>0) incx=1;
          else  if (delta_x==0) incx=0;
          else  incx= -1;

          if (delta_y>0) incy=1;
          else  if (delta_y==0) incy=0;
          else  incy= -1;

        /* определение какое расстояние больше */
          delta_x=abs(delta_x);
          delta_y=abs(delta_y);
          if (delta_x>delta_y) distance=delta_x;
          else distance=delta_y;

        /* изображение линии */
          for (t=0; t<=distance+1; t++) {
             mempoint(startx,starty,color);
             xerr+=delta_x;
             yerr+=delta_y;
             if (xerr>distance) {
                xerr-=distance;
                startx+=incx;
             }
             if (yerr>distance) {
                yerr-=distance;
                starty+=incy;
             }
          }
       }


        /* закрашивание прямоугольника в заданный цвет */

        void fill_box(startx,starty,endx,endy,color_code)
        int startx,starty,endx,endy,color_code;
        {
           register int i,begin,end;

           begin=startx<endx ? startx:endx;
           end=startx>endx ? startx:endx;

           for (i=begin;i<=end;++i)
              line(i,starty,i,endy,color_code);
         }


        /* изображение   окружности   с    использованием    алгоритма
           Брезенхама */

         void circle(x_center,y_center,radius,color_code)
         int x_center,y_center,radius,color_code;
         {
            register x,y,delta;
            asp_ratio=1.0; /* это число меняется в различных
                              случаях */
             y=radius;
             delta=3-2*radius;
             for (x=0;x<y; ) {
                 plot_circle(x,y,x_center,y_center,color_code);
                 if (delta<0)
                    delta+=4*x+6;
                 else {
                    delta+=4*(x-y)+10;
                    y--;
                 }
                 x++;
              }
              x=y;
              if (y) plot_circle(x,y,x_center,y_center,color_code);
           }

         /* plot_circle печатает точки, определяющие окружность */
           void plot_circle(x, y, x_center, y_center, color_code)
           int x_center,y_center,radius,color_code;
           {
              int x, y, startx, starty, endx, endy, x1, y1;
              starty=y*asp_ratio;
              endy=(y+1)*asp_ratio;
              startx=x*asp_ratio;
              endx=(x+1)*asp_ratio;

              for (x1=startx;x1<endx;++x1) {
                 mempoint(x1+x_center,y+y_center,color_code);
                 mempoint(x1+x_center,y_center-y,color_code);
                 mempoint(x_center-x1,y+y_center,color_code);
                 mempoint(x_center-x1,y_center-y,color_code);
              }

              for (y1=starty;y1<endy;++y1) {
                 mempoint(y1+x_center,x+y_center,color_code);
                 mempoint(y1+x_center,y_center-x,color_code);
                 mempoint(x_center-y1,x+y_center,color_code);
                 mempoint(x_center-y1,y_center-x,color_code);
              }
           }
       }

       /* закрашивание окружности путем повторного вызова
            circle() с уменьшением радиуса */

            void fill_circle(x,y,r,c)
            int x,y,r,c;
            {
               while (r) {
                  circle(x,y,r,c);
                  r--;
               }
            }
        /* запись точки в CGA/EGA */

         void mempoint(x,y,color_code)
         int x,y,color_code;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=0xFF3F; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return;
            xor=color_code & 128; /* проверка, устанавливался ли
                                     режим "исключающего ИЛИ" */
            color_code=color_code & 127; /* маска старших битов */

            /*  установка битовой маски и битов режима цвета
                в правую позицию */

             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             color_code<<=2*(3-bit_position); /* сдвиг кода цвета
                                        в нужную позицию */
             bit_mask.i>>=2*bit_position; /* сдвиг битовой маски в
                                          нужную позицию */

             /* определение требуемого байта в памяти терминала */

              index=x*40+(y%4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */

               if (!xor) {  /* режим изменения цвета */
                  t=*(ptr+index) & bit_mask.c[0];
                  *(ptr+index)=t|color_code;
               }
               else {
                  t=*(ptr+index) | (char)0;
                  *(ptr+index)=t & color_code;
               }
            }

        /* отображение графического курсора */
         void xhairs(x,y)
         int x,y;
         {
            line(x-4,y,x+3,y,1|128);
            line(x,y+4,x,y-3,1|128);

          }

        /* чтение байта из оперативной памяти CGA/EGA */
         unsigned char read_point(x,y)
         int x,y;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=3; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return 0;

            /*  установка битовой маски и битов режима цвета
                в правую позицию */
             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             bit_mask.i<<=2*(3-bit_position);

             /* определение требуемого байта в памяти терминала */
              index=x*40+(y>>4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */
               t=*(ptr+index) & bit_mask.c[0];
               t>>=2*(3-bit_position);
               return t;
            }

       /* сохранение  графического изображения  */

        void save_pic()
        {
          char fname[80];
          FILE *fp;
          register int i,j;
          char far *ptr=(char far *) 0xB8000000; /* точка в
                                                 памяти   CGA  */
          char far *temp;
          unsigned char buf[14][80]; /* содержит образ экрана */

          temp=ptr;
        /* сохранение верхних строк текущего содержимого экрана */
          for (i=0;i<14;++i)
             for (j=0;j<80;++j) {
                buf[i][j]=*temp; /* четный байт */
                buf[i][j+1]=*(temp+8152); /* нечетный байт */
                *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                temp++;
             }
           goto_xy(0,0);
           printf("Имя файла:");
           gets(fname);
           if (!(fp=fopen(fname,"wb"))) {
               printf("Файл не может быть открыт\n");
               return;
           }

           temp=ptr;
       /* восстановление содержимого экрана */
          for (i=0;i<14;++i)
             for (j=0;j<80;++j) {
                *temp= buf[i][j]; /* четный байт */
                *(temp+8125)=buf[i][j+1]; /* нечетный байт */
                *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                temp++;
             }
        /* копирование изображения в файл  */
           for (i=0;i<8152;i++) {
              putc(*ptr,fp); /* четный байт */
              putc(*(ptr+8125),fp); /* нечетный байт */
              ptr++;
           }

           fclose(fp);
        }


       /* загрузка изображения */

         void load_pic()
         {
            char fname[80];
            FILE *fp;
            register int i,j;

            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                   памяти   CGA  */
            char far *temp;
            unsigned char buf[14][80]; /* содержит образ экрана */

            temp=ptr;
        /* сохранение верхних строк текущего содержимого экрана */
            for (i=0;i<14;++i)
               for (j=0;j<80;j+=2) {
                  buf[i][j]=*temp;
                  buf[i][j+1]=*(temp+8152);
                  *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                  temp++;
               }
            goto_xy(0,0);
            printf("Имя файла:");
            gets(fname);
            if (!(fp=fopen(fname,"rb"))) {
               goto_xy(0,0);
               printf("Файл не может быть открыт\n");
               temp=ptr;
       /* восстановление содержимого экрана */
               for (i=0;i<14;++i)
                  for (j=0;j<80;j+=2) {
                     *temp= buf[i][j];
                     *(temp+8125)=buf[i][j+1];
                     temp++;
                  }
               return;
             }
      /* загрузка изображения из файла */
           for (i=0;i<8152;i++) {
              *ptr=getc(fp); /* четный байт */
              *(ptr+8125)=getc(fp); /* нечетный байт */
              ptr++;
           }

           fclose(fp);
        }

       /*  поместить курсор в заданное положение */
           void goto_xy(x,y)
           int x,y;
           {
              r.h.ah=2; /* адресация курсора */
              r.h.dl=y; /* координата столбца */
              r.h.dh=x; /* координата строки */
              r.h.bh=0; /* видеостраница */
              int86(0x10,&r,&r);
            }


       /* копирование части экрана в другую область */

          void copy(startx,starty,endx,endy,x,y)
          int startx,starty; /* верхняя левая координата */
          int endx,endy; /* нижняя правая координата области
                            копирования */
          int x,y; /* верхняя левая координата области,
                     куда будет проводится копирование */
          {
             int i,j;
             unsigned char c;

             for (;startx<endx;startx++,x++)
                for (i=starty,j=y;i<endy;i++,j++) {
                   c=read_point(startx,i); /* чтение точки */
                   mempoint(x,j,c); /* запись ее в новую область */
                 }
            }


       /* пересылка части экрана в другую область */

          void move(startx,starty,endx,endy,x,y)
          int startx,starty; /* верхняя левая координата */
          int endx,endy; /* нижняя правая координата области
                            пересылки */
          int x,y; /* верхняя левая координата области,
                     куда будет проводиться пересылка */
          {
             int i,j;
             unsigned char c;

             for (;startx<endx;startx++,x++)
                for (i=starty,j=y;i<endy;i++,j++) {
                   c=read_point(startx,i); /* чтение точки */
                   mempoint(startx,i,0); /* стирание старого
                                            изображения */
                   mempoint(x,j,c); /* запись точки в новую область */
                 }
            }


        /* вращение точки вокруг центра с координатами
           x_org и y_org на угол theta */

          void rotate_point(theta,x,y,x_org,y_org)
          double theta,*x,*y;
          int x_org,y_org;
          {
             double tx,ty;

        /* нормализация X и Y к начальному адресу */
             tx=*x-x_org;
             ty=*y-y_org;

        /* вращение */
              *x=tx*cos(theta)-ty*sin(theta);
              *y=tx*sin(theta)-ty*cos(theta);

         /* возвращение значений координат */
              *x+=x_org;
              *y+=y_org;
           }


          /* Вращение заданных объектов */

          void rotate_object(ob, theta, x, y, sides)
          double ob[][4]; /* описание объекта */
          double theta;   /* угол поворота в радианах */
          int x, y;
          int sides;
            {
            register int i, j;
            double tempx, tempy;
            char ch;

            for(;;)
              {
              ch = getch(); /* ввод признака направления вращения */
              switch(tolower(ch))
                {
                case 'l': /* вращение против часовой стрелки */
                  theta = theta < 0 ? -theta : theta;
                  break;
                case 'r': /* вращение по часовой стрелке  */
                  theta = theta > 0 ? -theta : theta;
                  break;
                default: return;
                }
              for(j=0; j<=sides; j++) /* стирание старых линий  */
                {
                line((int) ob[j][0], (int) ob[j][1],
                     (int) ob[j][2], (int) ob[j][3], 0);
                rotate_point(theta, &ob[j][0], &ob[j][1], x, y);
                rotate_point(theta, &ob[j][2], &ob[j][3], x, y);
                line((int) ob[j][0], (int) ob[j][1],
                     (int) ob[j][2], (int) ob[j][3], 2);
                }
              }
            }


          /* отображение объекта на экране */
          void display_object(ob, sides)
          double ob[][4];
          int sides;
            {
            register int i;

            for(i=0; i<sides; i++)
              line((int)ob[i][0], (int)ob[i][1],
                   (int)ob[i][2], (int)ob[i][3], 2);
            }

       /* определение объекта по заданным точкам */
            define_object(ob,x,y)
            double ob[][4];
            int x,y;
            {

            union k{
              char c[2];
              int i;
               } key ;
            register int i,j;

            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                   памяти   CGA  */
            char far *temp;
            unsigned char buf[14][80]; /* содержит образ экрана */
            int sides=0;

            temp=ptr;
        /* сохранение верхних строк текущего содержимого экрана */
            for (i=0;i<14;++i)
               for (j=0;j<80;j+=2) {
                  buf[i][j]=*temp;
                  buf[i][j+1]=*(temp+8152);
                  *temp=0; *(temp+8152)=0; /* чистка позиций экрана */
                  temp++;
               }

              i=0;
              xhairs(x,y);
              do {
                 goto_xy(0,0);



             printf("Определите сторону %d,",sides+1);
                 if (i==0) printf("Введите первую габаритную точку ");
                 else printf("Введите вторую габаритную точку ");

                 key.i=bioskey(0);
                 xhairs(x,y);
                 if (key.c[0]=13) {
                    ob[sides][++i]=(double) x;
                    ob[sides][++i]=(double) y;
                    if (i==4) {
                       i=0;
                       sides++;
                    }
                  }
                 /* перемещение графического курсора */
                 if (rey.c[0]) switch (key.c[1]) {
                    case 75: /* влево */
                       y-=1;
                       break;
                      case 77: /* вправо */
                       y += 1
                       break;
                     case 72: /* вверх */
                            x -= 1;
                       break;
                     case 80: /* вниз */
                            x += 1;
                       break;
                     case 71: /* вверх и влево */
                          x -= 1;
                       y -= 1;
                       break;
                     case 73: /* вверх и вправо */
                          x -= 1;
                       y += 1;
                       break;
                     case 79: /* вниз и влево */
                       x += 1;
                       y -= 1;
                       break;
                     case 81: /* вниз и вправо */
                          x += 1;
                       y += 1;
                       break;
                    }
                    if (key.c[1]!=59) xhairs(x,y);

                 }  while (key.c[1]!=59); /* нажата клавиша F1 */

                 /* восстановление содержимого экрана */
                 for (i=0;i<14;++i)
                    for (j=0;j<80;j+=2) {
                       *temp= buf[i][j];
                       *(temp+8125)=buf[i][j+1];
                       temp++;
                    }
                 return sides;
              }


          Хотя в этой программе довольно много  операторов,  вам  надо
     ввести ее в свой компьютер, так как она довольно интересна. Также
     она   будет   являться   хорошим   графическим   инструментальным
     средством,   которое  вы  сможете  использовать  в  любой  момент
     времени.



                                ГЛАВА 5.
                                --------

                               ВИДЕОИГРЫ
     -----------------------------------------------------------------
           Видеоигры приносят вам либо радость,  либо  огорчения.  Это
     зависит  от  вашего  отношения  к  ним.  Однако  программирование
     видеоигр не только интересно,  но и полезно. Фактически, одним из
     лучших  способов обогащения является разработка удачных видеоигр.
     Хорошая игра,  объединяющая логику  с  живой  графикой,  доставит
     большое  удовольствие  игроку.  Лучшие  из  видеоигр,  включающие
     элементы искусственного интеллекта,  позволяют  компьютеру  вести
     диалог с игроком и "осмысленно" реагировать на ввод данных.
           В этой главе вы ознакомитесь  с некоторыми основами техники
     программирования видеоигр,   что   позволит   вам   разрабатывать
     собственные  игры.  Вы  научитесь "оживлять" различные объекты на
     экране вашего  терминала.  Разработка  видеоигр  явится  для  вас
     отправной  точкой.  Многие принципы,  используемые при разработке
     видеоигр,  будут полезны для вас и увеличат ваш интерес к работе.
     Для использования программ,  приводимых в качестве примера в этой
     главе,  необходим компьютер IBM PC или другой, совместимый с ним,
     в  состав  которого входят адаптеры CGA,  EGA или VGA.  Многие из
     функций,  используемых в данной главе, рассматривались в главе 4.
     Поэтому,  если вы еще не изучили главу 4, то вам придется сделать
     это сейчас.



                                  СПРАЙТЫ
     -----------------------------------------------------------------

          Многие видеоигры,   в  которых  игрок  управляет  объектами,
     атакующими   другие   объекты,   управляемые    программой    или
     защищающимися  от  них,  включают  два  класса активных объектов:
     среду  (представляющую  для  нас  маломеняющееся  поле  игры)   и
     спрайты.   СПРАЙТ  -  это  небольшой  подвижный  объект,  который
     движется по полю видеоигры по определенным  правилам  с  заданной
     целью.  Например,  когда  космический  корабль стреляет фотонными
     торпедами,  изображение торпеды реализуется  спрайтом.  В  рамках
     данной  главы  под  спрайтом будем понимать фигуру,  определенную
     некоторыми замкнутыми отрезками (многоугольник).  Хотя,  в  общем
     случае спрайт может изображаться любым образом,  например, в виде
     окружности.  В  примерах,   рассматриваемых   в   данной   главе,
     определять  спрайт  будем  в виде двумерного массива целых чисел.
     Например,  спрайт,  состоящий из 4  отрезков  может  быть  описан
     следующим массивом

                             int sprite [4][4];

          Первая размерность  массива  определяет  количество отрезков
     спрайта,  а вторая - координаты конечных точек отрезков (подобный
     способ  описания   объектов  подробно  рассмотрен  в   главе  4).
     Начальные и конечные  координаты  отрезков  задаются  в следующей
     последовательности:

                       start_x, start_y, end_x, end_y

          Отрезок,  входящий  в спрайт,  с координатами конечных точек
     0,0 и 0,10 может быть описан следующим массивом:

               sprite[0][0] = 0;   /* start_x */
               sprite[0][1] = 0;   /* start_y */
               sprite[0][2] = 0;   /* end_x */
               sprite[0][3] = 10;  /* end_y */



                                 ПОЛЕ ИГРЫ
     -----------------------------------------------------------------

          В большинстве  видеоигр   поле   игры   представляет   собой
     неменяющееся   (медленно   меняющееся)  изображение,  на  котором
     происходит  действие  игры.  Поле  игры  изображается  отдельными
     программами,    загружаемыми   в   начале   игры,   поэтому   нет
     необходимости  загружать  все  программы  верхнего   уровня   для
     динамической  генерации  игрового  поля.  Такой  подход  описан в
     данной главе.  Программы, используемые для генерации изображений,
     их хранения в файле на диске и доступа к ним,  описаны в главе 4.
     Они загружают эти изображения по мере необходимости.



                          МУЛЬТИПЛИКАЦИЯ НА ЭКРАНЕ
     -----------------------------------------------------------------

          Ключевым и наиболее впечатляющим моментом видеоигры является
     мультипликация.  Мультипликация - основной отличительный  признак
     видеоигр.   Основной   метод   мультипликации  прост:  уничтожить
     изображение  предмета  и  создать  его  вновь,  но  с   некоторым
     небольшим  смещением.  Скорость  этого процесса должна быть очень
     высокой.  Это  может  быть  обеспечено  путем   непосредственного
     доступа  к  видеопамяти  дисплея,  возможность которого описана в
     главе 4.

          Для повышения качества изображения,  быстродействия операций
     уничтожения   и   повторного  изображения   объекта  используется
     операция  "НЕ-ИЛИ"  для двоичного кода  каждой  точки  объекта на
     экране. Этот способ обеспечивает возможность быстрого перемещения
     спрайта по экрану,  не меняя его цвет и размеры, и фактически  не
     уничтожая в памяти терминала данные о его изображении.

          Программа,   отображающая   на   экране   терминала  спрайт,
     представляет собой некоторую модификацию функции display_object()
     из главы 4.

          /* отображение объекта на экране */

          void display_object(ob, sides,cc)
          double ob[][4];
          int sides,cc;
          {
            register int i;

            for(i=0; i<sides; i++)
              line((int)ob[i][0], (int)ob[i][1],
                   (int)ob[i][2], (int)ob[i][3], cc | 128);
         }

          Как вы могли убедиться,  функция display_object() рисует все
     линии  объекта,  используя  приведенную в главе 4 функцию line().
     Заметим,  что значение номера цвета складывается по схеме "ИЛИ" с
     числом  128  в  команде  установки старших битов.  Это приводит к
     тому, что в функции mempoint(), используемой в функции line() для
     помещения изображения каждой точки, выполняется сложение по схеме
     "НЕ-ИЛИ" двоичного кода.  Это позволяет спрайту всегда оставаться
     видимым независимо от собственного цвета и цвета фона.

          Для  демонстрации  мультипликации  введите  в  ваш компьютер
     следующую программу. Эта программа позволит вам перемещать спрайт
     (в виде маленького крестика размером 6x6 точек растра) по экрану,
     используя клавиши  управления  курсором.  Если  ваш  компьютер не
     включает  функцию   bioskey(),   то   просмотрите   главу  1  для
     определения версии компилятора, которая вам необходима.


        #include "dos.h"
        #include "stdio.h"

        void mode(), line();
        void mempoint(), palette();
        void display_object(),update_object();
        unsigned char read_point();

        int sprite[2][4] = {
           3,0,3,5,
           0,3,5,3
        };

        main()
        {
             union k {
                char c[2];
                int i;
             } key;

           int deltax=0,deltay=0;

           mode(4); /*m установка 4 режима графики CGA/EGA */
           palette(0); /* палитра 0 */

           display_object(sprite,2,1);
           do {
                  key.i = bioskey(0);
                  deltax=0;deltay=0;
                  if(!key.c[0]) switch(key.c[1]) {
                     case 75: /* влево */
                        deltay= -1;
                         break;
                     case 77: /* вправо */
                        deltay= 1;
                         break;
                     case 72: /* вверх */
                        deltax= -1;
                        break;
                     case 80: /* вниз */
                        deltax= 1;
                        break;
                     case 71: /* вверх и влево */
                        deltay= -1;
                        deltax= -1;
                        break;
                     case 73: /* вверх и вправо */
                        deltay= 1;
                        deltax= -1;
                        break;
                     case 79: /* вниз и влево */
                        deltay= -1;
                        deltax= 1;
                        break;
                     case 81: /* вниз и вправо */
                        deltay= 1;
                        deltax= 1;
                        break;
                    }
                   /* стирание текущей позиции спрайта */
                   display_object(sprite,2,1);
                   if (is_legal(sprite,deltax,deltay,2))
                   update_object(sprite,deltax,deltay,2);
                   /* перезапись спрайта в новую позицию */
                   displey_object(sprite2,1);
               }   while (key.c[0]!='q');
               getchar();
               mode(2);
           }

          /* Выбор палитры */
          void palette(pnum)
          int pnum;
            {
            union REGS r;

            r.h.bh = 1; /* код 4-го графического режима */
            r.h.bl = pnum;
            r.h.ah = 11;
            int86(0x10, &r, &r);
            }

          /* Выбор режима */
          void mode(mode_code)
          int mode_code;
            {
            union REGS r;

            r.h.al = mode_code;
            r.h.ah = 0;
            int86(0x10, &r, &r);
            }

      /* Изображение линии заданного цвета с использованием
         алгоритма Брезенхама */
       void line(startx,starty,endx,endy,color)
       int startx,starty,endx,endy,color;
       {
         register int t,distance;
         int x=0,y=0,delta_x,delta_y;
         int incx,incy;

       /* Вычисление расстояния в обоих направлениях         */
         delta_x=endx-startx;
         delta_y=endy-starty;

       /* определение направления шага,
          шаг вычисляется либо по вертикальной, либо по горизонтальной
          линии                   */
          if (delta_x>0) incx=1;
          else  if (delta_x==0) incx=0;
          else  incx= -1;

          if (delta_y>0) incy=1;
          else  if (delta_y==0) incy=0;
          else  incy= -1;

        /* определение какое расстояние больше */
          delta_x=abs(delta_x);
          delta_y=abs(delta_y);
          if (delta_x>delta_y) distance=delta_x;
          else distance=delta_y;

        /* Изображение линии */
          for (t=0; t<=distance+1; t++) {
             mempoint(startx,starty,color);
             x+=delta_x;
             y+=delta_y;
             if (x>distance) {
                x-=distance;
                startx+=incx;
             }
             if (y>distance) {
                y-=distance;
                starty+=incy;
             }
          }
       }


        /* Запись точки в CGA/EGA */
         void mempoint(x,y,color_code)
         int x,y,color_code;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=0xFF3F; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return;
            xor=color_code & 128; /* проверка, устанавливался ли
                                     режим "исключающего ИЛИ" */
            color_code=color_code & 127; /* маска старших битов */

            /*  установка битовой маски и битов режима цвета
                в правую позицию */

             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             color_code<<=2*(3-bit_position); /* сдвиг кода цвета
                                        в нужную позицию */
             bit_mask.i>>=2*bit_position; /* сдвиг битовой маски в
                                          нужную позицию */

             /* определение требуемого байта в памяти терминала */

              index=x*40+(y%4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */

               if (!xor) {  /* режим изменения цвета */
                  t=*(ptr+index) & bit_mask.c[0];
                  *(ptr+index)=t|color_code;
               }
               else {
                  t=*(ptr+index) | (char)0;
                  *(ptr+index)=t & color_code;
               }
            }

        /* чтение байта из оперативной памяти CGA/EGA */
         unsigned char read_point(x,y)
         int x,y;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=3; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return 0;

            /*  установка битовой маски и битов режима цвета
                в правую позицию */
             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             bit_mask.i<<=2*(3-bit_position);

             /* определение требуемого байта в памяти терминала */
              index=x*40+(y>>4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */
               t=*(ptr+index) & bit_mask.c[0];
               t>>=2*(3-bit_position);
               return t;
            }

          /* отображение объекта на экране */

          void display_object(ob, sides,cc)
          double ob[][4];
          int sides,cc;
          {
            register int i;

            for(i=0; i<sides; i++)
              line((int)ob[i][0], (int)ob[i][1],
                   (int)ob[i][2], (int)ob[i][3], cc|128);
         }

          /* Смещение (параллельный перенос) объекта в направлении,
          определенном x и y
          */
          void update_object(ob, x, y, sides)
          int ob[][4];        /* объект */
          int x, y;           /* направление смещения */
          register int sides; /* количество сторон объекта */
            {
            sides--;
            for(; sides>=0; sides--)
              {
              ob[sides][0] += x;
              ob[sides][1] += y;
              ob[sides][2] += x;
              ob[sides][3] += y;
              }
            }

          /* Определение допустимости перемещения объекта.
          Возвращает 1, если перемещение допустимо, 0- в
          противном случае
          */
          void is_legal(ob, x, y, sides)
          int ob[][4];          /* объект */
          int x, y;             /* шаг перемещения */
          int sides;            /* число сторон объекта */
            {
            if(x==0 && y==0)
              return 1;      /* пустое перемещение всегда допустимо*/
            sides--;
            for(; sides>=0; sides--)
              {
              /* контроль выхода за допустимую область */
              if(ob[sides][0]+x>199 || ob[sides][1]+y>319)
                return 0;
              if(ob[sides][2]+x<0 || ob[sides][3]+y<0)
                return 0;
              }
            return 1;
            }

           Рассмотрим кратко,  как  работает  эта  программа.  Клавиши
     управления курсором  (клавиши  со  стрелками  и  клавиши  <HOME>,
     <PGUP>, <END> и <PGDN>) определяют положение спрайта. При нажатии
     клавиши  спрайт  смещается  на  одну  точку  растра  в  указанном
     направлении.    Клавиши-стрелки    управляют   горзонтальными   и
     вертикальными перемещениями,  остальные - диагональными.  Функция
     is_legal() определяет возможность дальнейшего перемещения спрайта
     в выбранном направлении.  Если возможен выход спрайта за  пределы
     границ  экрана,  то такое перемещение запрещается.  Все остальные
     функции этой программы работают, как описано в главе 4.

           Обычно необходимо  сохранять  размер  объекта,  который  вы
     "оживляете" (особенно небольшого) для того,  чтобы его можно было
     перерисовывать с высокой скоростью.  Это  обеспечивает  плавность
     движения при мультипликации.  Если объект достаточно большой,  то
     его движение будет дискретно.  При разработке видеоигр необходимо
     так  подбирать  размеры  спрайта,  чтобы возможности компьютера и
     адаптера реализовывались оптимальным образом.



               МУЛЬТИПЛИКАЦИЯ СПРАЙТА
     -----------------------------------------------------------------

          Передвижение спрайта  по  экрану  составляет только половину
     возможностей   его   "оживления".   В   основном   спрайт   будет
     использоваться  на  экране  для  того,  чтобы  создавать  иллюзию
     движения.  Например,  спрайт,  который выглядит подобно человеку,
     может   передвигать   ногами,   как   будто  он  идет.  Этот  тип
     "оживления" является наиболее впечатляющим (и  наиболее  легким).
     Для  обеспечения  такой возможности разрабатываются два или более
     вариантов спрайта,  отличие между которыми заключается в том, что
     некоторые  из  частей  спрайта  отличаются от первоначального его
     варианта.  Программа последовательно меняет  варианты  спрайта  в
     процессе его движения по экрану.

          В качестве   примера   изменим  программу  main(),  как  это
     показано ниже,  и добавим в  нее  второй  спрайт.  Второй  спрайт
     отображает  крестик  ("+"),  повернутый  под углом в 45 градусов.
     Если вы запустите программу,  то будет  создаваться  впечатление,
     что   крестик   вращается  в  процессе  передвижения  по  экрану.
     Переменная swap используется для выбора типа текущего спрайта.


        int sprite2[2][4] = {
           0,0,5,5,
           0,5,5,0
        };

        main()
        {
             union k {
                char c[2];
                int i;
             } key;

           int deltax=0,deltay=0; /* направление движения */
           int swap=0; /* тип спрайта */

           mode(4); /* установка 4 режима графики CGA/EGA */
           palette(0); /* палитра 0 */

           display_object(sprite,2,1);
           do {
                  key.i = bioskey(0);
                  deltax=0;deltay=0;
                  if(!key.c[0]) switch(key.c[1]) {
                     case 75: /* влево */
                        deltay= -1;
                         break;
                     case 77: /* вправо */
                        deltay= 1;
                         break;
                     case 72: /* вверх */
                        deltax= -1;
                        break;
                     case 80: /* вниз */
                        deltax= 1;
                        break;
                     case 71: /* вверх и влево */
                        deltay= -1;
                        deltax= -1;
                        break;
                     case 73: /* вверх и вправо */
                        deltay= 1;
                        deltax= -1;
                        break;
                     case 79: /* вниз и влево */
                        deltay= -1;
                        deltax= 1;
                        break;
                     case 81: /* вниз и вправо */
                        deltay= 1;
                        deltax= 1;
                        break;
                    }
                   /* стирание текущей позиции спрайта */
                   if(!swap) displey_object(sprite,2,1);
                   else displey_object(sprite2,2,1);

                   if (is_legal(sprite,deltax,deltay,2)) {
                      update_object(sprite,deltax,deltay,2);
                      update_object(sprite2,deltax,deltay,2);
                   }
                   swap= !swap; /* смена типа спрайта */
                   /* перезапись спрайта в новую позицию */
                   if (!swap) displey_object(sprite,2,1);
                   else displey_object(sprite2,2,1);
               }   while (key.c[0]!='q');
               getchar();
               mode(2);
           }



                      ОРГАНИЗАЦИЯ ДАННЫХ В ВИДЕОИГРАХ
     -----------------------------------------------------------------

          Подобно остальным  программам,  программы  видеоигр включают
     как  операторы,  так  и  данные.  Кроме  счета  игры  и   статуса
     различных,   расходуемых  в  процессе  игры  ресурсов  (например,
     количество  запущенных  фотонных  торпед),  большинство   данных,
     используемых в видеоиграх,  представляют собой позиции экрана для
     различных объектов.  Координаты  позиций  экрана  для  движущихся
     объектов  должны храниться в установленных переменных. Информацию
     о фиксированных  объектах  игрового  поля  целесообразно  хранить
     непосредственно  в  видеопамяти  терминала.  Если в процессе игры
     потребуется информация для изменения игрового поля (как это часто
     бывает), осуществляется доступ к видеопамяти и оттуда считываются
     массивы с информацией об измененном объекте.



          Контрооль границ.
          -----------------

          В большинстве видеоигр существуют спрайты, которые находятся
     под  управлением  пользователя.  Обычно  игроку  не   разрешается
     перемещать спрайт через некоторые объекты игрового поля или через
     другой спрайт.  Есть  два  способа  ограничения   местонахождения
     спрайта.  В  первом  способе  в установленных переменных хранятся
     граничные точки области,  где  разрешено  движение  спрайта.  При
     передвижении  спрайта  по экрану осуществляется контроль на выход
     за пределы этих допустимых значений.  Однако этот метод  обладает
     довольно  малой  реактивностью  и  для  игр с большим количеством
     объектов неэффективен.  Более удобным способом  является  простая
     проверка  области  экрана на предмет нахождения в ней какого-либо
     объекта путем контроля соответствующей области  видеопамяти.  Это
     обеспечивается тем,  что информация об игровом поле уже находится
     в видеопамяти и бессмысленно ее где-либо дублировать.


          Изменение цвета.
          ----------------

          В процессе игры удобно оперировать объектами  разного цвета.
     Например,  красный  цвет  может отображать границы непересекаемых
     областей, зеленый цвет используется для вашего спрайта,  а желтый
     - для спрайта противника. Хотя это можно сделать с использованием
     переменных, описывающих эти объекты, часто бывает удобнее заранее
     определять  для объекта его цвет.  Это не только упростит процесс
     программирования   видеоигры,   но    и    сделает    ее    более
     быстродействующей. Например, если в пурпурный цвет окрашена мина,
     то считается,  что вы на ней подорвались лишь в том случае,  если
     одна из точек вашего спрайта окрашивается в пурпурный цвет.

          Программирование в  цвете  видеоигр  имеет  длинную историю.
     Например, первая игра "пинг-понг" имела только два цвета: белый и
     черный.  В  этой  игре  белый  цвет  был несовместим с белым (они
     отталкивались), но можно было двигаться по черному игровому полю.
     Таким образом, белый шарик мог перемещаться по черному полю, если
     ударялся белой ракеткой или  отражался  от  белой  стены  (линии)
     позади  ракетки.  Эти  основные  принципы использовались и тогда,
     когда в игре стали появляться и другие  цвета.  После  того,  как
     объекты  видеоигр  стали  программироваться  в цвете,  разработка
     программ обработки игровых  ситуаций  значительно  упростилась  и
     увеличилась скорость их работы.



                      ТАБЛО СЧЕТА АКТИВНОГО ПРОТИВНИКА
     -----------------------------------------------------------------

          Роль компьютера в игре во многом зависит от  того,  является
     ли  эта  игра  для  одного  человека  или для двоих.  Если в игре
     участвуют два  человека,  компьютеру  отводится  роль  арбитра  и
     функции   табло  для  отображения  счета.  Однако,  в  игре,  где
     участвует один игрок,  компьютер становится активным противником.
     С  точки  зрения  программирования разработка игр,  где компьютер
     выступает в роли противника, значительно интересней.



                           РАЗРАБОТКА  ВИДЕОИГРЫ
     -----------------------------------------------------------------

          В этом  параграфе  мы  опишем разработку видеоигры,  которая
     иллюстрирует многие принципы, описанные в данной главе.


          Описание игры
          -------------

          Первым шагом  в   процессе   создания   видеоигры   является
     определение   ее  природы  и  правил,  по  которым  она  ведется.
     Программа, описанная здесь, представляет собой компьютеризованную
     версию  традиционной  детской  игры "салочки".  Игрок и компьютер
     управляют каждый своим "человеком". Один из них догоняет другого,
     и,  если  у  них  произошел  контакт,  происходит  смена  амплуа.
     Победителем в игре становится тот, кто больший промежуток времени
     был в положении догоняемого.

          Cчет определяется  путем  фиксации  игрового времени:  после
     каждой  прошедшей  секунды  добавляется  одно  очко   тому,   кто
     находится в роли догоняемого. Счет непрерывно отображается в углу
     экрана.  Игра заканчивается,  когда один из игроков набирает  999
     очков.  Для  удобства  игра  может  быть  закончена путем нажатия
     клавиши <Q>.

          Игрок управляет   движением   спрайта   посредством   клавиш
     управления  курсором.  Игровое  поле в данном случае не создается
     самой программой игры.  Для  этих  целей  используются  программы
     рисования ("программы-художники"),  описанные в главе 4. Поэтому,
     вы можете самостоятельно создавать различную среду игры.


          Использование цвета и граничные условия.
          ---------------------------------------

          Игра "салочки"  использует  программирование  в  цвете   для
     идентификации  различных  объектов.  Например,  вы можете сделать
     спрайт игрока зеленым, спрайт компьютера - желтым, а границы поля
     игры   -   красными.   В   соответствии   с  этим  подходом,  нет
     необходимости хранить  отдельные  массивы  данных  в  разделяемой
     области программы,  т.к. подпрограммы могут просто контролировать
     содержимое видеопамяти.  В данном  случае,  так  же,  значительно
     упрощается  процесс ограничения области движения спрайтов красной
     линией.  Для  этой  цели  необходимо  немного  изменить   функцию
     is_legal(), описанную ранее, как это показано ниже.

          /* Определение допустимости перемещения объекта.
          Возвращает 1, если перемещение допустимо, 0 - в
          противном случае
          */
          void is_legal(ob, x, y, sides)
          int ob[][4];          /* объект */
          int x, y;             /* шаг перемещения */
          int sides;          /* число сторон объекта */
            {
            if(x==0 && y==0)
              return 1;    /* пустое перемещение всегда допустимо*/
            sides--;
            for(; sides>=0; sides--)
              {
              /* контроль выхода за допустимую область */
              if(ob[sides][0]+x>199 || ob[sides][1]+y>319)
                return 0;
              if(ob[sides][2]+x<0 || ob[sides][3]+y<0)
                return 0;
              /* контроль препятствий */
              if(read_point(ob[sides][0]+x, ob[sides][1]+y)==2)
                return 0;
              if(read_point(ob[sides][2]+x, ob[sides][3]+y)==2)
                return 0;
              }
            return 1;
            }

          Напомним коды  различных  цветов:  желтый - 1,  красный - 2,
     зеленый - 3, черный (фон) - 0.


          Описание спрайта.
          -----------------

          Спрайт,  используемый в данной игре, будет похож на бегущего
     человека.

     _________________________________________________________________

      Вид спрайта на стр. 187 не может быть воспроизведен имеющимися
      средствами. (Ред. пер. И.Бычковский.)
     _________________________________________________________________

          В программе  существует два типа спрайта.  Во втором спрайте
     ноги "человека" сжаты вместе.  Быстрая смена между  изображениями
     двух типов спрайта создает иллюзию бегущего человека.

          Спрайт пользователя  начинает  игру  в  верхнем  левом  углу
     экрана, а спрайт компьютера - в нижнем правом.  Описание спрайтов
     приведено ниже.

          int human[4][4] = /* это ваш спрайт */
               {
               1,     6,     6,     6,
               4,     2,     3,     9,
               9,     1,     6,     6,
               9,     11,    6,     6
               };

          int human2[4][4] =
               {
               1,     6,     6,     6,
               4,     2,     3,     9,
               9,     3,     6,     6,
               9,     9,     6,     6
               };

          int computer[4][4] = /* это  спрайт компьютера */
               {
               180,     6,     185,     6,
               183,     2,     182,     9,
               188,     1,     185,     6,
               188,     11,    185,     6
               };
          int computer2[4][4] =
               {
               180,     6,     185,     6,
               183,     2,     182,     9,
               188,     3,     185,     6,
               188,     9,     185,     6
               };



               ТЕЛО ГЛАВНОЙ ПРОГРАММЫ
     -----------------------------------------------------------------

          После того   как   вы  научитесь  разрабатывать  собственные
     видеоигры,  вы поймете,  что все они  имеют  одну  главную  общую
     деталь  - программу,  управляющую игрой.  Алгоритм таких программ
     довольно-таки сходен для различных  видеоигр.  Главная  программа
     генерирует  движение  объектов  по  экрану,  контролирует нажатие
     клавиш пользователем и реагирует на них,  проверяет  допустимость
     заданных  перемещений,  подсчитывает  набранные очки и отображает
     счет,  последовательно вызывает функции отображения  объектов  на
     экране.


          int directx,directy; /* направление  */

          main()
          {
             union k {
                char c[2];
                int i;
             } key;

           int deltax=0,deltay=0;
           int swaph=0,swapc=0;
           int it=COMPUTER;
           long htime,ctime,starttime,curtime; /* таймер счета */
           int count;
           mode(4); /* установка 4 режима графики CGA/EGA */
           palette(0); /* палитра 0 */

           load_pic(); /* ввод игрового поля */

           time(&starttime); /* установка времени */
           htime=ctime=0;

           display_object(human,4,1);
           display_object(computer,4,3);
           count=0;

           /* главный цикл игры */
           do {
               /* вычисление текущего счета  */
              time(&curtime);
              if (it==COMPUTER) htime+=curtime-starttime;
              else ctime+=curtime-starttime;
              time(&starttime);
              show_score(it,htime,ctime);

              if (bioskey(1)) { /* если нажата клавиша */
                  directx=directy=IDLE; /* устанавливает
                               направление перемещения */
                  key.i = bioskey(0);
                  deltax=0;deltay=0;
                  if(!key.c[0]) switch(key.c[1]) {
                     case 75: /* влево */
                        deltay= -1;
                        directy=LEFT;
                        break;
                     case 77: /* вправо */
                        deltay=1;
                        directy=RIGHT;
                        break;
                     case 72: /* вверх */
                        deltax= -1;
                        directx=UP;
                         deltax= -1;
                        directx=UP;
                        break;
                     case 80: /* вниз */
                        deltax=1;
                        directx=DOWN;
                        break;
                     case 71: /* вверх и влево */
                        deltay= -1;
                        directy=LEFT;
                        deltax= -1;
                        directx=UP;
                        break;
                     case 73: /* вверх и вправо */
                        deltay=1;
                        directy=RIGHT;
                        deltax= -1;
                        directx=UP;
                        break;
                     case 79: /* вниз и влево */
                        deltay= -1;
                        directy=LEFT;
                        deltax=1;
                        directx=DOWN;
                        break;
                     case 81: /* вниз и вправо */
                        deltay=1;
                        directy=RIGHT;
                        deltax=1;
                        directx=DOWN;
                        break;
                   }
                 }
                 /* смена типа спрайта игрока  */
                 if (!swaph) display_object(human,4,1);
                 else display_object(human2,4,1);
                 if (is_legal(human,deltax,deltay,4)) {
                    update_object(human,deltax,deltay,4);
                    update_object(human2,deltax,deltay,4);
                 }
                 /* проверяет: попался ли убегающий */
                 if (!count && tag(human,computer)) {
                    it= !it; /* смена амплуа */
                    count=6;
                 }
                 swaph= !swaph; /* смена фигуры имитирующей бег */

                 /* изображение "человека" в новой позиции */
                 if (!swaph) displey_object(human,4,1);
                 else displey_object(human2,4,1);

                 if (!swapc) display_object(computer,4,3);
                 else display_object(computer2,4,3);

                 /* генерация движения спрайта компьютера */
                 if (it==COMPUTER)
                 it_comp_move(computer,computer2,human,4);
                 else
               not_it_comp_move(computer,computer2,directx,directy,4);
                 if (!count && tag(human,computer)) {
                    it= !it;
                    count=6;
               /* компьютер догоняет; изменение координаты Х на 2
                  так, чтобы быстрей стать догоняемым
               */
                     if (is_legal(computer, 2, 0, 4))
                     {
                        update_object(computer, 2, 0, 4);
                       update_object(computer2, 2, 0, 4);
                    }
                   else
                   {
                     update_object(computer, -2, 0, 4);
                     update_object(computer2, -2, 0, 4);
                   }
                }
                swapc = !swapc; /* заменить тип спрайта */
            /* вывод на экран спрайта компьютера */
                if(!swapc) display_object(computer, 4, 3);
                else       display_object(computer2, 4, 3);
                if(count) count--;
             }
             while (key.c[0] !='q' && htime<999 && ctime<999);
             mode(2);
             if(ctime>htime)
                printf("Компьютер выиграл!");
             else
                printf("Вы победили!");
           }


          В  теле главной  программы экран терминала устанавливается в
     4-й графический режим,  выбирается палитра 0  и  инициализируются
     переменные  счета  игры.  После  этого оба спрайта отображаются в
     своих исходных позициях.

          Переменная htime содержит значение счета игрока,  а ctime  -
     компьютера.  Переменные  swapc и swaph предназначены для указания
     типа спрайта.  Переменные  deltax  и  deltay  содержат  изменения
     значений  координат  после  очередного  нажатия  клавиш  игроком.
     Глобальные  переменные  directx  и  directy  содержат  координаты
     спрайта, управляемого игроком. Значения этих величин используются
     компьютером для генерации перемещения своего спрайта. Переменная-
     признак  it  содержит  информацию  о  том,  кто  в  данный момент
     находится в режиме догоняющего.  Она может принимать одно из двух
     значений,  описанных  в  макроопределении  #define:  COMPUTER или
     HUMAN.

          Главная   программа   работает    циклически.    На   экране
     отображается  текущий  счет.  После  этого  проверяется,  была ли
     нажата  какая-либо  клавиша.   Если   клавиша   была  нажата,  то
     определяется ее  код и производится  заданное перемещение спрайта
     игрока.  Обратите  внимание  на  то,  что в  данной программе нет
     режима ожидания  нажатия клавиши игроком.  Поэтому,  не смотря на
     то,  что игрок  не  нажимает  клавиш,  компьютер  продолжает свою
     работу,  и спрайт игрока продолжает указанное  перемещение до тех
     пор,  пока не будет нажата другая клавиша. Такое движение спрайта
     обеспечивает достаточно высокую динамичность игры.

          После очередного   перемещения   спрайта  игрока,  компьютер
     генерирует движение собственного спрайта,  если  это  необходимо.
     Обратите  внимание  на  то,  что  для  генерации движения спрайта
     используются различные функции в зависимости  от  того  в  режиме
     догоняющего  или  догоняемого  находится  спрайт.  При реализации
     очередного перемещения собственного  спрайта,  компьютер  так  же
     проверяет его корректность.

          Рассмотрим некоторые программы, используемые в этой игре.


          Программа генерации движения спрайта компьютера.
          ------------------------------------------------

          Если спрайт  компьютера  находится в режиме догоняющего,  то
     для генерации очередного его кванта движения используется функция
     it_comp_move(). В основном компьютер повторяет стратегию движения
     пользователя. Движение его спрайта отклоняется из-за того, что он
     должен  обходить  объекты-препятствия.  Однако  спрайт компьютера
     может игнорировать некоторые  объекты,  что  позволяет  выровнять
     баланс игры.

          Приведем текст функции it_comp_move().


          /* Генерация движения спрайта компьютера, когда
             он в роли догоняющего */
          void it_comp_move(ob1, ob2, human, sides)
          int ob1[][4], ob2[][4], human[][4], sides;
               {
               register int x, y, d; /* d = direction */
               static skip = 0;
               skip++;
               if(skip==3)
                 {
                 skip=0;
                 return;
                 /* уменьшение времени реакции компьютера */
                 }
               x = 0;
               y = 0;

        /* движение к игроку */
          if(human[0][0]<ob1[0][0])
                 x = -1;
               else
                 if(human[0][0]>ob1[0][0])
                   x = 1;
               if(human[0][1]<ob1[0][1])
                 y = -1;
               else
                 if(human[0][1]>ob1[0][1])
                   y = 1;

               if(is_legal(ob1, x, y, sides))
                 {
                 update_object(ob1, x, y, sides);
                 update_object(ob2, x, y, sides);
                 }
               else
                 {
                 if(x && is_legal(ob1, x, 0, sides))
                   {
                   update_object(ob1, x, 0, sides);
                   update_object(ob2, x, 0, sides);
                   }
                 else
                   if(is_legal(ob1, 0, y, sides))
                   {
                   update_object(ob1, 0, y, sides);
                   update_object(ob2, 0, y, sides);
                   }
                 }
               }

          Заметим, что эта функция меняет положение спрайта в  3  раза
     медленнее,  чем  это возможно.  Делается такое замедление с целью
     снижения быстродействия компьютера до уровня человека.

          Функция, генерирующая движение спрайта в режиме догоняемого,
     обеспечивает  движение  в  сторону,  противоположную  от  спрайта
     игрока. Хотя этот алгоритм является неоптимальным, он делает игру
     достаточно  привлекательной  и  требует  от  пользователя хорошей
     реакции.


          /* Генерация движения спрайта компьютера, когда
             он выступает в роли убегающего */
          void it_comp_move(ob1, ob2, human, sides)
          int ob1[][4], ob2[][4], human[][4], sides;
               {
               register int x, y, d; /* d = direction */
               static skip = 0;
               skip++;
               if(skip==3)
                 {
                 skip=0;
                 return;
                 /* уменьшение времени реакции компьютера */
                 }
               x = 0;
               y = 0;

        /* движение к игроку */
          if(human[0][0]<ob1[0][0])
                 x = -1;
               else
                 if(human[0][0]>ob1[0][0])
                   x = 1;
               if(human[0][1]<ob1[0][1])
                 y = -1;
               else
                 if(human[0][1]>ob1[0][1])
                   y = 1;

               if(is_legal(ob1, x, y, sides))
                 {
                 update_object(ob1, x, y, sides);
                 update_object(ob2, x, y, sides);
                 }
               else
                 {
                 if(x && is_legal(ob1, x, 0, sides))
                   {
                   update_object(ob1, x, 0, sides);
                   update_object(ob2, x, 0, sides);
                   }
                 else
                   if(is_legal(ob1, 0, y, sides))
                   {
                   update_object(ob1, 0, y, sides);
                   update_object(ob2, 0, y, sides);
                   }
                 }
               }

          /* генерация движения спрайта компьютера, когда
             он убегает     */
          void not_it_comp_move(ob1, ob2, dx, dy, sides)
          int ob1[][4], ob2[][4];
          int dx, dy; /* направление последнего перемещения
                       "человека" */
          int sides;
               {
               register int x, y, d;
               static skip = 1;

               skip++;
               if (skip==3)
                 {
                 skip = 0;
                 return;
                 /* уменьшение времени реакции компьютера в 3 раза */
                 }
               x = 0;
               y = 0;
               /* перемещение в противоположном направлении */
               x = -dx;
               y = -dy;

               if (is_legal(ob1, x, y, sides))
                 {
                 updаte_object(ob1, x, y, sides);
                 updаte_object(ob2, x, y, sides);
                 }
               else
                 {
                 if (x && is_legal(ob1, x, 0, sides))
                   {
                   update_object(ob1, x, 0, sides);
                   update_object(ob2, x, 0, sides);
                   }
                 else if (is_legal(ob1, 0, y, sides)) {
                     update_object(ob1, 0, y, sides);
                     update_object(ob2, 0, y, sides);
                     }
                   }
                 }


          Эта  функция так же  как и предыдущая,  работает с 3-кратным
     замедлением.


          Программа контроля касания спрайтов.
          ------------------------------------

          В этой игре режимы спрайтов изменяются на  противоположные в
     том  случае,  если координаты  хотя  бы  одной  точки догоняющего
     спрайта совпадут с координатами любой точкой догоняемого. Правила
     игры могут быть  изменены  таким  образом,  что  изменение режима
     произойдет лишь  в случае  полного  совмещения  спрайтов.  Но эта
     довольно-таки сложная задача для многих игроков. Приведенная ниже
     функция tag()  возвращает значение 1, если спрайты столкнулись, и
     0 - в противном случае.

          /* Проверяет есть ли контакт между спрайтами */
          tag(ob1, ob2)
          int ob1[][4], ob2[][4];
               {
               register int i;
               /* для смены амплуа необходимо, чтобы спрайты
                  имели хотя бы одну общую точку растра */
               for (i= -1; i<2; i++)
                 if (ob1[0][0]==ob2[0][0]+i && ob1[0][1]==ob2[0][2]+i)
                   return 1;
               return 0;
               }

          Вы можете внести изменения в функцию tag() и установить свои
     правила контроля режимов спрайтов.


          Полный текст программы игры TAG.
          --------------------------------

          В данном  разделе приведен текст программы игры TAG, похожей
     на русские "салочки".  Вы можете ввести ее в свой компьютер, если
     он снабжен графическим адаптером.


       /* Пример мультипликации игры "салочки"

          Объектом в игре является "человек", который
          догоняет другого "человека".

          Ваш "человек"- зеленый,"человек" компьютера-
          желтый. Все, что окрашено в красный цвет,
          пересекать нельзя.

          Для смены ролей догоняющего и догоняемого
          необходимо, чтобы "люди" пересеклись
          хотя бы в одной точке растра  */

        #define COMPUTER 0
        #define HUMAN 1

        #define IDLE 0
        #define DOWN 1
        #define UP -1
        #define LEFT -1
        #define RIGHT 1

        #include "dos.h"
        #include "stdio.h"
        #include "math.h"
        #include "time.h"

        void mode(), line();
        void mempoint(), palette(), xhairs();
        void goto_xy(),show_score();
        void display_object(),update_object();
        void it_comp_move(),not_it_comp_move();
        void save_pic(), load_pic();
        unsigned char read_point();

        int human[4][4] = { /* ваш спрайт */
           1,6,6,6,
           4,2,3,9,
           9,1,6,6,
           9,11,6,6
         };

         int human2[4][4] = {

           1,6,6,6,
           4,2,3,9,
           9,3,6,6,
           9,9,6,6
          };

          int computer[4][4] = { /* спрайт компьютера */
            180,6,185,6,
            183,2,182,9,
            188,1,185,6,
            188,11,185,6
          };

          int computer2[4][4] = {
            180,6,185,6,
            183,2,182,9,
            188,3,185,6,
            188,9,185,6
          };

          int directx,directy; /* направление  */

          main()
          {
             union k {
                char c[2];
                int i;
             } key;

           int deltax=0,deltay=0;
           int swaph=0,swapc=0;
           int it=COMPUTER;
           long htime,ctime,starttime,curtime;
           int count;
           mode(4); /* установка 4 режима графики CGA/EGA */
           palette(0); /* палитра 0 */

           load_pic(); /* ввод игрового поля */

           time(&starttime); /* установка времени */
           htime=ctime=0;

           display_object(human,4,1);
           display_object(computer,4,3);
           count=0;

           /* главный цикл игры */
           do {
               /* вычисление текущего счета  */
              time(&curtime);
              if (it==COMPUTER) htime+=curtime-starttime;
              else ctime+=curtime-starttime;
              time(&starttime);
              show_score(it,htime,ctime);

              if (bioskey(1)) { /* если нажата клавиша */
                  directx=directy=IDLE; /* устанавливает
                               направление перемещения */
                  key.i = bioskey(0);
                  deltax=0;deltay=0;
                  if(!key.c[0]) switch(key.c[1]) {
                     case 75: /* влево */
                        deltay= -1;
                        directy=LEFT;
                        break;
                     case 77: /* вправо */
                        deltay=1;
                        directy=RIGHT;
                        break;
                     case 72: /* вверх */
                        deltax= -1;
                        directx=UP;
                         deltax= -1;
                        directx=UP;
                        break;
                     case 80: /* вниз */
                        deltax=1;
                        directx=DOWN;
                        break;
                     case 71: /* вверх и влево */
                        deltay= -1;
                        directy=LEFT;
                        deltax= -1;
                        directx=UP;
                        break;
                     case 73: /* вверх и вправо */
                        deltay=1;
                        directy=RIGHT;
                        deltax=-1;
                        directx=UP;
                        break;
                     case 79: /* вниз и влево */
                        deltay= -1;
                        directy=LEFT;
                        deltax=1;
                        directx=DOWN;
                        break;
                     case 81: /* вниз и вправо */
                        deltay=1;
                        directy=RIGHT;
                        deltax=1;
                        directx=DOWN;
                        break;
                    }
                 }
                 /* смена типа спрайта игрока  */
                 if (!swaph) displаy_object(human,4,1);
                 else displey_object(human2,4,1);
                 if (is_legal(human,deltax,deltay,4)) {
                    update_object(human,deltax,deltay,4);
                    update_object(human2,deltax,deltay,4);
                 }
                 /* проверяет: попался ли убегающий */
                 if (!count && tag(human,computer)) {
                    it=!it; /* смена амплуа */
                    count=6;
                 }
                 swaph= !swaph; /* смена фигур, имитирующих бег */
                 /* вывод "человека" в новой позиции */
                 if (!swaph) displаy_object(human,4,1);
                 else displаy_object(human2,4,1);

                 if (!swapc) displаy_object(computer,4,3);
                 else displаy_object(computer2,4,3);

                 /* генерация движения спрайта компютера */
                 if (it==COMPUTER)
                 it_comp_move(computer,computer2,human,4);
                 else
               not_it_comp_move(computer,computer2,directx,directy,4);
                 if (!count && tag(human,computer)) {
                    it= !it;
                    count=6;
               /* компьютер догоняет; изменение координаты Х на 2
                  так, чтобы быстрей стать догоняемым */
                     if(is_legal(computer, 2, 0, 4))
                     {
                        update_object(computer, 2, 0, 4);
                       update_object(computer2, 2, 0, 4);
                    }
                   else
                   {
                     update_object(computer, -2, 0, 4);
                     update_object(computer2, -2, 0, 4);
                   }
                }
                swapc = !swapc; /* заменить тип спрайта */
            /* вывод на экран спрайта компьютера */
                if(!swapc) display_object(computer, 4, 3);
                else       display_object(computer2, 4, 3);
                if(count) count--;
             }
             while (key.c[0] !='q' && htime<999 && ctime<999);
             getchar();
             mode(2);
             if(ctime>htime)
                printf("Компьютер выиграл!");
             else
                printf("Вы победили!");
           }

          /* Вывод на экран терминала счета */
          void shou_score(it, htime, ctime)
          int it;
          long htime, ctime;
            {
            goto_xy(24, 6);
            if(it==COMPUTER)
              printf("ВЫ:%ld", htime);
            else
              printf("вы:%ld", htime);
            goto_xy(24, 26);
            if(it==HUMAN)
              printf("Я:%ld", ctime);
            else
              printf("я:%ld", ctime);
            }

          /* Выбор палитры */
          void palette(pnum)
          int pnum;
            {
            union REGS r;

            r.h.bh = 1; /* код 4-го графического режима */
            r.h.bl = pnum;
            r.h.ah = 11;
            int86(0x10, &r, &r);
            }

          /* Выбор режима */
          void mode(mode_code)
          int mode_code;
            {
            union REGS r;

            r.h.al = mode_code;
            r.h.ah = 0;
            int86(0x10, &r, &r);
            }

      /* изображение линии заданного цвета с использованием
         алгоритма Брезенхама */
       void line(startx,starty,endx,endy,color)
       int startx,starty,endx,endy,color;
       {
         register int t,distance;
         int x=0,y=0,delta_x,delta_y;
         int incx,incy;

       /* вычисление расстояния в обоих направлениях         */
         delta_x=endx-startx;
         delta_y=endy-starty;

       /* определение  направления  шага,  шаг  вычисляется  либо   по
          вертикальной,  либо  горизонтальной  линии */
          if (delta_x>0) incx=1;
          else if (delta_x==0) incx=0; else incx=-1;

          if (delta_y>0) incy=1;
          else  if (delta_y==0) incy=0;
          else  incy=-1;

        /* определение какое расстояние больше */
          delta_x=abs(delta_x);
          delta_y=abs(delta_y);
          if (delta_x>delta_y) distance=delta_x;
          else distance=delta_y;

        /* изображение линии */
          for (t=0; t<=distance+1; t++) {
             mempoint(startx,starty,color);
             x+=delta_x;
             y+=delta_y;
             if (x>distance) {
                x-=distance;
                startx+=incx;
             }
             if (y>distance) {
                y-=distance;
                starty+=incy;
             }
          }
       }


        /* запись точки в CGA/EGA */

         void mempoint(x,y,color_code)
         int x,y,color_code;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=0xFF3F; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return;
            xor=color_code & 128; /* проверка, устанавливался ли
                                     режим "исключающего ИЛИ" */
            color_code=color_code & 127; /* маска старших битов */

            /*  установка битовой маски и битов режима цвета
                в правую позицию */

             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             color_code<<=2*(3-bit_position); /* сдвиг кода цвета
                                        в нужную позицию */
             bit_mask.i>>=2*bit_position; /* сдвиг битовой маски в
                                          нужную позицию */

             /* определение требуемого байта в памяти терминала */

              index=x*40+(y%4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */

               if (!xor) {  /* режим изменения цвета */
                  t=*(ptr+index) & bit_mask.c[0];
                  *(ptr+index)=t|color_code;
               }
               else {
                  t=*(ptr+index) | (char)0;
                  *(ptr+index)=t & color_code;
               }
            }

        /* чтение байта из оперативной памяти CGA/EGA */
         unsigned char read_point(x,y)
         int x,y;
         {
            union mask {
               char c[2];
               int i;
            } bit_mask;
            int i,index,bit_position;
            unsigned char t;
            char xor; /* "исключающее ИЛИ" цвета в случае его
                          изменения */
            char far *ptr=(char far *) 0xB8000000; /* точка в
                                                  памяти CGA */
            bit_mask.i=3; /* 11111111 00111111 в
                                  двоичном виде */
            if (x<0 || x>199 || y<0 || y>319) return 0;

            /*  установка битовой маски и битов режима цвета
                в правую позицию */
             bit_position=y%4; /* вычисление нужной позиции
                                  в байте */
             bit_mask.i<<=2*(3-bit_position);

             /* определение требуемого байта в памяти терминала */
              index=x*40+(y>>4);
              if (x%2) index+=8152; /* если нечетный, используется
                                       второй блок */

              /* запись цвета */
               t=*(ptr+index) & bit_mask.c[0];
               t>>=2*(3-bit_position);
               return t;
            }

       /* загрузка изображения */

           void load_pic()
           {
              char fname[80];
              FILE *fp;
              register int i,j;

              char far *ptr=(char far *) 0xB8000000; /* точка в
                                                     памяти   CGA  */
              char far *temp;
              unsigned char buf[14][80]; /* содержит образ экрана */

              temp=ptr;
         /* сохранение верхних строк текущего содержимого экрана */
              for (i=0;i<14;++i)
                 for (j=0;j<80;j+=2) {
                    buf[i][j]=*temp;
                    buf[i][j+1]=*(temp+8152);
                    *temp=0; *(temp+8152)=0;/*чистка позиций экрана*/
                    temp++;
                 }
              goto_xy(0,0);
              printf("Имя файла:");
              gets(fname);
              if (!(fp=fopen(fname,"rb"))) {
                 goto_xy(0,0);
                 printf("Файл не может быть открыт\n");
                 temp=ptr;
         /* восстановление содержимого экрана */
                 for (i=0;i<14;++i)
                    for (j=0;j<80;j+=2) {
                       *temp= buf[i][j];
                       *(temp+8125)=buf[i][j+1];
                       temp++;
                    }
                 return;
               }
        /* загрузка изображения из файла */
              for (i=0;i<8152;i++) {
                *ptr=getc(fp); /* четный байт */
                *(ptr+8125)=getc(fp); /* нечетный байт */
                ptr++;
              }

              fclose(fp);
           }

       /* поместить курсор в заданное положение */
           void goto_xy(x,y)
           int x,y;
           {
              r.h.ah=2; /* адресация курсора */
              r.h.dl=y; /* координата столбца */
              r.h.dh=x; /* координата строки */
              r.h.bh=0; /* видео-страница */
              int86(0x10,&r,&r);
            }

          /* отображение объекта на экране */

          void display_object(ob, sides,cc)
          double ob[][4];
          int sides,cc;
          {
            register int i;

            for(i=0; i<sides; i++)
              line((int)ob[i][0], (int)ob[i][1],
                   (int)ob[i][2], (int)ob[i][3], cc|128);
         }

          /* Смещение (параллельный перенос) объекта в направлении,
          определенном x и y
          */
          void update_object(ob, x, y, sides)
          int ob[][4];        /* объект */
          int x, y;           /* направление смещения */
          register int sides; /* количество сторон объекта */
            {
            sides--;
            for(; sides>=0; sides--)
              {
              ob[sides][0] += x;
              ob[sides][1] += y;
              ob[sides][2] += x;
              ob[sides][3] += y;
              }
            }

          /* Определение  допустимости перемещения объекта. Возвращает
          1, если перемещение допустимо, 0 - в противном случае */
          is_legal(ob, x, y, sides)
          int ob[][4];        /* объект */
          int x, y;           /* шаг перемещения */
          int sides;          /* число сторон объекта */
            {
            if(x==0 && y==0)
              return 1;       /* пустое перемещение всегда допустимо*/
            sides--;
            for(; sides>=0; sides--)
              {
              /* контроль выхода за допустимую область */
              if(ob[sides][0]+x>199 || ob[sides][1]+y>319)
                return 0;
              if(ob[sides][2]+x<0 || ob[sides][3]+y<0)
                return 0;
              if(read_point(ob[sides][0]+x, ob[sides][1]+y)==2)
                return 0;
              if(read_point(ob[sides][2]+x, ob[sides][3]+y)==2)
                return 0;
              }
            return 1;
            }

          /* генерация движения спрайта компьютера,  когда он догоняет
          */
            void it_comp_move(ob1,  ob2,  human, sides)
            int ob1[][4],ob2[][4], human[][4], sides;
               {
               register int x, y, d; /* d = direction */
               static skip = 0;
               skip++;
               if(skip==3)
                 {
                 skip=0;
                 return;
                 /* уменьшение времени реакции компютера */
                 }
               x = 0;
               y = 0;

        /* движение к игроку */
          if(human[0][0]<ob1[0][0])
                 x = -1;
               else
                 if(human[0][0]>ob1[0][0])
                   x = 1;
               if(human[0][1]<ob1[0][1])
                 y = -1;
               else
                 if(human[0][1]>ob1[0][1])
                   y = 1;

               if(is_legal(ob1, x, y, sides))
                 {
                 update_object(ob1, x, y, sides);
                 update_object(ob2, x, y, sides);
                 }
               else
                 {
                 if(x && is_legal(ob1, x, 0, sides))
                   {
                   update_object(ob1, x, 0, sides);
                   update_object(ob2, x, 0, sides);
                   }
                 else
                   if(is_legal(ob1, 0, y, sides))
                   {
                   update_object(ob1, 0, y, sides);
                   update_object(ob2, 0, y, sides);
                   }
                 }
               }

          /* генерация движения спрайта компьютера, когда
             он убегает     */
          void not_it_comp_move(ob1, ob2, dx, dy, sides)
          int ob1[][4], ob2[][4];
          int dx, dy; /* направление последнего перемещения
                       "человека" */
          int sides;
               {
               register int x, y, d;
               static skip = 1;

               skip++;
               if (skip==3)
                 {
                 skip = 0;
                 return;
                 /* уменьшение времени реакции компьютера в 3 раза */
                 }
               x = 0;
               y = 0;
               /* перемещение в противоположном направлении */
               x = -dx;
               y = -dy;

               if (is_legal(ob1, x, y, sides))
                 {
                 updаte_object(ob1, x, y, sides);
                 updаte_object(ob2, x, y, sides);
                 }
               else
                 {
                 if (x && is_legal(ob1, x, 0, sides))
                   {
                   updаte_object(ob1, x, 0, sides);
                   updаte_object(ob2, x, 0, sides);
                   }
                 else if (is_legal(ob1, 0, y, sides)) {
                     updаte_object(ob1, 0, y, sides);
                     updаte_object(ob2, 0, y, sides);
                     }
                   }
                 }

          /*  проверяет наличие контакта между спрайтами */
          tag(ob1, ob2)
          int ob1[][4], ob2[][4];
               {
               register int i;
               /* для смены амплуа необходимо, чтобы спрайты
                  имели хотя бы одну общую точку растра */
               for (i=-1; i<2; i++)
                 if (ob1[0][0]==ob2[0][0]+i && ob1[0][1]==ob2[0][2]+i)
                   return 1;
               return 0;
               }


          Для использования  игры вы должны создать одно или несколько
     игровых  полей,  используя  функции,   описанные   в   главе   4.
     Используйте  красный  цвет для изображения препятствий.  Желтый и
     зеленый цвета можно использовать для фона.  Эти  цвета  не  несут
     нагрузки,  поэтому могут использоваться в декоративных целях.  На
     рисунках 5-1 и 5-2 показаны два варианта игровых  полей  в  таком
     виде, в котором они отображаются на экране вашего терминала.

          Быстродействие компьютеров,  таких  моделей  как AT или PS/2
     моделей 50,  60 или 80,  вполне достаточно для данной игры.  Темп
     игры будет несколько снижен на обычном компьютере PC.  Однако вам
     уже известно, как может быть повышена динамичность игры.

     _________________________________________________________________

      Рис. 5-1 на стр. 205 имеющимися средствами воспроизведен быть не
      может. (Ред. пер. И.Бычковский.)
     _________________________________________________________________

     Рис. 5-1. Первое игровое поле видеоигры "салочки"


     _________________________________________________________________

      Рис. 5-2 на стр. 205 имеющимися средствами воспроизведен быть не
     может. (Ред. пер. И.Бычковский.)
     _________________________________________________________________

     Рис. 5-2. Второе игровое поле видеоигры "салочки"




               НЕКОТОРЫЕ СООБРАЖЕНИЯ ПО ВОЗМОЖНОЙ МОДИФИКАЦИИ
                                 ПРОГРАММЫ
     -----------------------------------------------------------------

          Возможно, вы со временем захотите  создать  свою  видеоигру,
     взяв,  однако,  за  основу  рассмотренную здесь игру TAG.  В этом
     случае в можете,  например,  изменить траекторию движения спрайта
     компьютера   заставив  его  двигаться  вокруг  какого-то  объекта
     ("охранять"  его).  Интересным  дополнением  к  программе   будет
     возможность изменять внешний вид каждого объекта-участника игры в
     зависимости от каких-либо условий. Кстати, решение этой задачи не
     требует  от вас каких-либо дополнительных усилий,  так как каждое
     изображение  спрайта  можно  хранить   в   видеопамяти,   а   все
     необходимые подпрограммы для работы с ней у вас уже есть.

          Другим,  также  представляющим  интерес  дополнением,  может
     стать   наделение    компьютера   возможностью   "прогнозировать"
     направление  движения  спрайта человека.  В  самом деле,  вы ведь
     знаете,  куда  можно двигаться,  а куда нельзя,  в зависимости от
     ситуации на экране дисплея.  Так научите это делать  и компьютер!
     Поскольку  игровое поле  статично,  то решение и  этой  задачи не
     будет представлять сложности.
          Попробуйте добавить  в программу  еще  один  спрайт, касание
     которого будет приносить дополнительные очки играющим.

          И, наконец,  последняя  мысль:  процесс   разработки   любой
     видеоигры  начинайте с создания ее простейшего "скелета".  И лишь
     после того,  как ваш "скелет"  "задышал",  начинайте  наращивание
     возможностей своей игры. Всегда стремитесь идти путем от простого
     к сложному.
