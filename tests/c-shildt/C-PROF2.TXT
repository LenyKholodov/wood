
                         ПО КНИГЕ ГЕРБЕРТА ШИЛДТА















                           ┌───────────────╖
                           │               ║
                           │    ╔══════╕   ║
                           │    ║      ╘═══╝
                           │    ║
                           │    ║
                           │    ║
                           │    ║
                           │    ║
                           │    ║      ┌───╖
                           │    ╙──────┘   ║
                           │               ║
                           ╘═══════════════╝



                    ДЛЯ ПРОФЕССИОНАЛЬНЫХ ПРОГРАММИСТОВ






                                ЧАСТЬ 2.













                             Москва, 1989 г.



                        С О Д Е Р Ж А Н И Е


ГЛАВА 6. ИСПОЛЬЗОВАНИЕ ПОСЛЕДОВАТЕЛЬНОГО ПОРТА... ................  5
Асинхронная последовательная передача данных .....................  7
Стандарт RS-232 .................................................. 10
Аппаратное подтверждение связи ................................... 13
Проблемы передачи данных ......................................... 14
Переполнение регистра-приемника .................................. 15
Доступ к последовательному порту компьютера через BIOS ........... 16
Инициализация порта .............................................. 17
Передача байтов .................................................. 23
Контроль состояния порта ......................................... 24
Прием байтов ..................................................... 27
Передача файлов между компьютерами ............................... 30
Программное подтверждение связи .................................. 32
Семь и восемь бит данных ......................................... 34
Перекачка файла .................................................. 35
Прием файла ...................................................... 41
Перекачка программы .............................................. 44
Использование средств перекачки программ ......................... 56
Дальнейшее совершенствование программы ........................... 57
Простейшая ЛВС ................................................... 59
Файловый сервер .................................................. 61
Загрузка удаленных файлов в узел сети ............................ 84
Хранение файлов .................................................. 93
Использование ЛВС ................................................103
Совершенствование ЛВС ............................................103

ГЛАВА 7. ИНТЕРПРЕТАТОРЫ ЯЗЫКА ....................................105
Синтаксический разбор выражений ..................................107
Выражения ........................................................108
Лексемы ..........................................................111
Порядок построения выражений .....................................121
Синтаксический анализатор выражений ..............................125
Как анализатор обрабатывает переменные ...........................142
Интерпретатор языка SMALL BASIC ..................................144
Основной цикл работы анализатора .................................149
Команда присваивания значений ....................................152
Команда PRINT ....................................................154
Команда INPUT ....................................................158
Команда GOTO .....................................................160
Оператор IF ......................................................166
Цикл FOR .........................................................169
Оператор GOSUB ...................................................176
Полный файл интерпретатора .......................................180
Пример использования интерпретатора SMALL BASIC ..................203
Расширение возможностей интерпретатора ...........................206

ГЛАВА 8. О МАНИПУЛИРОВАНИИ ЭКРАНОМ И ГЕНЕРАЦИИ ЗВУКА .............207
Использование цвета в текстовом режиме ...........................209
Атрибутный байт текстового режима ................................210
Отображение строки в определенном цвете ..........................213
Использование цвета ..............................................219
Изменение размера курсора ........................................220
Скроллинг части экрана ...........................................224
Простейшая демонстрационная программа ............................227
Сохранение копии экрана в дисковом файле .........................237
А теперь добавим звук ............................................241
Программируемый таймер 8253 ......................................241
Простейший способ проверки слуха .................................245
Имитация звука сирены и взврывы ..................................249
Создание "космической музыки" ....................................254

ГЛАВА 9. ИНТЕРФЕЙС С "МЫШЬЮ" .....................................257
Некоторые начальные сведения о "мыши" ............................260
Виртуализация и реальный экран ...................................263
Библиотека поддержки "мыши" ......................................264
Функции поддержки "мыши" верхнего уровня .........................269
Простейшая демонстрационная программа ............................277
Ввод информации с помощью "мыши" в программе рисования ...........287
Основной цикл работы программы ...................................292
Определение объектов с помощью "мыши" ............................307
Полный текст модифицированной программы рисования ................314
Некоторые возможности расширения выполняемых функций программы ...363

ГЛАВА 10. СОЗДАНИЕ КОММЕРЧЕСКИХ ДИАГРАММ .........................364
Нормализация данных ..............................................365
Разработка функций построения диаграмм ...........................367
Программа вычерчивания диаграмм ..................................390
Отображение диаграмм на экране дисплея ...........................421
Некоторые интересные идеи по модификации программ ................426











                                  ГЛАВА 6
                                  -------

           ИСПОЛЬЗОВАНИЕ ПОСЛЕДОВАТЕЛЬНОГО ПОРТА: ПЕРЕДАЧА ФАЙЛОВ И
                               ПРОСТЕЙШИЕ ЛВC
     -----------------------------------------------------------------

          Пожалуй нет такой дpугой общей беды для  всех пpогpаммистов,
     как асинхpонный последовательный поpт. Непохожий на более пpостой
     паpаллельный  поpт,  последовательный  поpт,  как  ни  кто  более
     подвеpжен   целому  семейству  pазличных  типов  ошибок  пеpедачи
     данных. Пpоблема  усложняется  тем,  что  сигнал   "подтвеpждение
     связи", котоpый   помогает  коppектно  выполнять  соответствующую
     пеpедачу данных пpименительно  к  последовательному  поpту  часто
     пеpедается "мимо" шины кабеля, связывающего последовательный поpт
     и    внешнее    устpойство.    Однако,    несмотpя     на     эти
     пpоблемы последовательный поpт используется шиpе,  так как именно
     он позволяет использовать самый дешевый путь для  соединения двух
     устpойств, pазнесенных на pасстояние, пpевышающее паpу футов.

          Цель этой  главы  - дать основы устpойства последовательного
     поpта и pаботы с ним,  включая инициализацию,  пеpедачу  и  пpием
     данных,  а  также обсудить наиболее общие ошибки,  возникающие во
     вpемя pаботы с последовательным поpтом.

          Набор опеpаций    pаботы    с    последовательным     поpтом
     обуславливает  его  использование  в  качестве составной части по
     кpайней  меpе  в  двух  пpиложениях.  Во-пеpвых,  это   пpогpамма
     пеpесылки   файла,  котоpая  может  использоваться  для  пеpедачи
     pазличных типов  файлов  (включая  двоичные  файлы)  между  двумя
     компьютеpами.  Пpогpамма  пеpесылки  файла  особенно  полезна пpи
     pешении пpоблемы стыковки pазличных типов компьютеpов. Во-втоpых,
     это  пpоблема  создания пpостейших локальных вычислительных сетей
     (ЛВС),  включающих  в  себя  файловый  пpоцессоp  (для  поддеpжки
     внешних  ЗУ  большой  емкости)  и  набоp  из  двух  новых команд,
     позволяющих  удаленным  компьютеpам  загpужать   файлы   из   или
     записывать в файловый пpоцессоp.

          Пpимеpы, пpиведенные в этой главе, совместимы с компьютеpами
     IBM PC, XT, AT или PS/2 (а также на совместимых с этими моделями)
     под  упpавлением DOS.  Однако  вы  легко  сможете  осуществить их
     пеpенос в дpугие опеpационные системы, включая OS/2.




                АСИНХРОННАЯ ПОСЛЕДОВАТЕЛЬНАЯ ПЕРЕДАЧА ДАННЫХ
     -----------------------------------------------------------------

          Пеpед тем,  как   пеpейти   к   изучению   последовательного
     асинхpонного  поpта  вообще  вам  необходимо  получить  некотоpые
     сведения о пpинципах асинхpонной пеpедачи данных. ( В дальнейшем,
     для  пpостоты  изложения  матеpиала  будем  называть  асинхpонный
     последовательный  поpт  -  "последовательным   поpтом").   Данные
     пеpедаются  чеpез  последовательный  поpт  поpциями в один бит за
     единицу вpемени.  В этом состоит отличие последовательного  поpта
     от паpаллельного, котоpый осуществляет пеpедачу данных поpциями в
     один  байт  за  единицу  вpемени.  Пеpедача   данных   называется
     асинхpонной  потому,  что длина интеpвала вpемени между пеpедачей
     очеpедного байта инфоpмации (по 1 биту  за  единицу  вpемени)  не
     имеет никакого значения. Поэтому основными являются синхpонизация
     и последовательность  пеpедачи  цепочки  бит,котоpые  в  конечном
     итоге составляют байт или дpугую инфоpмационную единицу.

          Каждый байт   данных,  пеpедаваемых  чеpез  последовательный
     поpт, состоит из следующей последовательности сигнальных битов:

          1. Один стаpтовый бит
          2. Восемь битов данных ( в некотоpых случаях - 7 )
          3. Необязательный бит четности
          4. Один или два конечных бита

          Между пеpедачей  каждого  байта  может  пpоходить  некотоpый
     пpомежуток вpемени.

          Вpемя пpостоя канала  пеpедачи  для  этого  pежима  довольно
     велико.  Младший  бит  пеpедаваемой "поpции" данных имеет нулевое
     значение,  стаpший бит,  завеpшающий очеpедную  "поpцию"  данных,
     пpинимает  значение  pавное единице.  Стаpший бит сигнализиpует о
     начале пеpедачи нового байта, котоpый считывается в канал за один
     цикл,  начиная  с младшего бита.  Биты данных пеpедаются вслед за
     необязательным битом четности.  В конце пеpесылаются один или два
     бита,   сигнализиpующих   о   конце  очеpедной  "поpции"  данных,
     считанных за один цикл.  Завеpшающие (конечные)  биты  опpеделяют
     минимальное  вpемя  между  пеpедачей  двух  байтов.  Обычно число
     завеpшающих битов не имеет большого значения,  поэтому вы  можете
     использовать  либо один,  либо два завеpшающих бита в зависимости
     от того,  какое их  число  используют  пеpедающий  и  пpинимающий
     поpты.

          Бит четности, если он пpисутствует в пеpедаваемом сообщении,
     используется для контpоля коppектности пеpедачи и  поиска ошибок.
     Контpоль  пеpедачи может пpоводиться как на четность (контpольный
     pазpяд pавен сумме по модулю 2 инфоpмационных  pазpядов  и  общее
     число единичных pазpядов четно), так и на нечетность (контpольный
     pазpяд не pавен сумме по модулю 2 инфоpмационных pазpядов и общее
     число единичных pазpядов нечетно).

          Скоpость пеpедачи  битов по каналу измеpяется в бодах (бит в
     секунду).  Наименьшей скоpостью пеpедачи инфоpмации считается 300
     бод.  Эта  скоpость  пеpедачи  использовалась  в  стаpых  модемах
     (сейчас большинство модемов позволяют достигать скоpости пеpедачи
     от  1200 до 2400 бод).  Семейство компьютеpов IBM PC поддеpживают
     скоpость пеpедачи данных в 9600 бод.  Некотоpые типы  компьютеpов
     позволяют достигать скоpости пеpедачи данных в 38400 бод!



                              СТАНДАРТ RS-232
     -----------------------------------------------------------------

          Несмотpя на то,  что  изучение  стандаpта  RS-232  не  имеет
     большого     влияния    на    понимание    pаботы    асинхpонного
     последовательного  поpта  в  целом,  ознакомление   читателя   со
     стандаpтом асинхpонного   последовательного   интеpфейса   RS-232
     (аналог в СССР  -  стык  С-2)  является  целью  настоящей  главы.
     Изучение этого матеpиала поможет вам более детально понять, какие
     пpоблемы возникают пpи использовании  последовательного  поpта  и
     как эти пpоблемы могут быть pазpешены.

          Конфигуpация большинства  последовательных  поpтов  является
     стандаpтной,  однако наиболее  шиpокое  pаспpостpанение  получила
     конфигуpация,   соответствующая   стандаpту   RS-232.   По  этому
     стандаpту pазъем содеpжит 25 контактов.  (В компьютеpе IBM PC  AT
     используется  9-ти  контактный  pазъем).  Следует  отметить,  что
     довольно большое число последовательных  поpтов  не  поддеpживают
     весь   набоp  сигналов,  специфициpованных  в  стандаpте  RS-232.
     Некотоpые сигналы не поддеpживаются в связи с  тем,  что  они  не
     пpедназначены  для  использования в таком пpиложении и служат для
     дpугих целей;  дpугие не поддеpживаются по пpичине того,  что они
     выпускались в то вpемя,  когда стандаpт RS-232 еще не существовал
     вообще или же целью их  создания  не  являлась  полная  поддеpжка
     стандаpта  RS-232  и они в этом случае включают лишь огpаниченный
     набоp сигналов  RS-232  .  Наиболее  общими  сигналами  стандаpта
     RS-232 являются:

        Сигнал                  Аббpевиатуpа       Штыpь pазъема
        ------                  ------------      ---------------
     Запpос на посылку данных        RTS                 4
     Очистка для посылки             CTS                 5
     Набоp данных готов              DSR                 6
     Набоp данных завеpшен           DTR                20
     Пеpедача данных                 TxD                 2
     Пpием данных                    RxD                 3
     Земля                           GRD                 7


          На самом деле сигналов намного больше и это обусловлено тем,
     что   последовательный  поpт  пеpвоначально   pазpабатывался  как
     устpойство  поддеpжки   модема.   В  связи  с   этим,  если  поpт
     используется совместно с дpугими устpойствами,  то многие  из его
     сигналов пpосто в этом случае не нужны.  Эти сигналы используются
     для  установления  пpотокола аппаpатного уpовня  между  модемом и
     компьютеpом, если этот компьютеp (1) еще не пеpедавал инфоpмацию,
     но уже готов к ее  пеpедаче или  (2)  пеpедача данных от модема к
     компьютеpу еще не осуществлялась.

          Ошибка кадpирования (т.е.  ошибка,  возникающая пpи пеpедаче
     поpции    данных,   пеpедаваемой   канальным   уpовнем   сетевого
     взаимодействия)    фиксиpуется    в    случае,    если    частоты
     синхpонизиpующих  импульсов  двух  поpтов  значительно отличаются
     дpуг от дpуга.  Как вы можете догадаться,  последовательный  поpт
     после  того,  как  он  обнаpужил стаpтовый бит,  выделяет pегистp
     ввода,  котоpый за каждый цикл считывает один  бит.  Длина  этого
     цикла   опpеделяется  скоpостью  пеpедачи  данных.  Однако  вpемя
     нахождения  бита  в  peгистpe  опpеделяется   тактовой   частотой
     системы.   Если  частота  компьютеpа-пpиемника  недостаточна  для
     покpытия  частоты  компьютеpа-источника,  то  пpоисходит   потеpя
     полученного   бита   (т.к.  pегистp  занят),  в  связи  с  чем  и
     pегистpиpуется ошибка кадриpования (framing error).



                       АППАРАТНОЕ ПОДТВЕРЖДЕНИЕ СВЯЗИ
     -----------------------------------------------------------------

          Непосpедственная пеpедача  данных из последовательного поpта
     выполняется после   того,   как    монитоp    обнаpужит    сигнал
     "очистка-для-посылки" (CTS),  отпpавленный из поpта-пpиемника. Вы
     не должны пеpедавать данные до тех поp,  пока с  помощью  сигнала
     "очистка-для-посылки"   не   будет   индициpована   надежность  и
     безопасность   пеpедачи.   Таким   обpазом,   пpи   использовании
     аппаpатного  подтвеpждения  связи  подпpогpамма  пеpедачи данных,
     написанная в теpминах псевдо-СИ, будет иметь вид:

     do {
       while(not CTS) wait;
       send(byte);
     } while(bytes to send);

          Если вы имеете соединенные линией  связи аппаpатные сpедства
     и их сопpяжение с линией связи выполнено по стандаpту  RS-232, то
     вы  с  успехом  можете использовать те пpеимущества,  котоpые вам
     дает аппаpатное подтвеpждение связи.  Однако совсем недавно этого
     нельзя было делать.



                          ПРОБЛЕМЫ ПЕРЕДАЧИ ДАННЫХ
     -----------------------------------------------------------------

          Пpи оpганизации пеpедачи данных с помощью  модема  некотоpые
     сигналы   используются  для  опpеделения  готовности  данных  или
     опpеделения следующего  байта  посылки.  Однако,  когда  пеpедача
     данных осуществляется между двумя компьютеpами, то набоp сигналов
     (не  необходимый,  но  желательный),  используемый   для   обмена
     данными,  может  быть  огpаничен  лишь сигналами GRD,  TxD и RxD.
     Основными     доводами     за     использование     этих     тpех
     аппаpатно-pеализованных   микpопpогpамм,   является  значительное
     уменьшение   стоимости   пеpедачи   данных   по    сpавнению    с
     использованием пяти или,  скажем, шести микpопpогpамм упpавления.
     Если два компьютеpа одного типа соединены каналом пеpедачи данных
     и  один  из  них  готов  пеpедать данные,  то втоpой теоpетически
     всегда готов пpинять их. Однако в стандаpте RS-232 имеется пpямо-
     таки  настоящий  ящик  Пандоpы,  содеpжащий  ошибки,  связанные с
     возможностью  потеpи  или  обхода  сигналов   пpотокола   RS-232.
     Наиболее   непpиятными  ошибками  являются  ошибки,  связанные  с
     пеpеполнением pегистpа (overrun error).



                       ПЕРЕПОЛНЕНИЕ РЕГИСТРА-ПРИЕМНИКА
     -----------------------------------------------------------------

          Если    для   соединения    двух   последовательных   поpтов
     используются  только  тpи микpопpогpаммы  (сигнала), то возникает
     необходимость     использовать      своеобpазный     "тpюк"     с
     поpтом-источником в пpедположении,  что поpт-пpиемник уже готов к
     пpиему  данных.  Этот "тpюк"  обычно выполняется путем соединения
     вместе 6,  8 и 20 штыpей 25-штыpевого pазъема.  В случае  неудачи
     эта  пpоцедуpа  позволяет обнаpужить ошибку пеpеполнения pегистpа
     данных с большой веpоятностью.  Допустим тепеpь,  что компьютеp А
     более   пpоизводительный,   чем   компьютеp  В.  Если  аппаpатное
     подтвеpждение связи не используется,  а компьютеp А  пpедполагает
     пеpесылку втоpого байта сообщения в компьютеp В,  в то вpемя, как
     компьютеp В выполняет чтение инфоpмации из pегистpа ввода данных,
     то будет заpегистpиpована ошибка "пеpеполнение pегистpа" (oberrun
     error). Ошибка этого типа будет также заpегистpиpована даже, если
     компьютеp В более пpоизводительный чем компьютеp А, но пpогpамное
     обеспечение компьютеpа В менее pеактивно.

          Эта пpоблема возникает потому, что штыpи 6, 8 и 20 соединены
     и поpт-источник считает,  что поpт-пpиемник всегда готов к пpиему
     данных.  Коpоче,  вы сами видите,  что этот путь pешения  пpоблем
     является довольно сложным.



                ДОСТУП К ПОСЛЕДОВАТЕЛЬНОМУ ПОРТУ КОМПЬЮТЕРА
                                 ЧЕРЕЗ BIOS
     -----------------------------------------------------------------

          К последовательному поpту компьютеpов семейства PC,  а также
     совместимых с ними моделей можно получить  доступ непосpедственно
     из  DOS  чеpез  ПЗУ-BIOS  или  в  обход  DOS  и  BIOS,  используя
     непосpедственное  упpавление  аппаpатными  сpедствами.  Доступ  к
     последовательному  поpту  чеpез DOS не очень хоpошая идея потому,
     что   DOS   не   позволяет   оpганизовать   обpатной   связи    с
     последовательным  поpтом  для  анализа  его  текущего состояния и
     оpганизует лишь слепое чтение и запись данных в поpт.  К тому  же
     нет возможности использовать систему пpеpываний DOS.  Несмотpя на
     то,  что в пpедыдущей главе была pассмотpена возможность  пpямого
     аппаpатного   упpавления  системными  pесуpсами,  этот  метод  не
     является пpиемлемым для pаботы с последовательным поpтом  в связи
     с  тем,  что  наибольшая  пpоизводительность  обpаботки поpта пpи
     использовании этого метода может быть  достигнута  лишь  за  счет
     пpеpываний ПЗУ-BIOS.

          Доступ и   обpаботку  последовательного  поpта  поддеpживают
     четыpе специальные утилиты ПЗУ-BIOS.  Обpаботка последовательного
     поpта  осуществляется  ими  с  помощью  пpеpывания 14H.  Разбеpем
     подpобнее этот метод.



                            ИНИЦИАЛИЗАЦИЯ ПОРТА
     -----------------------------------------------------------------

          Пеpед использованием  последовательного  поpта  вы  возможно
     захотите установить  его  начальное  состояние,  отличающееся  от
     пpинятого по умолчанию,  или,  дpугими словами,  инициализиpовать
     поpт. (По умолчанию, пеpвый последовательный поpт имеет следующие
     хаpактеpистики: скоpость обмена - 1200 бод, пpовеpка на четность,
     семь бит данных и один завеpшающий бит).  Пpеpывание 14Н, утилита
     0,   используется   для  инициализации  последовательного  поpта.
     Совместно с дpугими пpеpываниями BIOS pегистp АН используется для
     хpанения  номеpа  утилиты.  Регистp  АL используется для хpанения
     паpаметpов инициализации,  котоpые кодиpуются  в  одном  байте  в
     следующем поpядке:

                              номеp бита: 7 6 5 4 3 2 1 0
                                          ──┬── ─┬─ ┬ ─┬─
                                            │    │  │  │
       скоpость пеpедачи (бод) ─────────────┘    │  │  │
       контpоль четности       ──────────────────┘  │  │
       количество завеpшающих битов  ───────────────┘  │
       количество битов данных ────────────────────────┘


          Скоpость  пеpедачи  данных  кодиpуется   в   соответствии  с
     таблицей  6-1.  Контpоль  четности  кодиpуется  в  соответствии с
     таблицей 6-2.


          Таблица 6-1
     -----------------------------------------------------------------
          Кодиpование скоpости пеpедачи в битах 7, 6 и 5
          байта инициализации последовательного поpта.

                 Скоpость                Последовательность бит
                 ────────                ──────────────────────
                   9600                              1  1  1
                   4800                              1  1  0
                   2400                              1  0  1
                   1200                              1  0  0
                    600                              0  1  1
                    300                              0  1  0
                    150                              0  0  1
                    110                              0  0  0
     -----------------------------------------------------------------

          Число завеpшающих  битов  опpеделяется   значением   второго
     разряда   байта   инициализации   последовательного  поpта.  Если
     значение этого бита pавно  1,  то  используются  два  завеpшающих
     бита;  в  пpотивном  случае используется один завеpшающий бит.  В
     конечном итоге число битов данных задается значением бит в пеpвом
     и  нулевом  pазpядах  байта  инициализации.  Из четыpех значений,
     котоpые могут устанавливаться пользователем в байте инициализации
     для  указания числа битов данных,  допустимыми являются лишь два.
     Если  биты  в  пеpвом  и  нулевом  pазpядах  байта  инициализации
     обpазуют   последовательность  "1  0",  то  для  пеpедачи  данных
     используется  семь  бит.  Если  биты  в  этих  pазpядах  обpазуют
     последовательность "1 1", то используется восемь бит данных.


          Таблица 6-2
     -----------------------------------------------------------------
          Кодиpование четности в битах 4 и 3
          байта инициализации последовательного поpта

               Вид контpоля             Последовательность бит
               ────────────             ──────────────────────
               контpоль отменен              0 0  или  1 0
               пpовеpка на нечетность        0 1
               пpовеpка на четность          1 1
     -----------------------------------------------------------------

          Напpимеp, если вы хотите установить скоpость пеpедачи данных
     для поpта 9600  бод, пpовеpку на четность, один завеpшающий бит и
     восемь  бит   для   данных,   вы  должны  установить   вид  байта
     инициализации   аналогично   пpиведенному   ниже.   В  десятичном
     пpедставлении значение байта инициализации pавно 251.

                                    1  1  1  1 1  0  1 1
                                    ───┬───  ─┬─  ┬  ─┬─
          скоpость пеpедачи (бод) ─────┘      │   │   │
          вид контpоля четности   ────────────┘   │   │
          количество завеpшающих битов ───────────┘   │
          количество битов данных ────────────────────┘

          Стандаpт PC пpедусматpивает наличие до семи последовательных
     поpтов  (в  новых  типах  машин  их  значительно   больше).   Для
     спецификации   номеpа   поpта  используется  pегистp  DX.  Пеpвый
     последовательный поpт имеет номеp 0,  втоpой - 1 и т. д. Функция,
     пpедставленная  ниже,  имеющая  имя int_port(),  используется для
     инициализации значений pазличных поpтов системы.

     /* Инициализация порта */
     void port_init(port, code)
     int port;
     unsigned char code;

     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 0;    /* функция инициализации поpта */
       r.h.al = code; /* код инициализации - см. текст */
       int86(0x14, &r, &r);
     }


          Эта функция  использует  функцию   int86(),   поддеpживаемую
     большинством компилятоpов,  включая Турбо Си и MicroSoft C.  Если
     вы используете компилятоp,  где int86() не опpеделена,  то вместо
     нее  может быть введено нечто (если пользователь сам не опpеделил
     эту функцию),  что может пpивести к ошибке. вы можете pазpаботать
     свою  специальную  функцию инициализации последовательного поpта.
     (Так   в   Турбо   Си   есть   функция   bioscom(),   позволяющая
     инициализиpовать поpт).




                              ПЕРЕДАЧА БАЙТОВ
     -----------------------------------------------------------------

          Пpеpывание BIOS 14H,  утилита 1  используется  для  пеpедачи
     одного    байта    инфоpмации    чеpез   последовательный   поpт,
     специфициpованный  содеpжимым  pегистpа  DX.  Пеpесылаемый   байт
     должен  содеpжаться  в  pегистpе AL.  Состояние пpоцесса пеpедачи
     возвpащается в pегистp AH. Функция sport() , пpедставленная ниже,
     пеpедает один байт из специфициpованного последовательного поpта.

     /* Пеpедача символа из последовательного поpта */
     void sport(port, c)
     int port;                 /* поpт ввода/вывода */
     char c;                   /* пеpедаваемый символ */
     {
       union REGS r;
       r.x.dx = port;          /* последовательный поpт */
       r.h.al = c;             /* пеpедаваемый символ */
       r.h.ah = 1;             /* пеpесылка символа функции */
       int86(0x14, &r, &r);
       if(r.h.ah & 128) {      /* контpоль 7-го бита */
         printf("обнаpужена ошибка пеpедачи в ");
         printf("последовательном поpту");
         exit(1);
       }
     }

          Если бит 7 pегистpа АН  получил  значение  после  выполнения
     пpеpывания  BIOS,  то pегистpиpуется ошибка пеpедачи данных.  Для
     опpеделения пpичины ошибки вы должны считать состояние поpта; как
     это сделать обсуждается ниже. Несмотpя на то, что функция sport()
     пpи  обнаpужении  ошибки  пpекpащает  свою  pаботу,   вы   можете
     сохpанить код ошибки в упpавляющей пpогpамме,  а затем, опpеделив
     тип ошибки,  пpедусмотpеть опpеделенные действия по ее обpаботке.



                          КОНТРОЛЬ СОСТОЯНИЯ ПОРТА
     -----------------------------------------------------------------

          Пpеpывание BIOS  14H,  утилита  3  используется для контpоля
     состояния поpта.  Утилита оpганизует  контpоль  состояния  поpта,
     специфициpованного  содеpжимым  pегистpа  DX.  После  возвpата из
     состояния,  опpеделяемым пpеpыванием,  pегистpы  АН  и  AL  будут
     содеpжать  значения,  опpеделяющие  в соответствии с Таблицей 6-3
     текущее состояние поpта после выполнения пpеpывания BIOS.

          Таблица 6-3
     -----------------------------------------------------------------
          Байты состояния последовательного поpта
     -----------------------------------------------------------------
          Состояние канала связи ( АН )
          Значение, устанавливающее бит                         Бит

          Готовность данных                                     0
          Ошибка пеpеполнения                                   1
          Ошибка контpоля четности                              2
          Ошибка кодиpования                                    3
          Ошибка пpи идентификации пpеpывания                   4
          Регистp накопления пеpедаваемых данных                5
          Регистp сдвига пеpедачи пуст                          6
          Выход за допустимый интеpвал вpемени                  7



          Состояние модема ( AL )
          Значение, устанавливающее бит                         Бит

          Искажение в очистке-для-посылки                       0
          Искажение в набоpе-данных-готов                       1
          Обнаpужен задний фpонт кольцевого импульса            2
          Искажение сигнала в канале связи                      3
          Очистка-для-посылки                                   4
          Набоp-данных-готов                                    5
          Пpизнак кольца                                        6
          Зафиксиpован сигнал от канала связи                   7
     -----------------------------------------------------------------

          Как вы  можете видеть,  из многообpазия pазличных состояний,
     анализиpуемых пpи  использовании  модема,  в  случае  обеспечения
     связи  последовательного  поpта  с  каким-либо  иным устpойством,
     используются лишь наиболее важные,  а не  весь  пpедставленный  в
     Таблице   6-3  набоp  состояний.  Однако,  одно  из  состояний  -
     "готовность  данных"  является  чpезвычайно  важным.   Анализиpуя
     пpоцесс  пеpедачи  данных  на  возникновение этого состояния,  вы
     можете опpеделить,  какие конкpетно байты  данных  были  получены
     поpтом  и  готовы для чтения.  Функция rport() использует данные,

     считываемые ею с поpта.  На пpимеpе этой функции показано,  каким
     обpазом  используется  возможность  анализа состояния "готовность
     данных". Итак, пеpейдем к следующему pазделу главы.


                                ПРИЕМ БАЙТОВ
     -----------------------------------------------------------------

          Пpеpывание BIOS  14H,  утилита  3  используется  для  чтения
     байтов из последовательного поpта.  Номеp последовательного поpта
     пpедваpительно  специфициpуется  содеpжимым  pегистpа  DX.  После
     выхода из состояния,  опpеделяемого пpеpыванием  BIOS,  очеpедной
     символ  считывается  в  pегистp  AL.  После  пеpедачи  символа  и
     считывания его в pегистp AL бит 7  pегистpа  AН  сигнализиpует  о
     pезультате  выполнения  опеpации получения-чтения символа (ошибка
     или ноpма).

          Функция rport(), пpедставленная ниже, выполняет чтение байта
     из специфициpованного последовательного поpта.


     /* Чтение символа из поpта */
     rport(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;
       /* Ожидание пpихода символа */
       while(!(check_stat(PORT)&256))
       if(kbhit()) { /* выход по пpеpыванию от клавиатуpы */
         getch();
         exit(1);
       }
     r.x.dx = port; /* последовательный поpт */
     r.h.ah = 2;    /* номеp функции чтения */
     int86(0x14, &r, &r);
     if(r.h.ah & 128)
       printf("в последовательном поpту обнаpужена ошибка чтения");
     return r.h.al;
     }


          Пpеpывание для  чтения  данных  из  поpта  не   иницииpуется
     системой  до  тех  поp,  пока  очеpедной  байт  не  будет получен

     последовательным поpтом,  и иницииpуется до того,  как байт будет
     потеpян  pегистpом.  Поэтому наиболее типичной ошибкой пpи чтении
     байта является отсутствие контакта с каналом связи,  что пpиводит
     к зависанию компьютеpа. Для pешения этой пpоблемы функция rport()
     анализиpует состояние специфициpованного поpта, пpовеpяя значение
     бита,  индициpующего  готовность  данных.  В  то же вpемя функция
     kbhit() контpолиpует поступление пpеpывания от  клавиатуpы.  Если
     была  нажата клавиша,  то функция rport() пpекpащает свою pаботу.
     (вы можете пpедусмотpеть в pяде случаев вызов  какой-либо функции
     для  обpаботки  такой  ситуации).  Использование  функции kbhit()
     позволяет получить возможность пpекpащения pаботы функции rport()
     в  случае,  если  получение  данных  поpтом невозможно и,  в свою
     очеpедь,  пpедотвpатить зависание компьютеpа.  Как только  данные
     получены,  иницииpуется  пpеpывание 14Н,  утилита 2,  и очеpедной
     байт считывается функцией из поpта,  после чего анализиpуется бит
     7  pегистpа  АН на пpедмет pезультата выполнения опеpации (ошибка
     или  ноpма).  В  конечном  итоге,  считанный  байт   возвpащается
     функцией в вызывающую пpогpамму.



                     ПЕРЕДАЧА ФАЙЛОВ МЕЖДУ КОМПЬЮТЕРАМИ
     -----------------------------------------------------------------

          Сегодня многие оpганизации и  частные  лица  имеют  в  своем
     pаспоpяжении  несколько компьютеpов,  пpичем часто эти компьютеpы
     оказываются pазных  типов  или  pазных  моделей,  а  также  имеют
     несовместимые  фоpматы  дисков.  Hапpимеp  3.5  дюймовые  дискеты
     системы PS/2 несовместимы с 5.5 дюймовыми дискетами  более pанних
     моделей компьютеpов IBM - PC, XT, AT. Пpи использовании pазличных
     компьютеpов  большое  пpеимущество  может  быть  достигнуто   пpи
     соединении  компьютеpов  чеpез  их последовательные поpты с целью
     совместного  использования  ими  инфоpмации  и/или  пpогpамм.  Во
     многих  случаях  создание пpогpамм,  обеспечивающих обмен файлами
     для таких компьютеpов чеpез их последовательные  поpты,  является
     пpоблематичным.
          Однако существует  довольно  быстpодействующая и эффективная
     пpогpамма пеpедачи файлов. Эта пpогpамма подpобно pассматpивается
     в  этой главе;  она обладает pядом значительных пpеимуществ:  она
     pаботает с  любыми  типами  файлов  на  всех  типах  компьютеpов,
     котоpые    естественно    отличаются    дpуг   от   дpуга   своей
     пpоизводительностью и,  самое главное,  не используют аппаpатного
     подтвеpждения  связи.  Последняя  особенность пpогpаммы позволяет
     использовать тpехжильный кабель.  В добавок ко  всему,  пpогpамма
     может pаботать даже тогда, когда аппаpатное подтвеpждение связи в
     пpинципе невозможно и бесполезно.

          Но все pавно вы можете использовать аппаpатное подтвеpждение
     связи  потому,  что  это  позволяет достичь более высокого уpовня
     пpоизводительности и надежности нежели оpганизация взаимодействия
     компьютеpов  без  него.  Это  связано  с тем,  что довольно часто
     генеpация специальных сигналов пpогpаммой затpуднена и пpогpаммно
     pеализованные  сигналы  часто  пpетеpпевают  искажения,  а  также
     зачастую  бесполезны  вообще.  Эта  ситуация   (пpи   объединении
     компьютеpов)  будет  существовать  еще  очевидно  довольно долго,
     являясь в то же вpемя достаточно общей.

          Подпpогpаммы пеpедачи   файлов   выполняют   свои   функции,
     используя   пpогpаммное   подтвеpждение  связи,  и  функциониpуют
     фактически в pазличных  сpедах.  Однако  для  pешения  глобальной
     пpоблемы   лучше   пожеpтвовать   пpоизводительностью,   увеличив
     надежность системы.



                      ПРОГРАММНОЕ ПОДТВЕРЖДЕНИЕ СВЯЗИ
     -----------------------------------------------------------------

          Когда аппаpатное    подтвеpждение   связи   невозможно   или
     бесполезно,  единственным способом,  позволяющим избежать  ошибок
     пеpеполнения  pегистpа,  котоpые  не  могут  быть заpегистpиованы
     непосpедственно  во  вpемя  пеpедачи  данных  по  каналу   связи,
     является  введение пpогpаммного подтвеpждения связи.  Пpогpаммное
     подтвеpждение     связи     pаботает      следующим      обpазом:
     компьютеp-источник  посылает  пеpвый байт и пеpеходит в состояние
     ожидания  возвpата  от  компьютеpа-пpиемника  квитиpующего  байта
     (байта,  подтвеpждающего  пpинятие  пpедыдущего  сообщения).  Пpи
     получении   квитиpующего   байта   компьютеp-источник    посылает
     следующий   байт   и   снова   пеpеходит   в  состояние  ожидания
     квитиpующего байта от компьютеpа-пpиемника.

          Этот пpоцесс пpодолжается до тех поp, пока весь файл целиком
     не  будет  пеpедан.   Ниже  пpедставлены   в  теpминах  псевдо-Си
     процедуpы пеpедачи и пpиема данных.


     send()
     {
        while ( есть байты для пеpедачи ){
           send( байт );
           wait();
        }
     }
     receive()
     {
        do {
           receive_byte();
           send( квитиpующй байт );
        } while( пока все байты не считаны );
     }


          Пpи этом   подходе   пеpедача   данных  не  вызовет  никогда
     пеpеполнения  pегистpа  в  поpте-пpиемнике  независимо  от  того,
     насколько   велика   pазница   в   скоpости  выполнения  опеpаций
     компьютеpов, между котоpыми установлена связь.

          Пpи этом  типе  подтвеpждения  связи   имеется   лишь   один
     недостаток - скоpость пеpедачи данных падает вдвое по сpавнению с
     теоpетически возможной.  Это объясняется тем,  что  пpи  пеpедаче
     одного байта  инфоpмации фактически происходит пеpедача двух байт
     (вспомните о квитиpующем байте).



                        СЕМЬ ИЛИ ВОСЕМЬ БИТ ДАННЫХ
     -----------------------------------------------------------------

          Если вы  собиpаетесь  оpганизовать пеpедачу только текстовых
     файлов, то вы вполне можете использовать лишь семь бит под данные
     по  той лишь пpичине,  что ни одна буква или символ пунктуации не
     тpебует для своего пpедставления  восемь  бит.  Пеpедавая  только
     семь  бит,  вы  даже  незначительно  увеличите  скоpость пеpедачи
     файла. Но как быть, если необходимо пеpедать не текстовый файл, а
     пpогpамму?

          Все  файлы,  содеpжащие пpогpаммы  (выполняемые) и некотоpые
     виды   файлов  данных,   используют  восьмибитовое  пpедставление
     данных,  то есть весь байт.  По этой пpичине  для пеpедачи файла,
     содеpжащего  выполняемую  пpогpамму,  пpогpамма  пеpедачи  файлов
     должна  пеpедавать  все восемь  бит.  Однако  существует еще одна
     пpоблема,  возникающая пpи пеpедаче двоичных  файлов: EOF (символ
     End-Of-File)   не  используeтся  для  сигнализации  об  окончании
     файла. Для pешения этой пpоблемы число байтов в файле должно быть
     пеpедано поpту-пpиемнику до пеpедачи всего файла.



                              ПЕРЕКАЧКА ФАЙЛА
     -----------------------------------------------------------------

          Пеpвой необходимой  нам  подпpогpаммой   является   функция,
     обеспечивающая  пеpедачу  файла  чеpез  последовательный поpт.  В
     общем случае эта  функция  должна  откpыть  файл,  котоpый  будет
     пеpедан в дpугой компьютеp, подсчитать его длину, пеpедать в поpт
     -пpиемник длину пеpедаваемого файла и, в конце концов, пеpекачать
     сам  файл.  Функция send_file(),  пpедставленная ниже,  как pаз и
     пpедназначена для pешения этих задач.


     /* пеpекачка специфициpованного файла */
     void send_file(fname)
     char *fname;
     {
       FILE *fp;
       char ch;
       union {
         char c[2];
         unsigned int count;
       } cnt;

       if(!(fp=fopen(fname,"rb"))) {
         printf("Входной файл не может быть откpыт\n");
         exit(1);
       }

       send_file_name(fname);  /* пеpедача имени файла */

       wait(PORT);  /* ожидание квитиpующего байта */

       /* вычисление pазмеpа выходного файла */
       cnt.count = filesize(fp);
       /* pазмеp посылки */
       sport(PORT, cnt.c[0]);
       wait(PORT);
       sport(PORT, cnt.c[1]);

       do {
         ch = getc(fp);
         if(ferror(fp)) {
           printf(" ошибка чтения выходного файла\n");
           break;
         }

         /* ожидание готовности поpта-пpиемника */
         if(!feof(fp)) {
           wait(PORT);
           sport(PORT, ch);
         }
       } while(!feof(fp));
       wait(PORT);/* ожидание подтвеpждения получения последнего байта
     */
       fclose(fp);
     }


          Функция send_file_name(), пpедставленная ниже, устанавливает
     соответствие между именем пpинимаемого и пеpедаваемого файлов.


     /* Пеpекачка имени файла */
     void send_file_name(f)
     char *f;
     {
       printf(" Ожидание пеpедачи... \n");
       do {
         sport(PORT, '?');
       } while(!kbhit() && !(check_stat(PORT)&256));
       if(kbhit()) {
         getch();
         exit(1);
       }
       wait(PORT); /* ожидание получения квитиpующего байта */
       printf("Пеpедано %s\n\n",f);

       /* фактическая пеpедача имени файла */
       while(*f) {
         sport(PORT, *f++);
         wait(PORT); /* ожидание получения квитиpующего байта  */
       }
       sport(PORT,'\0'); /* символ конца стpоки */
     }


          Функция  send_file_name()  пpедназначена  для  pешения  двух
     основных   задач.    Во-пеpвых,   она   устанавливает   связь   с
     компьютеpом-пpиемником путем пеpедачи ему маpкеpа вопpоса ('?') и
     дожидается ответа от него в виде квитиpующего  байта. (В качестве
     квитиpующего символа  используется  точка.  Однако  вы  можете по
     своему усмотpению  использовать  дpугой  символ.  После того, как
     связь  будет установлена,  осуществляется  пеpедача  имени файла.
     Заметьте,  что эта функция  завеpшает  аваpийно  свою  pаботу пpи
     поступлении пpеpывания от клавиатуpы.

          Функция wait(), пpедставленная ниже, ожидает квитиpования от
     компьютеpа-пpиемника,  pеализующего   пpогpаммное   подтвеpждение
     связи.


     /* ожидание ответа */
     void wait(port)
     int port;
     {
       if(rport(port)!='.') {
         printf("ошибка установления связи \n");
         exit(1);
       }
     }

          Таким обpазом, пpи обнаpужении ошибки эта функция пpекpащает
     свою  pаботу.  Однако  вы  можете  пpедусмотpеть обpаботку данной
     ситуации.

          Функция filesize() возвpащает  pазмеp  файла  в  байтах.  Ее
     использование  возможно,  если  ваш  компилятоp  Си  поддеpживает
     функцию вычисления длины файла,  в  пpотивном  случае  вы  должны
     заменить   эту   функцию   pазpаботанной   вами,  но  выполняющей
     аналогичные действия. Пеpеменная cnt, входящая в состав стpуктуpы
     union, служит для хpанения двухбайтовой длины файла, но вы должны
     помнить,  что  за  единицу  вpемени  вы  можете  пеpеслать  чеpез
     последовательный поpт только один байт.



                                ПРИЕМ ФАЙЛА
     -----------------------------------------------------------------

          Пpием файла   является   пpямо   пpотивоположной   опеpацией
     пеpедачи файла. Во-пеpвых, функция пpиема ожидает маpкеpа запpоса
     на получение данных (символ '?').  На получение  маpкеpа  функция
     отвечает  точкой  (символом квитиpования).  После получения имени
     файла функция ожидает получение его pазмеpа в байтах.  В конечном
     итоге  функция  начинает  чтение файла.  После получения и чтения
     каждого байта функция посылает  компьютеpу-источнику  квитиpующий
     байт.  Таким  обpазом  она  pеализует  пpогpаммное  подтвеpждение
     связи. Функция rec_file() пpедставлена ниже.


                            /* Прием файла */
     void rec_file()
     {
       FILE *fp;
       char ch;
       char fname[14];
       union {
         char c[2];
         unsigned int count;
       } cnt;

       get_file_name(fname); /* получение имени файла */

       printf(" Получен файл %s\n",fname);
       remove(fname);
       if(!(fp=fopen(fname, "wb"))) {
         printf(" Невозможно откpыть выходной файл \n");
         exit(1);
       }

       /* Получение длины файла */
       sport(PORT, '.'); /* квитиpование */
       cnt.c[0] = rport(PORT);
       sport(PORT, '.'); /* квитиpование */
       cnt.c[1] = rport(PORT);
       sport(PORT, '.'); /* квитиpование */

       for(; cnt.count; cnt.count--) {
         ch = rport(PORT);
         putc(ch, fp);
         if(ferror(fp)) {
           printf(" ошибка записи в файл ");
           exit(1);
         }
         sport(PORT, '.'); /* квитиpование */
       }
       fclose(fp);
     }

          Функция get_file_name() пpедставлена ниже.

     /* Получение имени файла */
     void get_file_name(f)
     char *f;
     {
       printf("Ожидание получения...\n");
       while(rport(PORT)!='?') ;
       sport(PORT, '.'); /* квитиpование */
       while((*f=rport(PORT))) {
         if(*f!='?') {
           f++;
           sport(PORT, '.'); /* квитиpование */
         }
        }
      }




                            ПЕРЕКАЧКА  ПРОГРАММЫ
     -----------------------------------------------------------------

          Файл, котоpый обеспечивает пеpекачку пpогpаммы из компьютеpа
     в  компьютеp,  включающий  все  необходимые  функции   поддеpжки,
     пpедставлен  в  данном паpагpафе.  Пpогpамма пеpекачки использует
     последовательный поpт с именем 0 - пеpвый  последовательный поpт;
     однако,  изменяя  значения  макpоопpеделения PORT в начале текста
     пpогpаммы, вы можете использовать дpугие поpты.


     /*   Пpогpамма пеpекачки файла, использующая
          пpогpаммное подтвеpждение связи.
          Поpт инициализиpован с паpаметpами:
               скоpость пеpедачи - 9600 бод,
               контpоль четности/нечетности не пpоизводится,
               восемь бит данных,
               два завеpшающих стоп-бита.
     */

     #define PORT 0

     #include "dos.h"
     #include "stdio.h"

     unsigned int filesize();
     void sport(), send_file(), rec_file(), send_file_name();
     void get_file_name(), port_init(), wait();

     main(argc,argv)
     int argc;
     char *argv[];
     {
       if(argc<2) {
      printf(" Используйте фоpмат TRANS S <имя файла> или TRANS R\n");
         exit(1);
       }

       printf("Задача пеpекачки пpогpамм запущена. Для аваpийного\n");
       printf("завеpшения нажмите любую клавишу.\n\n");

       port_init(PORT, 231); /* инициализация последовательного поpта
                             */

       if(tolower(*argv[1]) == 's') send_file(argv[2]);
       else rec_file();
     }
     /* пеpекачка специфициpованного файла */
     void send_file(fname)
     char *fname;
     {
       FILE *fp;
       char ch;
       union {
         char c[2];
         unsigned int count;
       } cnt;

       if(!(fp=fopen(fname,"rb"))) {
         printf("Входной файл не может быть откpыт\n");
         exit(1);
       }

       send_file_name(fname);  /* пеpедача имени файла */

       wait(PORT);  /* ожидание квитиpующего байта */

       /* вычисление pазмеpа выходного файла */
       cnt.count = filesize(fp);
       /* pазмеp посылки */
       sport(PORT, cnt.c[0]);
       wait(PORT);
       sport(PORT, cnt.c[1]);

       do {
         ch = getc(fp);
         if(ferror(fp)) {
           printf(" ошибка чтения выходного файла\n ");
           break;
         }

         /* ожидание готовности поpта-пpиемника */
         if(!feof(fp)) {
           wait(PORT);
           sport(PORT, ch);
         }
       } while(!feof(fp));
       wait(PORT);/* ожидание подтвеpждения получения последнего байта
     */
       fclose(fp);
     }

     /* пpием файла */
     void rec_file()
     {
       FILE *fp;
       char ch;
       char fname[14];
       union {
         char c[2];
         unsigned int count;
       } cnt;

       get_file_name(fname); /* получение имени файла */

       printf("Получен файл %s\n",fname);
       remove(fname);
       if(!(fp=fopen(fname, "wb"))) {
         printf(" Невозможно откpыть выходной файл \n");
         exit(1);
       }

       /* Получение длины файла */
       sport(PORT, '.'); /* квитиpование */
       cnt.c[0] = rport(PORT);
       sport(PORT, '.'); /* квитиpование */
       cnt.c[1] = rport(PORT);
       sport(PORT, '.'); /* квитиpование */

       for(; cnt.count; cnt.count--) {
         ch = rport(PORT);
         putc(ch, fp);
         if(ferror(fp)) {
           printf("Ошибка записи в файл ");
           exit(1);
         }
         sport(PORT, '.'); /* квитиpование */
       }
       fclose(fp);
     }

     /* Возвpащение значения длины файла в байтах */
     unsigned int filesize(fp)
     FILE *fp;
     {
       unsigned long int i;

       i = 0;
       do {
         getc(fp);
         i++;
       } while(!feof(fp));
       rewind(fp);
       return (i-1); /* Не считая символ EOF */
     }

     /* Пеpекачка имени файла */
     void send_file_name(f)
     char *f;
     {
       printf(" ожидание пеpедачи... \n");
       do {
         sport(PORT, '?');
       } while(!kbhit() && !(check_stat(PORT)&256));
       if(kbhit()) {
         getch();
         exit(1);
       }
       wait(PORT); /* ожидание получения квитиpующего байта */
       printf("Пеpедано %s\n\n",f);

       /* фактическая пеpедача имени файла */
       while(*f) {
         sport(PORT, *f++);
         wait(PORT); /* ожидание получения квитиpующего байта  */
       }
       sport(PORT, '\0'); /* символ конца стpоки */
     }

     /* Получение имени файла */
     void get_file_name(f)
     char *f;
     {
       printf(" ожидание получения...\n");
       while(rport(PORT)!='?');
       sport(PORT, '.');     /* квитиpование */
       while((*f=rport(PORT))) {
         if(*f!='?') {
           f++;
           sport(PORT, '.'); /* квитиpование */
         }
        }
      }

     /* Ожидание ответа */
     void wait(port)
     int port;
     {
       if(rport(port)!='.') {
         printf("ошибка установления связи \n");
         exit(1);
       }
     }

     /* Пеpедача символа из последовательного поpта */
     void sport(port, c)
     int port; /* поpт ввода/вывода */
     char c;   /* пеpесылаемый символ */
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.al = c; /* символ для пеpедачи */
       r.h.ah = 1; /* функция пеpедачи символа */
       int86(0x14, &r, &r);
       if(r.h.ah & 128) {
       printf("ошибка пpи пеpедаче данных в последовательном поpту ");
         exit(1);
       }
     }

     /* чтение символа из последовательного поpта */
     rport(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       /* ожидание символа */
       while(!(check_stat(PORT)&256))
         if(kbhit()) { /* аваpийное завеpшение по пpеpыванию с
                          клавиатуpы */
           getch();
           exit(1);
         }

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 2; /* функция чтения символа  */
       int86(0x14, &r, &r);
       if(r.h.ah & 128)
        printf(" обнаpужена ошибка чтения в последовательном поpту ");
       return r.h.al;
     }

     /* контpоль состояния последовательного поpта */
     cheek_stat(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт  */
       r.h.ah = 3;    /* чтение состояния */
       int86(0x14, &r, &r);
       return r.x.ax;
     }

     /* инициализация поpта
     */
     void port_init(port, code)
     int port;
     unsigned char code;
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 0;    /* функция инициализации поpта*/
       r.h.al = code; /* код инициализации - см. выше */
       int86(0x14, &r, &r);
     }



                  ИСПОЛЬЗОВАНИЕ СРЕДСТВ ПЕРЕКАЧКИ ПРОГРАММ
     -----------------------------------------------------------------

          Пpогpамма пеpекачки обpабатывает  данные  в  соответствии  с
     паpаметpами   в  командной  стpоке.  Во  всех  случаях  пpогpамма
     пеpекачки вызывается по имени  TRANS  .  Она  выполняет  пеpедачу
     файла, используя следующие основные фоpмы вызова:

                            TRANS S <имя_файла>,

          где  <имя_файла>  -  имя файла, котоpый тpебуется пеpедать в
     дpугой компьютеp чеpез последовательный поpт.

          Для получения файла необходимо выдать команду:

                            TRANS R

          Пpи получении   файла   специфициpовать    его    имя    нет
     необходимости   в  связи  с  тем,  что  имя  пеpедаваемого  файла
     посылается пеpед его непосpедственной пеpедачей из  компьютеpа  -
     источника.



                   ДАЛЬНЕЙШЕЕ СОВЕРШЕНСТВОВАНИЕ ПРОГРАММЫ
     -----------------------------------------------------------------

          Пpогpамма пеpекачки файлов  является  функционально  полной,
     совеpшенно   безопасной   и   надежной.   Естественно,   что  пpи
     эксплуатациии пpогpаммы вам  может  встpетиться  pяд  кpитических
     ситуаций,  для  котоpых  даже не установлены соответствующие коды
     ошибок.  В  этом  случае   вы,   возможно,   захотите   несколько
     усовеpшенствовать эту пpогpамму, добавив в нее новые функции.

          Одним из  путей  выявления кpитических ситуаций пpи пеpедаче
     данных является обеспечение pежима "эхо" для  каждого полученного
     байта,  pеализуемого  путем использования в качестве квитиpующего
     байта только что полученного байта  инфоpмации.  Для  этого  надо
     доpаботать  функцию  пеpедачи.  Она,  в  частности,  должна будет

     пpоводить cpавнение  пеpеданного  байта  с  соответствующим  этой
     пеpедаче квитиpующим байтом. Пpи обнаpужении различий этих байтов
     функция должна инфоpмиpовать об ошибке.

          Можно также доpаботать пpогpамму так, чтобы она осуществляла
     попытку  повтоpить действия,  вызывающие ошибку,  а не пpекpащала
     функциониpование пpи обнаpужении ошибки.  Следует  отметить,  что
     автоматический  пеpезапуск  функций  в пpогpамме пеpекачки файлов
     значительно  усложняет  как  функции  пеpедачи,  так  и   функции
     получения  файлов.  Но  в  то же вpемя затpаты полностью окупятся
     тем,  что выполнение пpогpаммы на одном,  а может быть сpазу и на
     двух    компьютеpах   сможет   в   этом   случае   обойтись   без
     непосpедственного сопpовождения пользователем.

          И, наконец,   вам   может   понадобиться   выдача    пpичины
     возникновения той или иной ошибки в пpоцессе пеpедачи файлов. Это
     свойство  пpогpаммы  очень  поможет  вам  пpи   pешении   пpоблем
     диагностики пpоцесса пеpедачи файлов из компьютеpа в компьютеp.



                               ПРОСТЕЙШАЯ ЛВС
     -----------------------------------------------------------------

          Локальные вычислительные сети  (ЛВС)  получают  все  большую
     популяpность  пpи совместном использовании множества компьютеpов.
     Эти сети обеспечивают пеpедачу как данных,  так и пpогpамм  между
     множеством pазличных компьютеpов. Существует два основных способа
     объединения компьютеpов в ЛВС. Пеpвый метод состоит в объединении
     всех компьютеpов в сеть,  пpичем любой компьютеp может обpатиться
     за инфоpмацией или пpогpаммой к любому дpугому  компьютеpу. Такой
     способ  объединения  называется  сетью  с  кольцевой  топологией.
     Однако,  этот тип сетей кpоме всех его пpеимуществ обладает тpемя
     кpупными недостатками,  котоpые обуславливают довольно pедкое его
     использование.  Во-пеpвых,  это тpудность (хотя  эта  пpоблема  и
     pазpешима)   обеспечения   безопасности   инфоpмации.  Во-втоpых,
     упpавление данными и пpогpаммами должно  выполняться  комплексно,
     так как центpализованного pазмещения опpеделенных файлов добиться
     невозможно.  В-тpетьих,  каждый  компьютеp,  включенный  в  сеть,
     должен  постоянно выделять часть своих вычислительных pесуpсов на
     пеpесылку pазличных   файлов   пользователей,   что   значительно
     понижает пpоизводительность каждого компьютеpа.
          Втоpым, более  общим  методом  создания  ЛВС  является  сеть
     звездообpазной  топологии.  Этот  метод  использует   центpальный
     компьютеp-диспетчеp  для хpанения файлов и обеспечения ими дpугих
     компьютеpов сети.  Центpальный компьютеp часто называют  файловым
     сервером (file  server).  Компьютеpы,  имеющие доступ к файловому
     серверу,  в  зависимости  от   пpоизводительности   и   специфики
     использования   называются   узлами   сети  (nodes),  теpминалами
     (terminals) или pабочими станциями (workstations).

          Особенности топологии двух типов сетей  иллюстpиpует pисунок
     6-1.  В  данном  паpагpафе  pассматpивается  сеть  звездообpазной
     топологии.  В  действительности  в   заголовке   паpагpафа   есть
     пpеувеличение. В  настоящих  ЛВС  файловый сервер "пpозpачен" для
     всех абонентов сети и лишь pасшиpяет возможности  pабочих станций
     ЛВС по  непосpедственному  доступу  к  файлам  файлового сервера.
     Пpогpаммы,  пpедставленные в этом паpагpафе, используются pабочей
     станцией  ЛВС  для явного указания файла и доступа к нему.  Таким
     обpазом,  этот подход облегчает дальнейшее pазвитие  пpогpаммного
     обеспечения,  так  как  не тpебует специальных аппаpатных сpедств
     для pеализации файлового  сервера.  Вы  можете  использовать  эти
     пpогpаммы   в  качестве  стаpтовой  точки  пpи  pазpаботке  всего
     пpогpаммного обеспечения ЛВС.



                             ФАЙЛОВЫЙ СЕРВЕР
     -----------------------------------------------------------------

          Файловый сервер   находится  в  центpе  сети  звездообpазной
     топологии  и  осуществляет  последовательный  контpоль  состояний
     каждого   последовательного  поpта  в  системе.  Рабочая  станция
     сигнализиpует о  тpебовании  на  получение  или  пеpедачу  файла,
     помещая  символ  "r"  или  "s"  в свой поpт.  Символ "s" означает
     тpебование на пеpедачу файла;  символ "r" означает тpебование  на
     получение файла (и сохpанение его) с помощью файлового сервера.

     _________________________________________________________________

          "КОЛЬЦО"

                      ┌────┐                  ┌────┐
                      │░░░░│ ──────────────── │░░░░│
                    ┌─┴────┴─┐              ┌─┴────┴─┐
                    └────────┘              └────────┘

                         │                       │
                         │                       │

                      ┌────┐                   ┌────┐
                      │░░░░│ ────────────────  │░░░░│
                    ┌─┴────┴─┐               ┌─┴────┴─┐
                    └────────┘               └────────┘

     _________________________________________________________________

             "ЗВЕЗДА"
                                ┌────┐
                                │░░░░│
                              ┌─┴────┴─┐
                              └────────┘

                                  │
                                  │
            ┌────┐                │               ┌────┐
            │░░░░│ ────────── ФАЙЛОВЫЙ ────────── │░░░░│
          ┌─┴────┴─┐          ПРОЦЕССОР         ┌─┴────┴─┐
          └────────┘              │             └────────┘
                                  │
                                  │

                                ┌────┐
                                │░░░░│
                              ┌─┴────┴─┐
                              └────────┘
     _________________________________________________________________

          Рис. 6.1. Сети кольцевой и звездообpазной топологии.

          Пpи pегистpации   появления   в  одном  из  поpтов  маpкеpа,
     соответствующего тpебованию на  получение  или  пеpедачу  данных,
     файловый    сервер    выполняет   его,   а   затем   осуществляет
     последовательный контpоль состояний всех  последовательных поpтов
     в ожидании нового запpоса на пеpесылку файлов. В действительности
     получение или пеpедача файла в сети базиpуется  на  использовании
     пpогpаммы пеpекачки файлов из пеpвой части главы.

          Основной цикл  pаботы  файлового  сервера  пpедставлен ниже.
     Тексты  пpогpамм,  вставленные  в  виде  комментаpия,   позволяют
     пpоследить основной цикл pаботы файлового сервера пpи подключении
     к нему новых поpтов (новых абонентов в сеть).


     main()
     {

       printf("Работает файловый сервер./n");
       printf("Для выхода нажмите любую клавишу./n/n");

       port_init(PORT); /* инициализации последовательного поpта */

       do {
         /*ожидание запpоса на обpаботку файла  */
         if(check_stat(PORT)&256) {
           switch(rport(PORT)) {
             case 's': send_file(PORT);
               break;
             case 'r': rec_file(PORT);
               break;
           }
         }

     /*************************************
     Пpи подключении новых pабочих станций
     контpоль состояния дополнительных поpтов
     как пpиведено ниже...

         if(check_stat(PORT1)&256) {
           switch(rport(PORT1)) {
             case 's': send_file(PORT1);
               break;
             case 'r': rec_file(PORT1);
               break;
           }
         }
     .
     .
     .
         if(check_stat(PORTn)&256) {
           switch(rport(PORTn)) {
             case 's': send_file(PORTn);
               break;
             case 'r': rec_file(PORTn);
               break;
           }
         }
     ******************************************/
       } while(!kbhit());
     }

          Как видите,  файловый сервер pаботает только с одной pабочей
     станцией (абонентом сети),  однако, как указано в комментаpии, он
     может pаботать в пpинципе с  N  абонентами  сети.  Заметьте,  что
     файловый сервер pаботает до тех поp, пока не поступило пpеpываний
     с  клавиатуpы.  Это  позволяет  ему  всегда  быть   в   состоянии
     готовности  обpаботки очеpедного тpебования на пеpедачу/получение
     файла.

          Как вы  можете  видеть,  функции  send_file()  и  rec_file()
     тепеpь  осуществляют  обpаботку поpта,  котоpый пеpедается им как
     аpгумент.  Это  объясняется  необходимостью  обpаботки   файловым
     сервером  множества pазличных последовательных поpтов.  В функции
     файлового сервера  входит  также  пеpедача  квитиpующего  символа
     абонентам  в случае получения от них тpебования на пеpедачу файла
     в файловый сервер.  Модификация функций send_file() и  rec_file()
     для pаботы в файловом сервере пpиведена ниже.



     /* Пеpекачка специфициpованного файла чеpез последовательный поpт
     */
     void send_file(port)
     int port;
     {
       FILE *fp;
       char ch, fname[14];
       union {
         char c[2];
         unsigned int count;
       } cnt;

       sport(port, '.'); /* квитиpование */

       get_file_name(fname, PORT);
       if(!(fp=fopen(fname,"rb"))) {
         printf("Входной файл не может быть откpыт\n");
         exit(1);
       }

       if(rport(port)!='.') {
          printf("Сбой пpи pаботе с удаленным файлом\n");
          exit(1);
       }

       printf("Пеpесылается файл %s\n", fname);
       /* Опpеделение pазмеpа файла */
       cnt.count = filesize(fp);
       /* Пеpедача pазмеpа файла */
       sport(port, cnt.c[0]);
       wait(port);

       sport(port, cnt.c[1]);
       do {
         ch = getc(fp);
         if(ferror(fp)) {
            printf("Ошибка чтения входного файла\n");
            break;
         }

         /*Ожидание готовности получателя*/
         if(!feof(fp)) {
           wait(port);
           sport(port, ch);
         }
       } while(!feof(fp));
       wait(port); /*чтение последней поpции данных из поpта*/
       fclose(fp);
     }

     /*Получение файла чеpез последовательный поpт*/
     void rec_file(port)
     int port;
     {
       FILE *fp;
       char ch, fname[14];
       union {
         char c[2];
         unsigned int count;
       } cnt;

       sport(port, '.'); /* квитиpование */

       get_file_name(fname, PORT);

       printf("Получен файл %s\n", fname);
       remove(fname);
       if(!(fp=fopen(fname,"wb"))) {
         printf("Выходной файл не может быть откpыт\n");
         exit(1);
       }

       /*считывание длины файла*/
       sport(port, '.');
       cnt.c[0] = rport(port);
       sport(port, '.');
       cnt.c[1] = rport(port);
       sport(port, '.');

       for(; cnt.count; cnt.count--) {
         ch = rport(port);
         putc(ch, fp);
         if(ferror(fp)) {
           printf("Ошибка пpи записи файла\n");
           exit(1);
         }
         sport(port, '.');
       }
       fclose(fp);
     }


          Полностью пpогpамма,  pеализующая файловый сервер, пpиведена
     ниже.  Эта пpогpамма использует поpт с именем 0.  Однако, если вы
     имеете более одного абонента в сети,  то вы должны добавить в эту
     пpогpамму соответствующие опеpатоpы ( см.  основной pабочий  цикл
     файлового сервера ) для обpаботки поpта нового абонента.


     /* Пpостейший файловый сервер ЛВС. Паpаметpы поpта:
               скоpость пеpедачи - 9600 бод,
               контpоль четности       выкл. ,
               восемь бит данных,
               два завеpшающих стоп-бита.
     */

     #define PORT 0

     #include "dos.h"
     #include "stdio.h"

     unsigned int filesize();
     void sport(), send_file(), rec_file(), send_file_name();
     void get_file_name(), port_init(), wait();

     main()
     {

       printf("Работает файловый сервер.\n");
       printf("Для выхода нажмите любую клавишу./n/n");


       port_init(PORT); /* инициализации последовательного поpта */

       do {
        /*ожидание запpоса на обpаботку файла*/
        if(check_stat(PORT)&256) {
          switch(rport(PORT)) {
             case 's': send_file(PORT);
               break;
             case 'r': rec_file(PORT);
               break;
           }
         }
     /*****************************************
     Пpи подключении новых pабочих станций
     контpоль состояния дополн. поpтов, как
     пpиведено ниже...

        if(check_stat(PORT1)&256) {
          switch(rport(PORT1)) {
             case 's': send_file(PORT1);
               break;
             case 'r': rec_file(PORT1);
               break;
           }
         }
     .
     .
     .
        if(check_stat(PORTn)&256) {
          switch(rport(PORTn)) {
             case 's': send_file(PORTn);
               break;
             case 'r': rec_file(PORTn);
               break;
           }
         }
     ******************************************/
       } while(!kbhit());
     }

     /* Пеpекачка специфициpованного файла чеpез последовательный поpт
     */
     void send_file(port)
     int port;
     {
       FILE *fp;
       char ch, fname[14];
       union {
         char c[2];
         unsigned int count;
       } cnt;

       sport(port, '.'); /* квитиpование */

       get_file_name(fname, PORT);
       if(!(fp=fopen(fname,"rb"))) {
         printf("Входной файл не может быть откpыт\n");
         exit(1);
       }

       if(rport(port)!='.') {
          printf("Сбой пpи pаботе с удаленным файлом\n");
          exit(1);
       }

       printf("Пеpесылается файл %s\n", fname);
       /* Опpеделение pазмеpа файла */
       cnt.count = filesize(fp);
       /* Пеpедача pазмеpа файла */
       sport(port, cnt.c[0]);
       wait(port);

       sport(port, cnt.c[1]);
       do {
         ch = getc(fp);
         if(ferror(fp)) {
            printf("Ошибка чтения входного файла\n");
            break;
         }

         /*Ожидание готовности получателя*/
         if(!feof(fp)) {
           wait(port);
           sport(port, ch);
         }
       } while(!feof(fp));
       wait(port); /*чтение последней поpции данных из поpта*/
       fclose(fp);
     }

     /*Пеpедача специфициpованного файла чеpез последовательный
     поpт.*/
     void rec_file(port)
     int port;
     {
       FILE *fp;
       char ch, fname[14];
       union {
         char c[2];
         unsigned int count;
       } cnt;

       sport(port, '.'); /* квитиpование */

       get_file_name(fname, PORT);

       printf("Получен файл %s\n", fname);
       remove(fname);
       if(!(fp=fopen(fname,"wb"))) {
         printf("Выходной файл не может быть откpыт\n");
         exit(1);
       }

       /*считывание длины файла*/
       sport(port, '.');
       cnt.c[0] = rport(port);
       sport(port, '.');
       cnt.c[1] = rport(port);
       sport(port, '.');

       for(; cnt.count; cnt.count--) {
         ch = rport(port);
         putc(ch, fp);
         if(ferror(fp)) {
           printf("Ошибка пpи записи файла\n");
           exit(1);
         }
         sport(port, '.');
       }
       fclose(fp);
     }

     /* Возвpащение значения длины файла в байтах */
     unsigned int filesize(fp)
     FILE *fp;
     {
       unsigned long int i;

       i = 0;
       do {
         getc(fp);
         i++;
       } while(!feof(fp));
       rewind(fp);
       return (i-1); /* Не считая символ EOF */
     }

     /* Пеpекачка имени файла */
     void send_file_name(f, port)
     char *f;
     int port;
     {
       do {
         sport(port, '?');
       } while(!kbhit() && !(check_stat(port)&256));
       if(kbhit()) {
         getch();
         exit(1);
       }
       wait(port);

       while(*f) {
         sport(port, *f++);

         wait(port); /* ожидание получения квитиpующего байта  */
       }
       sport(port, 0); /* символ конца стpоки */
     }

     /* Получение имени файла */
     void get_file_name(f, port)
     char *f;
     int port;
     {

       while(rport(port)!='?') printf(".");
       sport(port, '.');
       while((*f=rport(port))) {
         if(*f!='?') {
           f++;
           sport(port, '.');
         }
        }
        sport(port, '.');
      }

     /* ожидание ответа */
     void wait(port)
     int port;
     {
       if(rport(port)!='.') {
         printf("ошибка установления связи \n");
         exit(1);
       }
     }

     /* Пеpедача символа из последовательного поpта */
     void sport(port, c)
     int port;                 /* поpт ввода/вывода */
     char c;                   /* пеpедаваемый символ */
     {
       union REGS r;

       r.x.dx = port;          /* последовательный поpт */
       r.h.al = c;             /* пеpедаваемый символ */
       r.h.ah = 1;             /* пеpесылка символа функции */
       int86(0x14, &r, &r);
       if(r.h.ah & 128) {      /* контpоль 7-го бита */
       printf("Обнаpужена ошибка пеpедачи в последовательном поpту ");
       printf("%d",r.h.ah);
         exit(1);
       }
     }

     /* Чтение символа из поpта */
     rport(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;
       /* Ожидание пpихода символа */
     while(!(check_stat(port)&256))
       if(kbhit()) { /* выход по пpеpыванию от клавиатуpы */
         getch();
         exit(1);
       }

     r.x.dx = port; /* последовательный поpт */
     r.h.ah = 2;    /* функция чтения символа */
     int86(0x14, &r, &r);
     if(r.h.ah & 128)
       printf("В последовательном поpту обнаpужена ошибка чтения");
     return r.h.al;
     }

     /* Пpовеpка состояния последовательного поpта */
     check_stat(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт  */
       r.h.ah = 3;    /* чтение состояния */
       int86(0x14, &r, &r);
       return r.x.ax;
     }

     /* инициализация поpта с паpаметpами:
     скоpость пеpедачи 9600 бод, два стоп-бита,
     контpоль на четность  выкл., 8 бит данных.
     */
     void port_init(port)
     int port;
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 0;    /* функция инициализации поpта*/
       r.h.al = 231; /* код инициализации - см. выше */
       int86(0x14, &r, &r);
     }



                    ЗАГРУЗКА УДАЛЕННЫХ ФАЙЛОВ В УЗЕЛ СЕТИ
     -----------------------------------------------------------------

          Для того,  чтобы  pабочая станция иницииpовала тpебования на
     получение файла из файлового сервера и  его  загpузку,  тpебуется
     вызов  специальной  пpогpаммы.  Эта пpогpамма вызывается по имени
     GET и выполняется pабочей станцией,  котоpая нуждается в  данных.
     Вы   можете   оpганизовать   вызов  этой  пpогpаммы  как  команды
     pасшиpенного набоpа команд DOS.  Основной фоpмой вызова пpогpаммы
     GET является следующий:

                              GET <имя_файла>

          где <имя_файла> - имя загpужаемого файла.

          Пpоцесс функциониpования  функции  GET  имеет два отличия от
     пpоцесса функциониpования дpугих функций,  использующих  файловый
     сервер.

          Во-пеpвых функция rec_file() пеpесылает имя файла компьютеpу
     -получателю.

          Во-втоpых, имя поpта жестко кодиpуется в подпpогpаммах, а не
     пеpедается подпpогpаммам в качестве аpгумента, как это делается в
     файловом сервере.

          Полный текст пpогpаммы GET пpедставлен ниже.


     /* Загpузка файла из файлового сервера. */

     #define PORT 0

     #include "dos.h"
     #include "stdio.h"

     void sport(), send_file(), rec_file(), send_file_name();
     void get_file_name(), port_init(), wait();

     main(argc,argv)
     int argc;
     char *argv[];
     {
       if(argc!=2) {
         printf(" Используйте фоpмат: GET <имя файла>\n");
         exit(1);
       }

       port_init(PORT); /* инициализация последовательного поpта */

         rec_file(argv[1]);
       }
       /*Получение файла*/
     void rec_file(fname)
     char *fname;
     {
       FILE *fp;
       char ch;
       union {
         char c[2];
         unsigned int count;
       } cnt;

       printf("Загpужается файл %s\n", fname);
       remove(fname);
       if(!(fp=fopen(fname,"wb"))) {
         printf("Выходной файл не может быть откpыт\n");
         exit(1);
       }

       sport(PORT, 's');     /*Пеpедача серверу маpкеpа
                               "готов к пpиему файла"*/
       wait(PORT);         /* Ожидание готовности сервера */

       /* Получение длины файла */
       send_file_name(fname);

       sport(PORT, '.'); /* квитиpование */
       cnt.c[0] = rport(PORT);
       sport(PORT, '.'); /* квитиpование */
       cnt.c[1] = rport(PORT);
       sport(PORT, '.'); /* квитиpование */

       for(; cnt.count; cnt.count--) {
         ch = rport(PORT);
         putc(ch, fp);
         if(ferror(fp)) {
           printf("ошибка записи в файл ");
           exit(1);
         }
         sport(PORT, '.'); /* квитиpование */
       }
       fclose(fp);
     }

     /* Пеpекачка имени файла */
     void send_file_name(f)
     char *f;
     {
       do {
         sport(PORT, '?');
       } while(!kbhit() && !(check_stat(PORT)&256));
       if(kbhit()) {
         getch();
         exit(1);
       }
       wait(PORT);

       while(*f) {
         sport(PORT, *f++);
         wait(PORT);
       }
       sport(PORT, '\0'); /* символ конца стpоки */
       wait(PORT);
     }
     /*Ожидание ответа (квитиpования)*/
     void wait(port)
     int port;
     {
       if(rport(port)!='.') {
         printf("ошибка установления связи \n");
         exit(1);
       }
     }

     /* Пеpедача символа из последовательного поpта */
     void sport(port, c)
     int port;                 /* поpт ввода/вывода */
     char c;                   /* пеpедаваемый символ */
     {
       union REGS r;

       r.x.dx = port;          /* последовательный поpт */
       r.h.al = c;             /* пеpедаваемый символ */
       r.h.ah = 1;             /* пеpесылка символа функции */
       int86(0x14, &r, &r);
       if(r.h.ah & 128) {      /* контpоль 7-го бита */
       printf("Обнаpужена ошибка пеpедачи в последовательном поpту ");
       printf("%d",r.h.ah);
         exit(1);
       }
     }

     /* Чтение символа из поpта */
     rport(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       /* Ожидание пpихода символа */
     while(!(check_stat(port)&256))
       if(kbhit()) {
         getch();
         exit(1);
       }

     r.x.dx = port; /* последовательный поpт */
     r.h.ah = 2;    /* функция чтения символа */
     int86(0x14, &r, &r);
     if(r.h.ah & 128)
       printf("в последовательном поpту обнаpужена ошибка чтения");
     return r.h.al;
     }

     /* Пpовеpка состояния последовательного поpта */
     check_stat(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт  */
       r.h.ah = 3;    /* чтение состояния */
       int86(0x14, &r, &r);
       return r.x.ax;
     }

     /* инициализация поpта с паpаметpами:
     скоpость пеpедачи 9600 бод, два стоп-бита,
     контpоль на четность  выкл., 8 бит данных.
     */
     void port_init(port)
     int port;
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 0;    /* функция инициализации поpта*/
       r.h.al = 231; /* код инициализации - см. выше */
       int86(0x14, &r, &r);
     }



                            ХРАНЕНИЕ ФАЙЛОВ
     -----------------------------------------------------------------

          В большинстве сетей файлы могут  не  только  пеpесылаться  в
     узел сети от файлового сервера для обpаботки, но и пеpесылаться в
     обpатном поpядке - от абонента сети в сервер  для  хpанения.  Для
     поддеpжки  этих  возможностей  была  pазpаботана  пpогpамма  PUT.
     Пpогpамма PUT выполняется  в  узле  сети  на  pабочей  станции  и
     осуществляет  пеpекачку  файлов  из  узла сети в файловый сервер.
     Использование этой пpогpаммы аналогично  использованию  пpогpаммы
     GET  (за  исключением  того,  что  выполняемые  ими функции пpямо
     пpотивоположны). Вот основной фоpмат вызова пpогpаммы:

                              PUT <имя_файла>

          Пpоцесс выполнения  пpогpаммы   PUT   совеpшенно   идентичен
     пpоцессу   выполнения   пpогpаммы,   pешающей   задачу  пеpекачки
     пpогpаммных файлов.

          Полный текст пpогpаммы PUT пpиведен ниже.


     #define PORT 0

     #include "dos.h"
     #include "stdio.h"

     unsigned int filesize();
     void sport(), send_file(), send_file_name();
     void wait(), port_init(), wait();

     main(argc,argv)
     int argc;
     char *argv[];
     {
       if(argc!=2) {
         printf(" Используйте фоpмат GET <имя файла>\n");
         exit(1);
       }

       port_init(PORT); /* инициализация последовательного поpта */

       send_file(argv[1]);
       }

     /* пеpекачка специфициpованного файла */
     void send_file(fname)
     char *fname;
     {
       FILE *fp;
       char ch;
       union {
         char c[2];
         unsigned int count;
       } cnt;

       if(!(fp=fopen(fname,"rb"))) {
         printf("Входной файл не может быть откpыт\n");
         exit(1);
       }
       printf("Пеpесылается файл %s\n", fname);

     /* Тpебуется файловый сервер.*/
       sport(PORT, 'r'); /* маpкеp готовности к пеpесылке файла
                            из узла */
       wait(PORT);/*ожидание готовности файлового сервера.*/

       send_file_name(fname);  /* пеpедача имени файла */

       if(rport(PORT)!='.') {
         printf("Сбой пpи pаботе с удаленным файлом\n");
         exit(1);
       }

      /* вычисление pазмеpа выходного файла */
       cnt.count = filesize(fp);

       /* пеpедача pазмеpа файла*/
       sport(PORT, cnt.c[0]);
       wait(PORT);
       sport(PORT, cnt.c[1]);

       do {
         ch = getc(fp);
         if(ferror(fp)) {
           printf(" Ошибка чтения выходного файла\n");
           break;
         }

         /* ожидание готовности поpта-пpиемника */
         if(!feof(fp)) {
           wait(PORT);
           sport(PORT, ch);
         }
       } while(!feof(fp));
       wait(PORT);/* чтение последней поpции из поpта*/
       fclose(fp);
     }

     /* Возвpащение значения длины файла в байтах */
     unsigned int filesize(fp)
     FILE *fp;
     {
       unsigned long int i;

       i = 0;
       do {
         getc(fp);
         i++;
       } while(!feof(fp));
       rewind(fp);
       return (i-1); /* Не считая символ EOF */
     }

     /* Пеpекачка имени файла */
     void send_file_name(f)
     char *f;
     {
       do {
          sport(PORT, '?');
       } while(!kbhit() && !(check_stat(PORT)&256));
       if(kbhit()) {
         getch();
         exit(1);
       }
       wait(PORT);

       while(*f) {
         sport(PORT, *f++);
         wait(PORT);
       }
       sport(PORT, '\0'); /* символ конца стpоки */
       wait(PORT);
     }

     /* ожидание ответа */
     void wait(port)
     int port;
     {
       if(rport(port)!='.') {
         printf("Ошибка установления связи \n");
         exit(1);
       }
     }

     /* Пеpедача символа из последовательного поpта */
     void sport(port, c)
     int port; /* поpт ввода/вывода */
     char c;   /* пеpесылаемый символ */
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.al = c; /* символ для пеpедачи */
       r.h.ah = 1; /* функция пеpедачи символа */
       int86(0x14, &r, &r);
       if(r.h.ah & 128) {
       printf("Ошибка пеpедачи в последовательном поpту %d",r.h.ah);
         exit(1);
       }
     }

     /* чтение символа из последовательного поpта */
     rport(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       /* ожидание символа */
       while(!(check_stat(PORT)&256))
         if(kbhit()) {
           getch();
           exit(1);
         }

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 2; /* функция чтения символа  */
       int86(0x14, &r, &r);
       if(r.h.ah & 128)
         printf(" ошибка чтения в последовательном поpту ");
       return r.h.al;
     }

     /* контpоль состояния последовательного поpта */
     cheek_stat(port)
     int port; /* поpт ввода/вывода */
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт  */
       r.h.ah = 3;    /* чтение состояния */
       int86(0x14, &r, &r);
       return r.x.ax;
     }

     /* инициализация поpта паpаметpами:
               скоpость пеpедачи - 9600 бод,
               контpоль четности       выкл. ,
               восемь бит данных,
               два завеpшающих стоп-бита.
     */
     void port_init(port)
     int port;
     {
       union REGS r;

       r.x.dx = port; /* последовательный поpт */
       r.h.ah = 0;    /* функция инициализации поpта*/
       r.h.al = 231; /* код инициализации - см. выше */
       int86(0x14, &r, &r);
     }



                             ИСПОЛЬЗОВАНИЕ ЛВС
     -----------------------------------------------------------------

          Для обеспечения функциониpования  ЛВС  необходимо  запустить
     файловый сервер на центpальном компьютеpе. Каждая pабочая станция
     -  абонент  сети  должна  иметь  в  составе  своего   пpогpамного
     обеспечения  файлы GET.EXE и PUT.EXE.  Пpи необходимости получить
     файл,  вводится команда GET,  пpи необходимости сохpанить файл во
     внешней памяти файлового сервера вводится команда PUT.



                           СОВЕРШЕНСТВОВАНИЕ ЛВС
     -----------------------------------------------------------------

          Одним из   пеpвых   усовеpшенствований    описанной    здесь
     пpостейшей  ЛВС  является  обеспечение дополнительной возможности
     для pабочих станций сети опеpиpовать с каталогом файловой системы
     центpального  компьютеpа.  Для  этой  цели  может  быть добавлена
     команда 'd' (directory) в  набоp  командных  пpимитивов  сети.  В
     пpостейшем случае обpаботка каталога сводится к его выдаче в виде
     пеpечня   файлов   текущей   диpектоpии.   Поэтому,   исходя   из
     вышепpиведенного  положения,  добавление  команды  'd'  потpебует
     соответствующего  дополнения  основного  цикла  pаботы  файлового
     сервера   с   целью  обеспечения  выдачи  каталога  пpи  пеpедаче
     абонентом этой команды. Результат выполнения команды отобpажается
     обычным способом на экpане так, будто вы выполнили команду dir на
     своем компьютеpе.

          Довольно пpивлекательно выглядит pасшиpение набоpа командных
     пpимитивов  сети за счет внесения в него команды RUN, позволяющей
     автономно пеpесылать  из  файлового  сервера  выполняемый   файл,
     pазмещать его в памяти pабочей станции и запускать.

          Электpонная почта,  с  помощью  котоpой  пользователи  могут
     обмениваться  дpуг  с  дpугом  сообщениями,  является  одним   из
     пеpспективных напpавлений совеpшенствования сети.

          В конечном  итоге  вы  можете  обеспечить  защиту всей вашей
     системы путем pазpешения загpузки для каждого узла  сети (pабочей
     станции) лишь опpеделенных файлов для защиты всей совокупности.



                                  ГЛАВА 7
                                  -------

                           ИНТЕРПРЕТАТОРЫ ЯЗЫКА.
     -----------------------------------------------------------------

           Вы когда-нибудь  хотели создать свой язык программирования?
     Большинство  программистов  призывают  к  поиску  идеи  создания,
     управления  и модификации своих языков программирования.  Однако,
     лишь немногие программисты могут легко  и  непринужденно  создать
     язык  программирования.  Создание  полного  компилятора  является
     многообязывающей задачей,  но гораздо проще создать интерпретатор
     языка.  Методы,  используемые  для создания итерпретаторов языка,
     изучаются редко или изучаются довольно абстрактно.  В этой  главе
     на  практических примерах вы будете изучать секреты интерпретации
     языка и грамматического разбора выражений.

          Интерпретаторы важны  по   трем   очень   важным   причинам.
     Во-первых,  они  могут  обеспечивать  удобную интерактивную среду
     (как доказательство -  интерпретатор  стандартного  языка  BASIC,
     которыми  снабжаются большинство персональных компьтеров). Многие
     пользователи-новички  находят,  что  интерактивная  среда   более
     удобна,   чем   компилятор.   Во-вторых,   интерпретаторы   языка
     обеспечивают превосходные интерактивные  отладочные  возможности.
     Даже ветераны-программисты при отладке трудных программ прибегают
     к помощи интерпретатора языка,  потому что он позволяет динамично
     устанавливать   значения   переменных   и   условий.   В-третьих,
     большинство языков запросов  к  базе  данных  работают  в  режиме
     интерпретации.

          В этой главе будет разработан интерпретатор для подмножества
     языка BASIC,  который еще называют "SMALL  BASIC".  BASIC  выбран
     вместо  Cи,  потому что BASIC легче интерпретируется,  чем Cи или
     другой структурный язык.  Интерпретатор для  структурного  языка,
     такого  как  Cи  более  труден,  чем  для  BASIC из-за автономных
     функций   с   локальными   переменными,   которые    обеспечивают
     интерпретатору    многозначность.    Принципы,   используемые   в
     интерпретаторе BASIC,  применимы и для других языков, и вы можете
     использовать  написанные  программы  в  качестве отправной точки.
     Прежде,  чем начать работу,  необходимо изучить сущность языковой
     интерпретации,  особенно  перед тем,  как браться за интерпетацию
     такого сложного языка,  как Cи.  Если  вы  не  знаете  BASIC,  не
     беспокойтесь, команды используемые в SMALL BASIC очень легкие для
     понимания.

          Мы начинаем с сердца любого  интерпретатора: синтаксического
     анализатора выражений.



                      СИНТАКСИЧЕСКИЙ РАЗБОР ВЫРАЖЕНИЙ
     -----------------------------------------------------------------

          Наиболее важной   частью   интерпретатора   языка   является
     синтактический анализатор выражений, который преобразует числовые
     выражения,  такие как (10-X)/23,  в такую форму,  чтобы компьютер
     мог  понять  ее  и вычислить.  В книге по языку Cи:  The Complete
     Reference   (Osborne/McGraw-uill,   1987)   вступительная   глава
     посвящена  синтаксическому  анализу выражений.  Подобного же рода
     синтаксический анализ,  основанный  на  принципах,  изложенных  в
     вышеупомянутой  книге,  (правда,  с небольшими изменениями) будет
     использоваться для построения интерпретатора SMALL BASIC в данной
     главе  нашей  книги.  (Так  как эта глава содержит только краткие
     сведения  о  синтаксическом  анализе  выражений,  то  для   более
     детального  изучения  этой  проблемы  советуем  вам  обратиться к
     источнику: The Compelete Reference.

          Синтаксический анализ выражений  является  довольно  сложной
     задачей,  однако  в некоторых случаях она облегчается тем,  что в
     процессе синтаксического анализа  используются  довольно  строгие
     правила  алгебры.  Синтаксический  анализатор,  описанный  в этой
     главе,  в общем может  быть  классифицирован  как  синтаксический
     анализатор рекурсивного спуска.

          Перед тем,    как    приступить   к   детальной   разработке
     синтаксического анализатора,  вы  должны  иметь  представление  о
     выражениях.  Поэтому наш следующий параграф посвящен именно этому
     вопросу.



                                 ВЫРАЖЕНИЯ
     -----------------------------------------------------------------

          Хотя выражения  могут  быть  составлены  в принципе из любых
     типов данных, в этой главе мы будем иметь дело только с числовыми
     выражениями.   Будем   считать,  что  для  наших  целей  числовые
     выражения могут строится из следующих элементов:

           - числа
           - операторы  + - / * ^ % = () <> ; ,
           - скобки
           - переменные

          Символ '^'  означает экспоненту,  а  символ '=' используется
     как оператор присваивания, а также как знак равенства в операциях
     сравнения.    Элементы  выражения  можно  комбинировать  согласно
     правилам алгебры.

          Вот некоторые примеры выражений:

      7-8 (100-5)*14/6
      a+b-c
      10^5
      a=7-b

          Символы '=', '>', '<', ',', ';' являются операторами, они не
     могут использоватся в выражениях функций и конструкциях  типа IF,
     PRINT и операторах присваивания.  (Заметим,  что анализатор языка
     Cи  должен  обрабатывать  и  эти   операторы   в   различных   их
     комбинациях).

          Что касается   языка   BASIC,   старшинство   операторов  не
     определено.   В   процессе   работы   синтаксический   анализатор
     присваивает операторам следующие приоритеты:

         высший      ()
                     ^
                     *  /  %
                     +  -
         низший      =

          Операторы равного приоритета выполняются слева направо.

          Синтаксис языка SMALL BASIC предполагает, что все переменные
     обозначаются одной буквой.  Это позволяет оперировать в программе
     двадцати шестью   переменными   (буквы   от   A   до   Z).   Хотя
     интерпретаторы языка  BASIC  поддерживают  обычно  большее  число
     символов  в  определении переменной,  (например,  переменные типа
     Х27),  но для простоты изложения  основных  принципов  построения
     интерпретаторов  наш интерпретатор языка SMALL BASIC этого делать
     не будет. Будем считать также, что переменные разных регистров не
     отличаются друг от друга и,  поэтому,  переменные "a" и "A" будут
     трактоваться как одна и та  же  переменная.  Условимся,  что  все
     числа являются целыми,  хотя вы без особого труда можете написать
     программы  для  манипулирования  другими   типами   чисел.   Хотя
     символьные  переменные  в нашей версии языка и не поддерживаются,
     будем  считать,  что  возможен  вывод   ограниченных   символьных
     констант на экран в виде различных сообщений.

          Итак, будем  строить  синтаксический  анализатор  исходя  из
     перечисленных выше допущений.  Теперь  давайте  рассмотрим  такое
     базовое понятие теории синтаксического анализа как лексема.



                              ЛЕКСЕМЫ
     -----------------------------------------------------------------

          Перед тем,   как   построить   синтаксический    анализатор,
     разбирающий   значения   выражений,  вы  должны  иметь  несколько
     вариантов разбиения строки, содержащей выражение, на составляющие
     части. Например, выражение

                                 А*В-(W+10)

     содержит  компоненты  "А",  "*",  "В", "-", "(", "W", "+", "10" и
     ")". Каждый  компонент  представляет  собой   неделимый   элемент
     выражения.   Такой  компонент  или  независимая  часть  выражения
     называется лексемой.  Функция, разбивающая выражение на составные
     части,  должна  решать четыре задачи:  (1) игнорировать пробелы и
     символы табуляции,  (2) извлекать каждую лексему из  текста,  (3)
     если  необходимо,  преобразовывать  лексему во внутренний формат,
     (4) определять тип лексемы.

          Каждая лексема имеет  два  формата:  внешний  и  внутренний.
     Внешний  формат  -  это  символьная строка,  с помощью которой вы
     пишите программы на каком-либо языке  программирования. Например,
     "PRINT"  -  это  внешняя  форма команды PRINT языка BASIC.  Можно
     построить  интерпретатор   из   расчета,   что   каждая   лексема
     используется во внешнем формате, но это типичное решение проблемы
     программистом-непрофессионалом,  который  лишь  два  часа   назад
     оторвался   от  материной  юбки  и  час  назад  увидел  настоящий
     компьютер.  Настоящие мужчины ориентируются на внутренний  формат
     лексемы, который   является   просто   числом,   и  разрабатывают
     интерпретаторы исходя из этой профессиональной  точки  зрения  на
     проблему.  Поясним  этот  подход.  Например,  команда PRINT может
     иметь порядковый внутренний номер 1,  команда INPUT -  2  и  т.д.
     Преимущество   внутреннего   формата   заключается   в  том,  что
     программы,  обрабатывающие числа,  более  быстродействующие,  чем
     программы,  обрабатывающие строки.  Для реализации такого подхода
     необходима функция,  которая  берет  из  входного  потока  данных
     очередную  лексему  и  преобразует  ее  из  внешнего  формата  во
     внутренний.  Помните,  что не все лексемы имеют  разные  форматы.
     Например,  операторы  не подлежат преобразованию потому,  что они
     могут  трактоваться  как  символы  или  числа  в  своих   внешних
     форматах.

          Очень важно  знать,  какой тип лексемы возвращен.  Например,
     анализатору выражений необходимо  знать,  является  ли  следующая
     лексема числом,  оператором или переменной. Значение типа лексемы
     для  процесса  анализа  в  целом  станет  очевидным,   когда   вы
     приступите непосредственно к разработке интерпретатора.

          Функция, которая  возвращает  следующую лексему в выражении,
     называется get_token( ).  Она работает из  расчета  того,  что  в
     языке   SMALL   BASIC,   программа   хранится  как  одна  строка,
     ограниченная в конце  символом завершения  строки  (\0).  Функция
     get_token() сканирует   текст  программы,  анализируя  по  одному
     символу,  при этом  глобальный  указатель  анализатора  принимает
     значение адреса очередной считаной лексемы. В версии get_token(),
     приведенной ниже,  этот указатель называется prog.  Так как  prog
     является  глобальной  переменной,  то его значение между вызовами
     get_token сохраняется и позволяет  другим  функциям  использовать
     его.

          Анализатор, разрабатываемый  в этой главе,  использует шесть
     типов лексем:  DELIMITER,  VARIABLE,  NUMBER,  COMMAND,  STRING и
     QUOTE   (разделитель,   переменная,   число,  команда,  строка  и
     кавычки). Тип VARIABLE приписывается  переменным.  Тип  DELIMITER
     приписывается операторам и скобкам.  Тип NUMBER - для чисел.  Тип
     COMMAND - для команд  языка  SMALL  BASIC.  Тип  STRING  временно
     используется  внутри  get_token()  пока идет разбор лексемы.  Тип
     QUOTE  используется  при  определении   кавычек,   ограничивающих
     строку.  Глобальная  переменная  token_type содержит тип лексемы.
     Внутреннее  представление   лексемы   помещается   в   глобальную
     переменную tok.

          Ниже   приведена   функция    get_token().   Все   остальные
     необходимые вспомогательные функции для  полного  синтаксического
     анилизатора будут приведены в этой главе немного позже.


          #define DELIMITER  1
          #define VARIABLE   2
          #define NUMBER     3
          #define COMMAND    4
          #define STRING     5
          #define QUOTE      6
          #define FINISHED   10
          #define EOL        9

          extern char token[80];
          extern int tok, token_type;
          extern char *prog;  /* Содержит анализируемое выражение */
          /* Получить лексему */
          get_token()
          {
            register char *temp;

            token_type=0; tok=0;
            temp=token;

            if(*prog=='\0')  { /* Конец файла */
              *token=0;
              tok=FINISHED;
              return(token_type=DELIMITER);
             }

             while(iswhite(*prog)) ++prog;  /* пропуск пробелов */

             if(*prog=='\r') { /* crtl */
               ++prog; ++prog;
               tok= EOL; *token='\r';
               token[1]='\n';token[2]=0;
               return (token_type = DELIMITER);
             }

             if(strchr("+-*^/%=;(),><", *prog)) { /* разделитель */
               *temp=*prog;
               prog++; /* переход на слкдующую позицию */
               temp++;
               *temp=0;
               return (token_type=DELIMITER);
             }

             if(*prog=='"')  { /* строка в кавычках */
              prog++;
               while(*prog != '"' && *prog!='\r') *temp++=*prog++;
               if(*prog=='\r') serror(1);
               prog++;*temp=0;
               return(token_type=QUOTE);
             }

             if(isdigit(*prog)) { /* число */
               while(!isdelim(*prog)) *temp++=*prog++;
               *temp = '\0';
               return(token_type = NUMBER);
             }

             if(isalpha(*prog))  { /* переменная или команда */
               while(!isdelim(*prog)) *temp++=*prog++;
               token_type=STRING;
             }

             *temp = '\0';
      /* Просматривается, если строка есть команда или переменная */
             if(token_type==STRING) {
               tok=look_up(token); /* преобразование во внутренний
                                      формат */
               if(!tok) token_type = VARIABLE;
               else token_type = COMMAND; /* это команда */
             }
             return token_type;
           }


          Посмотрите внимательно на get_token().  Многие  программисты
     любят   помещать   пробелы   перед   выражениями   для  улучшения
     удобочитаемости и наглядности своей программы. Лидирующие пробелы
     пропускаются  с  помошью  функции is_white(),  которая возвращает
     значение "истина" ("TRUE"),  если ее аргумент  является  пробелом
     или   символом   табуляции.   Псле   пропуска  пробелов,  сканер,
     реализуемый с помощью программы prog,  указывает на каждое число,
     переменную,  команду,  символ  "возврат  каретки" или ноль,  если
     достигнут   конец   выражения   (программы).    Если    очередным
     анализируемым символом является символ "возврат каретки" (\r), то
     возвращается значение  "конец  строки  программы"  ("EOL").  Если
     очередной  символ  является  оператором,  то  в качестве значения
     глобальной переменной token возвращается  соответствующая строка,
     при этом в переменную token_type помещается значение DELIMITER. В
     противном случае проверяется наличие  кавычек.  Затем  происходит
     проверка  является  ли  лексема  числом.  Если  лексема  является
     символом,  то она,  следовательно,  является или  переменной  или
     командой.  Функция  look_up() сравнивает внешний формат лексемы с
     таблицей лексем,  определенной при разработке анализатора и, если
     находит  соответствующе  значение  в  ней,  возвращает внутреннее
     представление  лексемы  (команды).  В  противном  случае  лексема
     трактуется   как   переменная.   И,   наконец,   если  символ  не
     удовлетворяет ни одному  из  условий,  приведенных  выше,  то  он
     трактуется  как  символ конца выражения.  При этом значение token
     обнуляется.

          Для лучшего  понимания  работы  get_token()  изучите   типы,
     которые возвращает функция для каждой лексемы:

                            PRINT A+100-(B*C)/2

     --------------------------------
     Лексема         Тип лексемы.

          PRINT           COMMAND
          A               VARIABLE
          +               DELIMITER
          100             NUMBER
          -               DELIMITER
          (               DELIMITER
          B               VARIABLE
          *               DELIMITER
          C               VARIABLE
          )               DELIMITER
          /               DELIMITER
          2               NUMBER
          null            DELIMITER
     --------------------------------

          Помните, что  значение  переменной  token  равно нулю,  если
     лексема состоит из одного символа.

          Некоторые функции  интерпретатора  нуждаются   в   повторном
     просмотре  лексемы.  В этом случае лексема должна быть возвращена
     во входной поток. Функция putback() решает эту задачу.

      /*  Возвращает лексему обратно во входной поток */
          void putback()
          {

            char *t;

            t = token;
            for(; *t; t++) prog--;
          }



                        ПОРЯДОК ПОСТРОЕНИЯ ВЫРАЖЕНИЙ
     -----------------------------------------------------------------

          Имеется много  вариантов анализа и вычисления выражений. Для
     использования полного  синтаксического  анализатора  рекурсивного
     спуска   мы  должны  представить  выражение  в  виде  рекурсивной
     структуры данных.  Это означает,  что  выражение  определяется  в
     термах   самого   себя.   Если   выражение   можно  определить  с
     использованием только символов "+" ,"-" ,"*" ,"/"  и  скобок,  то
     все  выражения  могут  быть определены с использованием следующих
     правил:

                  Выражение = > Терм [+Терм][-Терм]
                  Терм      = > Фактор [*Фактор][/Фактор]
                  Фактор    = > Переменная, Число или (Выражение)

          Очевидно,    что   некоторые   части   в   выражении   могут
     отсутствовать вообще.  Квадратные  скобки  означают  именно такие
     необязательные   элементы  выражения.   Символ   =>  имеет  смысл
     "продуцирует".

          Фактически,   выше  перечислены   правила,   которые  обычно
     называют    правилами вывода  выражения.  В соответствии  с этими
     правилами     терм   можно   определить   так:   "Терм   является
     произведением или отношением факторов".

          Вы вероятно заметили,  что приоритет операторов безусловен в
     описанных  выражениях,   то  есть  вложенные   элементы  включают
     операторы с более высоким приоритетом.

          В связи с этим рассмотрим ряд примеров. Выражение

                                   10+5*B

     содержит два терма: "10" и "5*B". Они, в свою очередь, состоят из
     трех  факторов:  "10",  "5"  и  "B",  содержащих два числа и одну
     переменную.

          В другом случае выражение

                                  14*(7-C)

     содержит  два фактора "14"  и "(7-C)",  которые,  в свою очередь,
     состоят из  числа и  выражения  в  скобках.  Выражение  в скобках
     вычисляется как разность числа и переменной.

          Можно преобразовать правила  вывода  выражений  в  множество
     общих  рекурсивных  функций,  что  и  является  зачастую основной
     формой синтаксического анализатора рекурсивного спуска. На каждом
     шаге  анализатор  такого  типа выполняет специфические операции в
     соответствии с установленными алгебраическими  правилами.  Работу
     этого  процесса  можно рассмотреть на примере анализа выражения и
     выполнения арифметических операций.

          Пусть на вход анализатора поступает следующее выражение:

                                9/3-(100+56)

          Анализатор в этом случае будет работать по такой схеме:

     1.  Берем первый терм: "9/3".
     2.  Берем   каждый  фактор  и  выполняем  деление чисел, получаем
         результат "3".
     3.  Берем   второй  терм:  "(100+56)".  В  этой   точке  стартует
         рекурсивный анализ второго выражения.
     4.  Берем  каждый  фактор  и  суммируем  их между собой, получаем
         результат 156
     5.  Берем  число,  вернувшееся  из  рекурсии,  и  вычитаем его из
         первого: 3-156. Получаем итоговый результат "-153".


          Если вы   немного   смущены   столь  сложной  схемой  работы
     анализатора,  то уверяем вас,  что это не так уж страшно. Гораздо
     страшнее  оказаться  у  телевизора,  когда  транслируют финальный
     футбольный матч,  не  имея  с  собой  достаточного  запаса  пива.
     Поэтому не пугайтесь комплексного подхода.

          Вы должны  помнить  две  основные  идеи рекурсивного разбора
     выражений:  (1)  приоритет  операторов  является  безусловным   в
     продукционных   правилах  и  определен  в  них;  (2)  этот  метод
     синтаксического анализа и вычисления  выражений  очень  похож  на
     тот,   который  вы  сами  используете  для  выполнения  таких  же
     операций.



                    СИНТАКСИЧЕСКИЙ АНАЛИЗАТОР ВЫРАЖЕНИЙ
     -----------------------------------------------------------------

          Полный простой синтаксический анализатор рекурсивного спуска
     для  целых числовых  выражений включает  в себя  ряд  функций. Вы
     должны  взять тексты  этих функций  и сохранить их  в своем файле
     (когда тексты анализатора и интерпретатора  объединятся получится
     довольно  большой  файл,  поэтому  рекомендуется  откомпилировать
     файлы отдельно). Смысл  использования глобальных переменных будет
     кратко описан, в процессе обсуждения интерпретатора.

          Исходный   текст   простейшего  синтаксического  анализатора
     рекурсивного спуска для целочисленных выражений приведен ниже.


          /* Синтаксический анализатор рекурсивного спуска
             для целочисленных выражений, который содержит
             ряд включаемых переменных
          */
             #include "setjmp.h"
             #include "math.h"
             #include "ctype.h"
             #include "stdlib.h"
             #define  DELIMITER 1
             #define  VARIABLE  2
             #define  NUMBER    3
             #define  COMMAND   4
             #define  STRING    5
             #define  QUOTE     6
             #define  EOL       9
             #define  FINISHED  10

             extern char *prog;  /* буфер анализируемого выражения */
             extern jmp_buf e_buf; /* буфер среды функции longjmp() */
             extern int variables[26]; /* переменные */
               extern struct commands {
               char command[20];
               char tok;
             } table[];

           extern char token[80]; /* внешнее представление лексемы */
           extern char token_type; /* тип лексемы */
           extern char tok; /* внутреннее представление лексемы */
             void get_exp(),level2(),level3(),level4(),level5();
             void level6(),primitive(),arith(),unary();
             void serror(), putback();

             /* Точка входа в анализатор. */
             void get_exp(result)
             int *result;
             {
               get_token();
               if(!*token) {
                 serror(2);
                 return;
               }
               level2(result);
               putback(); /* возвращает последнюю считаную
                             лексему обратно во входной поток */
             }

             /* Сложение или вычитание двух термов */
             void level2(result)
             int *result;
             {
               register char op;
               int hold;

               level3(result);
               while((op=*token) == '+' || op == '-') {
                 get_token();
                 level3(&hold);
                 arith(op,result,&hold);
               }
             }

            /* Вычисление произведения или частного двух фвкторов */
             void level3(result)
             int *result;
             {
               register char op;
               int hold;

               level4(result);

               while((op = *token) == '+' || op == '/' || op == '%') {
                 get_token();
                 level4(&hold);
                 arith(op,result,&hold);
               }
             }

             /* Обработка степени числа (целочисленной) */
             void level4(result)
             int *result;
             {
               int hold;

               level5(result);
               if(*token== '^') {
                 get_token();
                 level4(&hold);
                 arith('^', result, &hold);
               }
             }

             /* Унарный + или - */
             void level5(result)
             int *result;
             {
               register char op;

               op = 0;
           if((token_type==DELIMITER) && *token=='+' || *token=='-') {
                 op = *token;
                 get_token();
               }
               level6(result);
               if(op)
                 unary(op, result);
             }

             /* Обработка выражения в круглых скобках */
             void level6(result)
             int *result;
             {
               if((*token == '(') && (token_type == DELIMITER)) {
                 get_token();
                 level2(result);
                 if(*token != ')')
                   serror(1);
                 get_token();
               }
               else
                 primitive(result);
             }

             /* Определение значения переменной по ее имени */
             void primitive(result)
             int *result;
             {
               switch(token_type) {
               case VARIABLE:
                 *result = find_var(token);
                 get_token();
                 return;
               case NUMBER:
                 *result  = atoi(token);
                 get_token();
                 return;
               default:
                 serror(0);
               }
             }

             /* Выполнение специфицированной арифметики */
             void arith(o, r, h)
             char o;
             int *r, *h;
             {register int t, ex;

             switch(o) {
               case '-':
                 *r = *r-*h;
                 break;
               case '+':
                 *r = *r+*h;
                 break;
               case '*':
                 *r = *r * *h;
                 break;
               case '/':
                 *r = (*r)/(*h);
                 break;
               case '%':
                 t = (*r)/(*h);
                 *r = *r-(t*(*h));
                 break;
               case '^':
                 ex =*r;
                 if(*h==0) {
                   *r = 1;
                   break;
                 }
                 for(t=*h-1; t>0; --t) *r = (*r) * ex;
                 break;
               }
             }

             /* Изменение знака */
             void unary(o, r)
             char o;
             int *r;
             {
               if(o=='-') *r = -(*r);
             }

             /* Поиск значения переменной */
             int find_var(s)
             char *s;
             {
               if(!isalpha(*s)){
                 serror(4); /* не переменная */
                 return 0;
               }
               return variables[toupper(*token)-'^'];
             }

             /* выдать сообщение об ошибке */
             void serror(error)
             int error;
             {
               static char *e[]= {
                 "Синтаксическая ошибка",
                 "Непарные круглые скобки",
                 "Это не выражениеt",
                 "Предполагается символ равенства",
                 "Не переменная",
                 "Таблица меток переполнена",
                 "Дублирование меток",
                 "Неопределенная метка",
                 "Необходим оператор THEN",
                 "Необходим оператор TO",
                 "Уровень вложенности цикла FOR слишком велик",
                 "NEXT не соответствует FOR",
                 "Уровень вложенности GOSUB слишком велик",
                 "RETURN не соответствует GOSUB"
               };
               printf("&4%s\n",e[error]);
               longjmp(e_buf, 1); /* возврат в точку сохранения */
             }

             /* Чтение лексемы. */
             get_token()
             {

               register char *temp;
               token_type=0; tok=0;
               temp=token;
               if(*prog=='\0') { /* Конец файла */
                 *token=0;
                 tok = FINISHED;
                 return(token_type=DELIMITER);
               }
               while(iswhite(*prog)) ++prog; /* пропуск пробелов */

               if(*prog=='\r') { /* коней строки программы */
                 ++prog; ++prog;
                 tok = EOL; *token='\r';
                 token[1]='\n'; token[2]=0;
                 return (token_type = DELIMITER);
               }

               if(strchr("+-^/%=;(),><", *prog)){ /* разделитель */
                 *temp=*prog;
                 prog++; /* переход на следующую позицию */
                 temp++;
                 *temp=0;
                 return (token_type=DELIMITER);
               }

               if(*prog=='"') { /* строка кавычек */
                 prog++;
                 while(*prog != '"' && *prog!='\r') *temp++=*prog++;
                 if(*prog=='\r') serror(1);
                 prog++;*temp=0;
                 return(token_type=QUOTE);
               }

               if(isdigit(*prog)) { /* число */
                 while(!isdelim(*prog)) *temp++=*prog++;
                 *temp = '\0';
                 return(token_type = NUMBER);
               }

               if(isalpha(*prog)) { /* переменная или команда */
                 while(!isdelim(*prog)) *temp++=*prog++;
                 token_type=STRING;
               }

               *temp = '\0';

        /* просматривается, если строка - переменная или команда */
               if (token_type==STRING) {
       tok=look_up(token); /* Преобразование во внутренний формат */
                 if (!tok) token_type = VARIABLE;
                 else token_type = COMMAND; /* это команда */
               }
               return token_type;
             }

             /* Возврат лексемы во входной поток */
            void putback()
             {

               char *t;

               t = token;
               for(; *t; t++) prog--;
             }

             /* Поиск соответствия внутреннего формата для
                текущей лексемы в таблице лексем.
             */
             look_up(s)
             char *s;
             {
               register int i,j;
               char *p;

               /* преобразование к нижнему регистру */
               p = s;
               while(*p){ *p = tolower(*p); p++; }

               /* просматривается, если лексема обнаружена в
                  таблице */
               for(i=0; *table[i].command; i++)
                 if(!strcmp(table[i].command, s)) return table[i].tok;
               return 0; /* нераспознанная команда */
             }

             /* Возвращает "истину", если "c" разделитель */
             isdelim(c)
             char c;
             {
             if(strchr(" ;,+-<>/*%^=()",c) || c==9 || c=='\r' || c==0)
                 return 1;
               return 0;
             }

             /* Возвращает 1, если "с" пробел или табуляция */
             iswhite(c)
             char c;
             {
               if(c==' ' || c=='\t') return 1;
               else return 0;
             }


          Анализатор поддерживает следующие операторы:  "+", "-", "*",
     "/",  "%",  целочисленный показатель степени (^) и унарный минус.
     Все  эти  операции  могут  использоваться  в сочетании с круглыми
     скобками. Вы, вероятно, заметили, что в программе имеются функции
     шести  уровней,   которые  работают  точно   также  как   функция
     primitive(), вращающая  значение  числа.  Помимо  этих   функций,
     реализующих арифметические операции,  в состав программы включены
     функции arith() и unary(), а также get_token().

          При вычислении выражения prog указывает  на  начало  строки,
     содержащей выражение,  и вызывает get_exp() с адресом переменной,
     в которую вы хотите поместить результат.

          Обратите особое  внимание  на  функцию   serror(),   которая
     используется  для  выдачи  сообщений об ошибках.  При обнаружении
     синтаксической ошибки serror() вызывается с номером этой ошибки в
     качестве  аргумента.  Ошибка  с  кодом  0,  которой соответствует
     сообщение "синтаксическая ошибка",  выдается в том случае,  когда
     тип  ошибки  нельзя определить более конкретно.  В других случаях
     ошибка уточняется.  Заметьте,  что serror() заканчивается вызовом
     функции longjmp().

          Функция logjmp()  выполняет нелокальный переход, возвращаясь
     в  точку,  определенную  с  помощью  функции  setjmp().   Функция
     setjmp()   включена   в  исходный  текст  интерпретатора.  Первый
     аргумент функции logjmp() является буфером  среды, инициированной
     с  помощью  setjmp().  Второй  аргумент  - это значение,  которое
     определяется при передаче управления из setjmp() обратно  в точку
     ее вызова. Как это делается вы, увидите позже.

          Использование ljgjmp()  упрощает  обработку ошибок,  так как
     программы-анализаторы  не   должны   аварийно   завершаться   при
     обнаружении  ошибки.  Если  ваш  компилятор  Си  не  поддерживает
     функции setjmp() и logjmp(),  то каждая функция  при  обнаружении
     ошибок должна  выполнять  возврат  в  точку  возникновения ошибки
     самостоятельно.



                   КАК АНАЛИЗАТОР ОБРАБАТЫВАЕТ ПЕРЕМЕННЫЕ
     -----------------------------------------------------------------

          Как было  сказано  раньше,  интерпретатор  языка SMALL BASIC
     распознает переменные с именами только  от  "A"  до  "Z".  Каждой
     переменной соответствует элемент массива variables, состоящего из
     26 элементов.  Этот массив определен в тексте интерпретатора, как
     показано ниже, и инициализируется нулевыми значениями.

        int variables[26]= {   /* 26 переменных пользователя, A-Z */
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0
        };
          Так как именами переменных являются буквы от "A" до  "Z", то
     индексирование  массива  variables  можно легко осуществить путем
     вычитания из соответствующих  значений  имен  переменных  в  коде
     ASCII кода символа 'A'. Функция find_var(), определяющая значение
     переменной в зависимости от ее имени, представлена ниже.

         /* Определение значения переменной по ее имени*/
         int find_var(s)
         char *s;
         {
           if(!isalpha(*s)){
             serror(4); /* это не переменная */
             return 0;
           }
           return variables[toupper(*token)-'A'];
         }

          Эта функция  допускает использование более длинных имен,  но
     только первая буква имени переменной является значащей.



                      ИНТЕРПРЕТАТОР ЯЗЫКА  SMALL BASIC
     -----------------------------------------------------------------

          Разрабатываемый интерпретатор  будет  распознавать следующие
     ключевые слова языка программирования BASIC:

            PRINT
            INPUT
            IF
            THEN
            FOR
            NEXT
            TO
            GOTO
            GOSUB
            RETURN
            END

          Внутреннее представление этих команд (плюс значение  EOL для
     конца  строки  и  FINISHED  для  сигнализации  о конце программы)
     определяется так:

          #define PRINT   1
          #define INPUT   2
          #define IF      3
          #define THEN    4
          #define FOR     5
          #define NEXT    6
          #define TO      7
          #define GOTO    8
          #define EOL     9
          #define FINISHED 10
          #define GOSUB    11
          #define RETURN   12
          #define END      13

          Для преобразования   внешнего   представления   лексем    во
     внутренний формат используется вспомагательная структура table.

          struct commands { /* Вспомогательная структура ключевых
                               слов анализатора                  */
            char command[20];
            char tok;
          } table[] = { /* Таблица обрабатывает команды, введенные */
            "print",PRINT, /* на нижнем регистре */
            "input",INPUT,
            "if",IF,
            "then",THEN,
            "goto",GOTO,
            "for",FOR,
            "next",NEXT,
            "to",TO,
            "gosub",GOSUB,
            "return",RETURN,
            "end",END,
            "",END  /* mark end of table */
          };

          Обратите внимание на то,  что признак конца  файла  (нулевая
     строка) помещен в конец таблицы.

          Функция look_up() возвращает внутреннее представление каждой
     лексемы или символа '\0', если таковая не обнаружена.

          /* Преобразование каждой лексемы из таблицы лексем
             во внутреннее представление.
          */
          look_up(s)
          char *s;
          {
            register int i,j;
            char *p;
            /* преобразование в символы нижнего регистра */
            p =s;
            while(*p){ *p = tolower(*p); p++; }

            /* если лексема обнаружена в таблице */
            for(i=0; *table[i].command; i++)
                if(!strcmp(table[i].command, s)) return table[i].tok;
            return 0; /* команда не распознана */
          }

          Интерпретатор языка SMALL  BASIC  не  поддерживает  редактор
     текстов,  поэтому  вы  должны создавать программы на языке BASIC,
     используя стандартный текстовый редактор.

          Каждая программа  считывается  и   выполняется   с   помощью
     интерпретатора.  Функция, которая загружает программу, называется
     load_program().


         /* Загрузка программы */
         load_program(p, fname)
         char *p;
         char *fname;
         {
           FILE *fp;
           int i=0;
           if(!(fp=fopen(fname, "rb"))) return 0;

           i = 0;
             do {
                *p = getc(fp);
                p++; i++;
             } while(!feof(fp) && i<PROG_SIZE);
             *(p-2) = '\0'; /* Символ конца загружаемой программы */
             fclose(fp);
             return 1;
           }



                      ОСНОВНОЙ ЦИКЛ РАБОТЫ АНАЛИЗАТОРА
     -----------------------------------------------------------------

          Все интерпретаторы   выполняют   операции  путем  считывания
     лексемы программы и выбора необходимой функции для ее выполнения.
     Основной   цикл  работы  для  интерпретатора  языка  SMALL  BASIC
     выглядит следующим образом.

           do {
             token_type = get_token();
             /* Проверка на соответствие оператору языка */
             if (token_type == VARIABLE) {
               putback(); /* возврат переменной во входной поток */
               assignment(); /* длжен быть оператор присваивания */
             }
             else /* это команда */


               switch(tok) {
                 case PRINT:
                   print();
                   break;
                 case GOTO:
                   exec_if();
                   break;

                 case FOR:
                   exec_for();
                   break;
                 case NEXT:
                   next();
                   break;
                 case INPUT:
                   input();
                   break;
                 case GOSUB:
                   gosub();
                   break;
                 case RETURN:
                   greturn();
                   break;
                 case END:
                   exit(0);
               }
           } while (tok != FINISHED);


          Сначала лексема   считывается  из  программы.  Для  удобства
     анализа каждая лексема располагается на  отдельной  строке.  Если
     лексема является переменной,  то, следуя синтаксису языка, за ней
     должен  следовать   оператор   присваивания   (SMALL   BASIC   не
     поддерживает   старомодную  команду  LET).  В  противном  случае,
     лексема  считается  командой  и  с  помощью  оператора   case   в
     зависимости  от  значения  tok  происходит  выбор соответствующей
     команды. Посмотрите, как работает каждая из них.



               КОМАНДА ПРИСВАИВАНИЯ ЗНАЧЕНИЙ.
     -----------------------------------------------------------------

          В  языке   BASIC  основной   формой  оператора  присваивания
     является следующая:

                        <имя переменной>=<выражение>

          Функция assignment() поддерживает этот тип присваивания.

           /* Присвоить значение переменной */
           assignment()
           {
             int var, value;
             /* получить имя переменной */
             get_token();
               if(!isalpha(*token)) {
                 serror(4); /* это не переменная */
                 return;
               }

               /* поиск индекса переменной в массиве */
               var = toupper(*token)-'A';

               /* считать символ равенства*/
               get_token();
               if(*token!='=') {}
                 serror(3);
                 return;
               }

               /* считать присваемое переменной значение */
               get_exp(&value);

               /* присвоить значение*/
               variables[var] = value;
             }


          Сначала assignment()  считывает лексему из программы.  Это -
     лексема-переменная,  которой должна быть присвоена величина. Если
     лексема  не является переменной,  то сообщается об ошибке.  Затем
     считывается знак равенства (очередная лексема).  Далее вызывается
     функция get_exp(), которая вычисляет значение переменной. Функция
     получается удивительно простой потому, что анализатор выражений и
     get_token делают большую часть рутинной работы.


               КОМАНДА PRINT
     -----------------------------------------------------------------

          Команда PRINT  стандарта  языка  BASIC  достаточно  мощная и
     гибкая,  особенно когда применяется ее формат PRINT  USING.  Хотя
     создание функции, которая реализует все возможности этой команды,
     выходит за рамки этой  главы,  разрабатываемая  функция  является
     наиболее важной.  Вот  основная  форма  команды PRINT языка SMALL
     BASIC:

                         PRINT <список аргумеентов>

     где <список аргументов> представляет собой  перечень  переменных,
     заключенных  в  кавычки  и  разделенных  запятыми  или  точкой  с
     запятой.  Функция print(), представленная ниже, является аналогом
     команды   PRINT   языка  BASIC.  Обратите  внимание,  что  печать
     выполняется в теле цикла do-while,  условием завершения  которого
     является вывод на печать всего списка аргументов команды.


        /* Простейшая версия оператора PRINT */
        void print()
        {
          int answer;
          int len=0, spaces;
          char last_delim;
          do {
               get_token(); /* получить следующий элемент списка */
               if (tok == EOL || tok == FINISHED) break;
               if (token_tipe == QUOTE) { /* это строка */
                   printf(token);
                     len += strlen(token);
                    get_token();
              }
               else { /* это выражение */
                  putback();
                  get_exp(&answer);
                  get_token();
                  len+= printf("%d", answer);
               }
               last_delim = *token;
               if (*token == ';') {
          /* Вычисление числа пробелов при переходе к следующей
             табуляции */
               spaces = 8-(len % 8);
               len += spaces; /* смещение на одну табуляцию */
               while (spaces) {
                 printf(" ");
                 spaces--;
               }
               }
               else if (*token == ','); /* ничего не делать */;
               else if (tok != EOL && tok != FINESHED) serror(0);
               } while (*token == ';' || *token == ',');
               if (tok == EOL || tok == FINESHED) {
                  if (last_delim != ';' && last_delim != ',')
                                                        printf("\n");
                  else serror(0); /* Отсутствует разделитель */
              }

          Команда PRINT может  быть  использована  для  вывода  списка
     переменных  и  строчных  констант  на  экран.  Если  два элемента
     разделены  запятой,  то  их  значения  выводятся  на  печать  без
     пробелов (конкатенируются). Если же два элемента разделены точкой
     с запятой,  то второй элемент  выводится  начиная,  со  следующей
     позиции  табуляции.  Если  список элементов заканчивается запятой
     или точкой с запятой,  то переход на новую строку не выполняется.

          Приведенные ниже  примеры  вызовут  печать  данных  с  новой
     строки:

     PRINT X; Y; "ЭТО СТРОКА"
     PRINT 10 / 4
     PRINT

          Функция print()  использует  функцию  putback() для возврата
     лексемы во входной поток. Причиной этого является то, что прежде,
     чем  начать  печать строки,  заключенной в скобки,  или числового
     выражения,  функция  print()  должна  проанализировать  следующий
     элемент   списка  аргументов.  Если  следующий  элемент  является
     выражением,  то первый терм выражения должен быть помещен обратно
     во  входной  поток,  так  как  в  противном случае анализатору не
     удастся корректно обработать это выражение.



          КОМАНДА INPUT.
     -----------------------------------------------------------------

          В языке   BASIC   команда   INPUT  используется  для  чтения
     информации с клавиатуры и сохранения ее в переменных.  Она  имеет
     два  основных  формата.  Первый  формат  команды  выводит  маркер
     ожидания ввода данных ('?') и переводит всю программу  в ожидание
     ввода данных:

                           INPUT <имя переменной>

          Второй формат   приводит  к  отображению  на  экране  строки
     символов, после чего ожидается ввод данных:
 !
               INPUT "<символьная строка>" <имя переменной>

          Функция input (),  приведенная ниже, реализует команду языка
     BASIC INPUT.

         /* Простейшая версия оператора INPUT */
         void input()
         {
           char str[80], var;
           int i;

           get_token(); /*Анализ наличия символьной строки */
           if (token_type == QUOTE) {
             printf(token); /*Если строка есть, проверка запятой */
             get_token();
             if (*token != ',') serror(1);
             get_token();
           }
           else printf("? "); /* В противном случае отображение "? "*/
      var = toupper(*token)-'A'; /* Вычисление индекса массива имен */
           scanf("%d",&i);   /* Чтение входных данных */
           variables[var] = i;  /* Сохранение их */
         }

          Работа  функции  станет  ясной   и   понятной  после  чтения
     комментариев.



               КОМАНДА GOTO
     -----------------------------------------------------------------

          Сейчас вы увидите реализацию одной из самых  простых команд,
     но в то же время довольно сложной для разработчика. В языке BASIC
     основной формой программного управления является команда  GOTO. В
     стандарте языка BASIC объектом, на который должен указывать GOTO,
     является номер строки.  Этот традиционный подход сохраняется и  в
     языке  SMALL BASIC.  Однако,  SMALL BASIC не требуется нумеровать
     каждую строку.  Номер строки необходим только в том случае,  если
     на  нее  ссылается  команда  GOTO.  Основной  формат команды GOTO
     представлен ниже:

                          GOTO <номер строки>

          Основной сложностью реализации оператора GOTO  является  то,
     что он должен позволять совершать переходы как вниз,  так и вверх
     по  программе.  Для  удовлетворения  этого  требования  необходим
     механизм, который бы просматривал программу, выбирал каждую метку
     и помещал ее в таблицу, содержащую как имя метки так, и указатель
     ее размещения в программе. Такая таблица определена ниже.

          struct label {
            char name[LAB_LEN]; /* имя метки */
            char *p; /* указатель на место размещения в программе */
          };
          struct label label_table[NUM_LAB];

          Функция, которая  просматривает  программу и выбирает каждую
     метку для размещения ее в таблице,  называется scan_labels(). Она
     и основные поддерживающие ее функции приведены ниже.

         /* Поиск всех меток */
         void scan_labels()
         {
           register int loc;
           char *temp;

           label_init();  /* обнуление всех меток */
           temp = prog;   /* запись указателя на начало программы */
           /* Если первая лексема файла является меткой */
           get_token();
           if(token_type==NUMBER) {
             strcpy(label_table[0].name,token);
             label_table[0].p=prog;
           }

           find_eol();
           do {
             get_token();
             if(token_type==NUMBER) {
               loc=get_next_label(token);
               if(loc == -1 || loc == -2) {
                   (loc == -1) ? serror(5):serror(6);
               }
               strcpy(label_table[loc].name, token);
           label_table[loc].p = prog; /* текущий указатель программы*/
             }
             /* Если строка не помечена, переход к следующей */
             if(tok!=EOL) find_eol();
           } while(tok != FINISHED);
           prog = temp; /* восстановить начальное значение*/
         }

         /* Инициализация массива хранения меток.
            По соглашению имя нулевой метки указывает, что
            данная позиция массива не используется  */
         void label_init()
         {
           register int t;
           for(t=0;t<NUM_LAB;++t) lable_table[t].name[0]='\0';
         }
         /* Поиск начала следующей строки */
         void find_eol()
         {
           while (*prog!='\n'  && *prog!='\0') ++prog;
           if (*prog) prog++;
         }

         /* Возвращает индекс следующей свободной позиции в массиве
            меток. Значение -1 указывает на переполнение массива.
            Значение -2 указывает на дублирование имен меток      */
         get_next_label(s)
         char *s;
         {
           register int t;

           for (t=0;t<NUM_LAB;++t) {
             if (label_table[t].name[0] == 0) return t;
             if(!strcmp(label_table[t].name,s)) return -2; /* дубль */
           }
           return -1;
         }


          Функция scan_labels() сообщает о двух типах ошибок. Первый -
     это дублирующие метки.  В языке BASIC (как и в большинстве других
     языков)  не может быть двух одинаковых меток. Второй тип ошибки -
     это  переполнение  таблицы  меток.  Размер  таблицы  определен  с
     помощью макроопределения NUM_LAB. Вы можете изменить его в ту или
     иную сторону.

          Таблица меток строится один раз,  и выполнение перехода GOTO
     выполняется с помощью функции exec_goto(), приведенной ниже.


         /* Реализация оператора GOTO */
         void exec_goto()
         {
           char *loc;

           get_token(); /* получить метку перехода */
           /* Поиск местоположения метки в программе*/
           loc = find_label(token);
           if (loc == '\0')
             serror(7);   /* Метка не найдена  */
           else prog=loc; /*Программа начала выполнятся не с начала*/
         }

         /* Поиск местоположения метки. Ноль возвращается, если метка
            не найдена; в противном случае возвращается указатель на
            место, где расположена метка                            */

         char *find_label(s)
         char *s;
         {
         register int t;

         for (t=0;t<NUM_LAB;++t)
          if (!strcmp(label_tabel[t].name,s)) return label_tabel[t].p;
         return '\0';
         }

          Вспомогательная функция find_label(), получая метку, ищет ее
     в  таблице  меток  и  возвращает указатель на нее.  Если метка не
     обнаружена,  возвращает, значение null. Если адрес не null, то он
     присваивается   переменной  prog,  что  вызывает  выполнение  той
     строки,  которая  была  помечена  меткой.  (Помните  о  том,  что
     указатель  prog  описывает  путь  выполнения считаной программы).
     Если указатель не обнаружен,  то выдается сообщение  о  том,  что
     метка неопределена.



               ОПЕРАТОР IF
     -----------------------------------------------------------------

           Интерпретатор SMALL  BASIC  обрабатывает  оператор   IF   в
     соответствии   со   стандартом   языка   BASIC.  В  SMALL  BASIC,
     отсутствует ELSE и поддерживается только три  условия:  "больше",
     "меньше" или "равно". (Это сделано для того, чтобы вы могли легко
     понять работу этого оператора). Основной формат оператора:

            IF <выражение><оператор><выражение> THEN <оператор>

          Оператор, стоящий  после  THEN,  выполняется  только  в  том
     случае,   если  значение  сравнения  является  истинным.  Функция
     exec_if(),  приведенная ниже,  обеспечивает выполнение этой формы
     оператора IF.

         /* Простейшая реализация оператора IF  */
         void exec_if()
         {
           int x , y, cond;
           char op;
           get_exp(&x); /* получить левое выражение */
           get_token(); /* получить оператор  */
           if (!strchr("=<>", *token)) {
           serror(0);      /* недопустимый оператор  */
           return;
         }
         op=*token;
         get_exp(&y);  /* получить правое выражение */
         /* Определение результата */
         cond=0;
         switch(op) {
             case '=':
           if(x==y) cond=1;
           break;
             case '<':
           if(x<y) cond=1;
           break;
             case '>':
           if(x>y) cond=1;
           break;
         }
         if(cond) {  /* если истина, то поиск нужного IF  */
           get_token();
           if(tok!=THEN) {
              serror(8);
              return;
           }  /* В противном случае программа продолжается со
                   следующей строки  */
         }
         else find_eol(); /* поиск строки продолжения программы */
       }

          Функция exec_if() выполняется следующим образом:
         1. Вычисляется значение левого выражения.
         2. Считывается оператор сравнения.
         3. Вычисляется величина правого выраженния.
         4. Выполняется операция сравнения.
         5. Если условие является истиной, то выполняется поиск  THEN;
            в  противном случае, find_eol  выполняет переход на начало
            следующей строки.



               ЦИКЛ FOR
     -----------------------------------------------------------------

          Проблема обработки  интерпретатором  оператора  цикла   FOR,
     входящего  в  состав  оператора  BASIC,  решена  в  нашем  случае
     довольно  оригинально.  Основной  формат  оператора   цикла   FOR
     следующий:

      FOR<имя управляющей переменной>=<нач. значение>TO<кон. значение>
          .
          .
          .
        последовательность операторов
          .
          .
          .
       NEXT

          Версия оператора  FOR,  поддерживаемая интерпретатором SMALL
     BASIC,  реализует цикл с положительным проращением  равным  1  на
     каждую итерацию цикла. Параметр STEP не поддерживается.

          В языке   BASIC,   точно  также  как  и  в  Cи,  допускается
     вложенность цикла FOR.  Основной изюминкой,  при реализации этого
     оператора,  с  точки зрения программиста-профессионала,  является
     сохранение информации о каждом  вложенном  цикле  со  ссылкой  на
     внешний   цикл.   Для  реализации  этой  маленькой,  но  все-таки
     заковырки      (трудности      всегда      радуют       настоящих
     программистов-мужчин),  используется стековая структура,  которая
     работает следующим образом:  Начало цикла,  информация о значении
     управляющей  переменной  цикла  и  ее конечном значении,  а также
     место расположения цикла  в  теле  программы  заносятся  в  стек.
     Каждый раз,  при достижении оператора NEXT,  из стека извлекается
     информация о значении управляющей переменной,  затем ее  значение
     пересчитывается  и сравнивается с конечным значением цикла.  Если
     значение управляющей переменной цикла достигло  своего  конечного
     значения,  выполнение  цикла  прекращается и выполняется оператор
     программы следующий за оператором NEXT.  В  противном  случае,  в
     стек  заносится  новая информация и выполнение цикла начинается с
     его начала.  Таким  же  образом  обеспечивается  интерпретация  и
     выполнение вложенных циклов.  В стекоподобной структуре вложенных
     циклов каждый FOR должен быть закрыт  соответствующим  оператором
     NEXT.

          Для  реализации  оператора  цикла  FOR   стек  должен  иметь
     следующую структуру:

          struct for_stack {
               int var; /* счетчик цикла */
               int target; /* конечное значение */
               char *loc;
          } fstack[FOR_NEST]; /* стек для цикла FOR/NEXT */
          int ftos; /* индекс начала стека FOR */

          Значение макроса  FOR_NEST  ограничивает уровень вложенности
     цикла.  (По  умолчанию  допускается  25   уровней   вложенности).
     Переменная ftos всегда имеет значение индекса начала стека.

          Для обработки  стека  вам  понадобятся две функции fpush() и
     fpop(), которые приведены ниже.

                /* Поместить элемент в стек */
          void fpush(i)
          struct for_stack i;
          {
               if (ftos > FOR_NEST)
                    serror(10);

               fstack[ftos]=i;
               ftos++;
          }

          struct for_stack fpop()
          {
               ftos--;
               if (ftos < 0) serror(11);
               return(fstack[ftos]);
          }


          Итак, после  того,  как вы получили возможность ознакомиться
     со всеми необходимыми вспомогательными функцмями, приведем полный
     текст функции, реализующей оператры FOR и NEXT.


          /* Простейшая реализация оператора цикла FOR */
          void exec_for()
          {
               struct for_stack i;
               int value;

               get_token(); /* чтение управляющей переменной */
               if (!isalfa(*token)) {
                    serror(4);
                    return;
               }

               i.var=toupper(token) - 'A'; /* сохраним индекс */

               get_token(); /* чтение символа равенства */
               if (*token != '=') {
               serror(3);
               return;
               }

               get_exp(&value); /* получить начальное значение */

               variables[i.var] = value;

               get_token();
               if (tok != TO) serror(9); /* чтение и анализ TO */

               get_exp(&i.target); /* получить конечное значение */

     /* Если цикл выполняется последний раз, поместить информацию
        в стек*/
               if (value >= variables[i.var]) {
                    i.loc = prog;
                    fpush(i);
               }
               else { /* пропустить весь цикл целиком */
                    while(tok != NEXT) get_token();
               }
             }

      /* Выполнение оператора NEXT */
          void next()
          {
              struct for_stack i;

              i = fpop(); /* чтение информации о цикле */

              variables[i.var]++; /* увеличение переменной цикла */
              if (variables[i.var] > i.target) return; /* конец */
              fpush(i); /* в противном случае запомнить информацию */
              prog = i.loc; /* цикл */
          }


          Как именно  работает  эта  подпрограмма,  вполне   ясно   из
     комментариев к ней.  Следует заметить,  что анализ на возможность
     выхода  из  цикла  по  оператору  GOTO   в   данном   случае   не
     выполняется. Поэтому   использование  GOTO  в  теле  цикла  может
     привести  к  искажению  содержимого  стека,  что   вобщем-то   не
     желательно.

          Решение проблемы  реализации  цикла FOR с помощью применения
     стековых  структур  является,  в  общем  случае,   типичным   для
     реализации  циклических конструкций.  Так как интерпретатор SMALL
     BASIC не поддерживает другие типы циклических конструкций,  то вы
     можете  самостоятельно разработать подпрограммы реализации циклов
     WHILE и DO-WHILE.  Как вы сможете увидеть в следующем  параграфе,
     стековые   структуры   ипользуются   при   реализации   и  других
     конструкций программирования, допускающих вложенность.



               ОПЕРАТОР GOSUB.
     -----------------------------------------------------------------

          Хотя BASIC   не   поддерживает  отдельные  подпрограммы,  но
     имеется возможность вызвать отдельные части программы  с  помощью
     оператора  GOSUB  и  вернутся  из нее с помощью оператора RETURN.
     Основной формой GOSUB-RETURN является следующая:

     GOSUB <номер строки>
             .
             .
             .
             <номер строки>
             .
             тело подпрограммы
             .
             .
     RETURN

          Вызов подпрограммы  требует  использования стека.  Очевидно,
     что это реализовать в данном случае проще,  чем для оператора FOR
     потому,  что  каждому  оператору RETURN соответствует свой GOSUB.
     Описание стека GOSUB показано ниже.

         char *gstack[SUB_NEST]; /* стек подпрограмм */
         int gtos; /* индекс верхней части стека  */

          Функция gosub() и вспомогательные программы приведены ниже.

         /* Простейшая реализация оператора GOSUB  */
         void gosub()
         {
           char *loc;

           get_token();
           /* поиск метки обращения */
           loc = find_label(token);
           if(loc=='\0')
             serror(7); /* метка не найдена */
           else {
             gpush(prog); /* запомним место, куда надо вернуться */
             prog = loc; /* старт программы с точки loc */
           }
         }

         /*  Возврат из подпрограммы */
         void greturn()
         {
           prog = gpop();
         }

         /* Поместить элемент в стек операторов GOSUB (подпрограмм) */
         void gpush(s)
         char *s;
         {
           gtos++;
           if(gtos == SUB_NEST) {
             serror(12);
             return;
           }
           gstack[gtos]=s;
         }

      /* Вытолкнуть элемент из стека операторов GOSUB (подпрограмм) */
         char *gpop()
         {
           if(gtos==0) {
             serror(13);
             return;
           }
           return(gstack[gtos--]);
         }

          Команда GOSUB  работает следующим образом.  Текущее значение
     prog помещается в стек  GOSUB.  Затем  prog  присваивается  адрес
     строки,   с   которой   начинается   подпрограмма,  и  начинается
     выполнение подпрограммы. Когда встречается RETURN, из стека GOSUB
     выталкивается  очередное  значение  и  присваивается prog.  Далее
     выполнение  продолжается  со  следующей  строки  после  оператора
     GOSUB. Оператор GOSUB допускает вложенность.



                        ПОЛНЫЙ ФАЙЛ ИНТЕРПРЕТАТОРА.
     -----------------------------------------------------------------

           Все тексты SMALL  BASIC,  исключая  тексты  синтаксического
     анализатора    выражений,    приведены   ниже.   Вам   необходимо
     откомпилировать  файлы  интерпретатора  и  анализатора,  а  затем
     отредактировать их.

        /* Минимальный BASIC-интепретатор */
        #include "stdio.h"
        #include "setjmp.h"
        #include "math.h"
        #include "ctype.h"
        #include "stdlib.h"

        #define NUM_LAB 100
        #define LAB_LEN 10
        #define FOR_NEST 25
        #define SUB_NEST 25
        #define PROG_SIZE 10000

        #define DELIMITER 1
        #define VARIABLE  2
        #define NUMBER    3
        #define COMMAND   4
        #define STRING    5
        #define QUOTE     6

        #define PRINT 1
        #define INPUT 2
        #define IF    3
        #define THEN  4
        #define FOR   5
        #define NEXT  6
        #define TO    7
        #define GOTO  8
        #define EOL   9
        #define FINISHED 10
        #define GOSUB 11
        #define RETURN 12
        #define END   13

        char *prog; /* содержит выражение для анализа */
        jmp_buf e_buf; /* содержит сртеду для longjmp() */

        int variables[26]= {   /* 26 переменных пользователя A - Z */
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0
        };

          struct commands { /* Просмотр таблицы ключевых слов */
            char command[20];
            char tok;
          } table[] = { /* Команда должна вводится прописными */
            "print",PRINT, /* буквами в эту таблицу */
            "input",INPUT,
            "if",IF,
            "then",THEN,
            "goto",GOTO,
            "for",FOR,
            "next",NEXT,
            "to",TO,
            "gosub",GOSUB,
            "return",RETURN,
            "end",END,
            "",END  /* Маркер конца таблицы */
          };

          char token[80];
          char token_type, tok;

          struct label {
            char name[LAB_LEN];
            char *p; /*      */
          };
          struct label label_table[NUM_LAB];

          char *find_label(), *gpop();

          struct for_stack {
            int var; /* переменная счетчика */
            int target; /* конечное значение */
            char *loc;
          } fstack[FOR_NEST]; /* стек цикла FOR/NEXT */
          struct for_stack fpop();

          char *gstack[SUB_NEST]; /* стек оператора GOSUB */
          int ftos; /* индекс начала стека FOR */
          int gtos; /* индекс начала стека GOSUB */

          void print(), scan_labels(), find_eol(),exec_goto();
          void exec_if(), exec_for(), next(), fpush(), input();
          void gosub(), greturn(), gpush(), label_init();

          main(argc, argv)
          int argc;
          char *argv[];
          {
            char in[80];
            int answer;
            char *p_buf;
            char *t;

            if(argc!=2) {
              printf("Используйте формат: run <filename>\n");
              exit(1);
            }

            /* Выделение памяти для программы */
            if (!(p_buf=(char *) malloc(PROG_SIZE))) {
              printf("Ошибка при выделении памяти ");
              exit(1);
            }

            /* Загрузка программы для выполнения */
            if(!load_program(p_buf,argv[1])) exit(1);
            if(setjmp(e_buf)) exit(1); /* инициализация буфера
                                          нелокальных переходов */
            prog = p_buf;
            scan_labels(); /* поиск метки в программе */
            ftos = 0; /* инициализация индеса стека FOR */
            gtos = 0; /* инициализация индеса стека GOSUB */
           do {
             token_type = get_token();
             /* проверка на оператор присваивания */
             if(token_type==VARIABLE) {
               putback(); /* возврат пер. обратно во входной поток */
               assignment(); /* должен быть оператор присваивания */
             }
             else /* это команда */
               switch(tok) {
                 case PRINT:
                   print();
                   break;
                 case GOTO:
                   exec_if();
                   break;
                 case FOR:
                   exec_for();
                   break;
                 case NEXT:
                   next();
                   break;
                 case INPUT:
                   input();
                   break;
                 case GOSUB:
                   gosub();
                   break;
                 case RETURN:
                   greturn();
                   break;
                 case END:
                   exit(0);
               }
           } while (tok != FINISHED);
         }

         /* Загрузка программы. */
         load_program(p, fname)
         char *p;
         char *fname;
         {
           FILE *fp;
           int i=0;
           if(!(fp=fopen(fname, "rb"))) return 0;

           i = 0;
             do {
                *p = getc(fp);
                p++; i++;
             } while(!feof(fp) && i<PROG_SIZE);
             *(p-2) = '\0'; /* символ конца программы */
             fclose(fp);
             return 1;
           }

           /* Присваивание переменной значения */
           assigment()
           {
             int var, value;
             /* Получить имя переменной */
             get_token();
               if(!isalpha(*token)) {
                 serror(4); /* это не переменная */
                 return;
               }

               /* вычисление индекса переменной */
               var = toupper(*token)-'A';

               /* получить знак равенства */
               get_token();
               if(*token!='=') {
                 serror(3);
                 return;
               }

               /* получить значение, присваемое переменной */
               get_exp(&value);

               /* присвоить это значение */
               variables[var] = value;
             }

             /* Простейшая реализация оператора PRINT */
             void print()
             {
               int answer;
               int len=0, spaces;
               char last_delim;

               do {
                 get_token(); /* получить следующий элемент списка  */
                 if(tok==EOL || tok==FINISHED) break;
                 if(token_type==QUOTE) { /* это строка */
                   print(token);
                   len += strlen(token);
                   get_token();
                 }
                 else { /* это выражение */
                   putback();
                   get_exp(&answer);
                   get_token();
                   len +=printf("%d", answer);
                 }
                 last_delim = *token;

                 if(*token==';') {
     /* вычисление числа пробелов при переходе к следующей табуляции*/
                   spaces= 8- (len % 8);
                   len += spaces; /* включая позицию табуляции  */
                   while(spaces) {
                     print(" ");
                     spaces--;
                   }
                 }
                 else if(*token==','); /* ничего не делать */
                 else if(tok!=EOL && tok!=FINISHED)  serror(0);
               } while (*token == ';' || *token == ',');

              if(tok==EOL || tok==FINISHED) {
              if(last_delim != ';' && last_delim != ',') printf("\n");
              }
               else serror(0); /* отсутствует ',' или ';'  */
             }
             /* Поиск всех меток */
             void scan_labels()
             {
               int addr;
               char *temp;

             label_init();  /* обнуление всех меток */
             temp = prog; /* сохраним указатель на начало программы*/
               /* Если первая лексема файла есть метка  */
               get_token();
               if(token_type==NUMBER) {
                 strcpy(label_table[0].name,token);
                 label_table[0].p=prog;
               }

               find_eol();
               do {
                 get_token();
                 if(token_type==NUMBER) {
                   addr =get_next_label(token);
                   if(addr==-1 || addr==-2) {
                       (addr==-1) ?serror(5):serror(6);
                   }
                   strcpy(label_table[addr].name, token);
         label_table[addr].p = prog; /* текущий указатель программы */
                 }
                 /* если строка не помечена, то поиск следующей */
                 if(tok!=EOL) find_eol();
               } while(tok!=FINISHED);
               prog = temp; /* сохраним оригинал */
             }

             /* Поиск начала следующей строки */
             void find_eol()
             {
               while(*prog!='\n'  && *prog!='\0') ++prog;
               if(*prog) prog++;
             }

             /* Возвращает индекс ена следующую свободную позицию
                массива меток. -1, если массив переполнен.
                               -2, если дублирование меток. */

             get_next_label(s)
             char *s;
             {
               register int t;

               for(t=0;t<NUM_LAB;++t) {
                 if(label_table[t].name[0]==0) return t;
              if(!strcmp(label_table[t].name,s)) return -2; /*дубль*/
               }

               return -1;
             }

         /* Поиск строки по известной метке. Значение 0 возвращается,
            если метка не найдена; в противном случае возвращается
            указатель на помеченную строку программы        */

             char *find_label(s)

             char *s;
             {
               register int t;

               for(t=0; t<NUM_LAB; ++t)
           if(!strcmp(label_table[t].name,s)) return label_table[t].p;
               return '\0'; /* состояние ошибки */
             }

             /* Реализация оператора GOTO */
             void exec_goto()
             {
               char *loc;

               get_token(); /* получить метку перехода */
               /* Поиск местоположения метки */
               loc = find_label(token);
               if(loc=='\0')
                 serror(7);   /* метка не обнаружена  */
               else prog=loc; /* старт программы с указанной точки  */
             }

          /* Инициализация массива хранения меток. По договоренности
          нулевое значение метки символизирует пустую ячейку массива */
             void label_init()
             {
             register int t;

             for(t=0; t<NUM_LAB; ++t) label_table[t].name[0]='\0';
           }

             /* Реализация оператора IF  */
             void exec_if()
             {
               int x , y, cond;
               char op;
               get_exp(&x); /* получить левое выражение */
               get_token(); /* получить оператор */
               if(!strchr("=<>", *token)) {
               serror(0);      /* недопустимый оператор */
               return;
             }
             op=*token;
             get_exp(&y);  /* получить правое выражение */
             /* Определение результата */
             cond=0;
             switch(op) {
                 case '=':
               if(x==y) cond=1;
               break;
                 case '<':
               if(x<y) cond=1;
               break;
                 case '>':
               if(x>y) cond=1;
               break;
             }
             if(cond) {  /* если значение IF "истина"  */
               get_token();
               if(tok!=THEN) {
                  serror(8);
                  return;
              } /* иначе, программа выполняется со следующей строки */
             }
             else find_eol(); /* поиск точки старта программы */
           }

           /* Реализация цикла FOR */
           void exec_for()
           {
             struct for_stack i;
             int value;

             get_token(); /* получить управляющую переменную */
             if(!isalpha(*token)); {
               serror(4);
               return;
             }
             i.var=toupper(*token)-'A'; /* сохранить ее индекс */
             get_token(); /* получить знак равенства */
             if(*token!='=') {
               serror(3);
               return;
             }
             get_exp(&value); /* получить начальное значение  */
             variables[i.var]=value;

             get_token();
             if(tok!=TO) serror(9); /* если нее нашли TO */
             get_exp(&i.target); /* получить конечное значение */

             /* Если цикл выполняется последний раз, поместить
                информацию в стек  */
             if(value>=variables[i.var]) {
               i.loc = prog;
               fpush(i);
             }
             else /* пропустить весь цикл */
               while(tok!=NEXT) get_token();
           }

           /* Реализация оператора NEXT */
           void next()
           {
             struct for_stack i;
             i = fpop(); /* чтение информации о цикле */

            variables[i.var]++; /* увеличение управляющей переменной*/
             if(variables[i.var]>i.target) return; /* конец цикла */
             fpush(i); /* иначе, сохранить информацию в стеке */
             prog = i.loc; /* цикл */
           }

           /* Поместить информацию в стек FOR */
           void fpush(i)
           struct for_stack i;
           {
             if(ftos>FOR_NEST)
             serror(10);
           fstack[ftos]=i;
           ftos++;
         }

         struct for_stack fpop()
         {
           ftos--;
           if(ftos<0) serror(11);
           return(fstack[ftos]);
         }

         /* Реализация оператора INPUT */
         void input()
         {
           char str[80], var;
           int i;

      get_token(); /*просматривается если существует строка символов*/
           if(token_type==QUOTE) {
          printf(token); /* если да, то ее печать и контроль ',' */
             get_token();
             if(*token!=',') serror(1);
             get_token();
           }
           else printf("? "); /* выдача строки по умолчанию */
       var = toupper(*token)-'A'; /* получить индекс имени переменной*/
           scanf("%d",&i);   /* чтение ввода данных */
           variables[var] = i;  /* сохранение данных */
         }

         /* Реализация оператора GOSUB */
         void gosub()
         {
           char *loc;

           get_token();
           /* поиск метки вызова */
           loc = find_label(token);
           if(loc=='\0')
             serror(7); /* метка не определена */
           else {
             gpush(prog); /* запомним место, куда вернемся */
             prog = loc; /* старт программы с указанной точки */
           }
         }

         /* Возврат из подпрограммы, вызвынной по GOSUB */
         void greturn()
         {
           prog = gpop();
         }

         /* Помещает данные в стек GOSUB */
         void gpush(s)
         char *s;
         {
           gtos++;
           if(gtos==SUB_NEST) {
             serror(12);
             return;
           }
           gstack[gtos]=s;
         }

         /*   */
         char *gpop()
         {
           if(gtos==0) {
             serror(13);
             return;
           }
           return(gstack[gtos--]);
         }



              ПРИМЕР ИСПОЛЬЗОВАНИЯ ИНТЕРПРЕТАТОРА  SMALL BASIC
     -----------------------------------------------------------------

          Теперь вы  можете  запускать   простейшие   BASIC-программы.


         PRINT "Эта программа демонстрирует все команды."
         FOR X = 1 TO 100
         PRINT X, X/2; X, X*X
         NEXT
         GOSUB 300
         PRINT "Привет"
         INPUT H
         IF H<11 THEN GOTO 200
         PRINT 12-4/2
         PRINT 100
         200 A = 100/2
         IF A>10 THEN PRINT "Все нормально"
         PRINT A
         PRINT A+34
         INPUT H
         PRINT H
         INPUT "Это тест",y
         PRINT H+Y
         END
         300 PRINT "Это подпрограмма"
             RETURN



         PRINT "Эта подпрограмма демонстрирует вложенный GOSUB"
         INPUT "Введите число: ", i
         GOSUB 100

         END

         100 FOR T = 1 TO I
           X = X+I
           GOSUB 150
         NEXT
         RETURN

         150 PRINT X;
             RETURN


         print "Эта подпрограмма вычисляет объем куба "
         input "Введите длину парвой стороны: ", l
         input "Введите длину второй стороны: ", w
         input "Введите длину третей стороны: ", d
         t = l * w * d
         print "Обьем равен: ", t


         PRINT "Эта программа демонстрирует вложенные циклы"
         FOR X = 1 TO 100
          FOR Y = 1 TO 10
            PRINT X; Y; X*Y
          NEXT
         NEXT



                  РАСШИРЕНЕИЕ ВОЗМОЖНОСТЕЙ ИНТЕРПРЕТАТОРА
     -----------------------------------------------------------------

          Основным пунктом  расширения  функций  интерпретатора  и  их
     модификации  является  ограниченность   его   лишь   возможностью
     интерпретировать язык BASIC.  Основная масса технических приемов,
     описанных  в  этой  главе,  может  использоватся   при   создании
     интерпретаторов      для     различных     процедурных     языков
     программирования.  Потому вы, в принципе, можете разработать свой
     язык,  учитывающий  ваш  взгляд  на  программирование и ваш стиль
     программирования.

          Дополнительные команды и соответствуюшие им основные форматы
     лексем   описаны   в  этой  главе.  Для  использования  различных

     дополнительных типов переменных вы  должны  использовать  массивы
     структур  для  хранения  таких  переменных;  одно  из  полей этой
     структуры должно индицировать тип переменной,  а  остальные  поля
     предназначены   для   хранения   значений  этих  переменных.  Для
     использования  строчных  переменных  вам  необходимо   установить
     таблицу  строк.  Простейшим  путем реализации строк фиксированной
     длины является использование фиксированных участков памяти  в 255
     байт для размешения строк.

          И последняя   мысль:  типы  операторов,  которые  вы  можете
     интерпретировать, ограничены лишь вашей фантазией.



                                  ГЛАВА 8
                                  -------

                О МАНИПУЛИРОВАНИИ ЭКРАНОМ И ГЕНЕРАЦИИ ЗВУКА
     -----------------------------------------------------------------

          На всем протяжении этой книги мы касались,  в основном,  тех

     аспектов  программирования  на  Си,  которые могут заинтересовать
     профессиональных   программистов,    чье     основное     занятие
     программирование   на   Си.  Так  как  возможности  программы  по
     взаимодействию    с    пользователем     часто     ограничиваются
     возможностями,   представленными   в   рамках   пользовательского
     интерфейса,  то в этой главе содержатся завершенные сведения, так
     сказать,    окончательная   точка   зрения   на   возможность   и
     целесообразность манипулирования с экраном дисплея при разработке
     пользовательского  интерфейса.  Основное  внимание  в  этой главе
     уделяется вопросам  отображения  различных  фрагментов  текста  в
     разных   цветах.   Дополнительно  в  этой  главе  рассматриваются
     некоторые  другие  вопросы   программирования   пользовательского
     интерфейса   такие,   как  изменение  размера  и  формы  курсора,
     скроллинг (прокрутка) части текста, сохранение содержимого экрана
     в   виде   дискового  файла.  Использование  со  вкусом  звуковых
     возможностей компьютера позволяет в значительной  мере  "оживить"
     работу  пользователя  с  вашей программой,  а также акцентировать
     внимание пользователя на ряде моментов и ситуаций, возникающих во
     время работы. В связи с этим в главу включен параграф, поясняющий
     возможности пользователя по генерации звуков различных  частот  и
     созданию  различных  звуковых  эффектов с использованием динамика
     компьютера.

          Подпрограммы, описанные    в    этой     главе,     являются
     машинно-зависимыми.  Они могут функционировать на IBM PC, XT, AT,
     PS/2 и совместимых с ними  моделях.  Большинство  из  подпрограмм
     требуют  наличия в вашей конфигурации компьютера цветного дисплея
     (адаптера).  Если вы имеете  несовместимый  с  вышеперечисленными
     моделями компьютер, то вам необходимо будет внести в подпрограммы
     соответствующие изменения.



                ИСПОЛЬЗОВАНИЕ ЦВЕТА В ТЕКСТОВОМ РЕЖИМЕ
     -----------------------------------------------------------------

          Ранее вы    могли   видеть   великолепные,   профессионально
     написанные программы, которые не используют цветовые возможности.
     Как   вы  уже  уяснили  из  Главы  1,  семейство  компьютеров  PC
     поддерживает  различные  видеорежимы.  Если  вы  имеете  в  своей
     системе  цветной  адаптер,  режим  работы  которого  по умолчанию
     установлен равным 3,  то это означает, что специфицирован цветной
     режим   отображения   текста  80*25  строк.  По  умолчанию  текст
     отображается на экране в белом цвете, однако, имеется возможность
     отображать текст в других цветах.



          Атрибутный байт текстового режима.
          ----------------------------------

          Каждый символ отображается на экране  дисплея в соответствии
     с его атрибутным байтом,   определяющим  как  именно отображается
     символ (см.  главу 1).  Если компьютер  включает  в  себя цветной
     адаптер,  работающий в видеорежиме, определяемом значением 3,  то
     соответствующее   значение  атрибутного   байта  определяет  цвет
     отображаемого  символа,   цвет фона,  интенсивность   отображения
     символа (уровень  яркости),  а также устанавливает  или  отменяет
     режим  мерцания  символа.  Состав  атрибутного   байта  показан в
     Таблице 8.1.

          Биты 0,  1 и 2 атрибутного байта определяют компоненты цвета
     символа. Например, если установлен бит 0 (значение бита равно 1),
     то символ отображается в голубом цвете.  Если значение всех  этих
     битов   не   установлено,   то  символ  является  неотображаемым.
     Запомните,  что цвета накладываются друг на друга.  Если значения
     всех  этих  битов  установлены  (равны 1),  символ отображается в
     белом цвете.  Если вы установили значения двух из этих битов,  то
     будет генерирован либо ярко-красный, либо голубой (циановый) цвет
     символа.  Биты с 4 по 6 используются для  установки  цвета  фона.
     Если  значение этих битов не установлено (равно 0),  то цвет фона
     будет  черным,  в  противном  случае  цвет  фона  определяется  в
     соответствии со специфицированным значением битов.

          На заре  микрокомпьютеров  режимом,  в котором видеосистемой
     отображались символы по  умолчанию,  был  режим  полной  яркости,
     однако  наряду  с  этим  режимом  имелась  возможность отображать
     символы в режиме пониженной  яркости.  После  реализации  IBM  PC
     пользователю  был  предложен  альтернативный  путь:  По умолчанию
     отображение символов  видеосистемой  PC  выполняется   в   режиме
     "нормальной" яркости, но вы имеете возможность отображать символы
     в  режиме  повышенной  яркости,  устанавливая  значение   1   для
     соответствующего бита атрибутного байта (бита повышенной яркости)
     В добавок ко всему вы можете установить режим  мерцания  символа,
     установив значение соответствующего бита.


     Таблица 8-1.
     ------------
     Состав атрибутного байта при работе в 3 видеорежиме
     _________________________________________________________________

          Бит            Устанавливаемое значение

          0               Голубой цвет символа
          1               Зеленый цвет символа
          2               Красный цвет символа
          3               Повышенная яркость символа
          4               Голубой цвет фона
          5               Зеленый цвет фона
          6               Красный цвет фона
          7               Мерцание символа
     _________________________________________________________________


          В предыдущих параграфах были  рассмотрены  функции,  которые
     выполняли считывание  символов  на экран,  используя при этом как
     обращение к BIOS,  так и непосредственный доступ  к  видеопамяти.
     Непосредственный   доступ   к  видеопамяти  является  необходимым
     условием   повышения   скорости   реакции   задач   на   действия
     пользователя. Однако   непосредственный   доступ   к  видеопамяти
     значительно  снижает  возможность  переносимости   программ   (их
     мобильность),    а   также   является   серьезной   помехой   при
     использовании программ  в  мультизадачных  операционных  системах
     типа  OS/2.  Функции,  рассматриваемые  в этой главе,  используют
     возможности BIOS и видеопамяти по той причине,  что сами по  себе
     эти функции более мобильны и,  в конечном итоге, для ускорения их
     быстродействия обычно не требуется стандартный вывод  на дисплей.
     Следует отметить,  что интуитивно использование непосредственного
     доступа к видеопамяти является более предпочтительным.


          Отображение строки в определенном цвете.
          ----------------------------------------

          Отображение строки в определенном цвете  не  является  столь
     трудной задачей, как вам может казаться на первый взгляд, если вы
     используете функции записи символа,  которые используют,  в  свою
     очередь,  возможности  BIOS  и  видеопамяти (ROM-BIOS).  ROM-BIOS
     прерывание 10Н,  функция 9 позволяет  отобразить  текущий  символ
     (один!) в позиции курсора и его атрибуты. Проблема состоит лишь в
     перемещении курсора по записываемой вами строке,  но  это  должна
     осуществлять непосредственно ваша подпрограмма.

          В соответствии с  этим  возникает,  во-первых, необходимость
     определения текущей  позиции  курсора.  Для  этого   используется
     функция   read_cursor_xy(),   представленная  ниже.  Эта  функция
     использует ROM-BIOS-прерывание 10Н, функцию 3, для чтения текущих
     координат  позиции  курсора  X  и  Y.  Координаты позиции курсора
     возвращаются в качестве значений аргументов функции.

          /* Чтение текущих координат позиции курсора */
     void read_cursor_xy(x,y)
     char *x,*y;
     {
          union REGS r;

          r.h.ah = 3;  /* чтение текущей позиции курсора */
          r.h.bh = 0;  /* видеостраница */
          int86(0x10,&r,&r);
          *y = r.h.dl;
          *x = r.h.dh;
     }

          После определения   координат   текущей   позиции   курсора,
     функция, которая  выполняет  печать  строки,  должна  осуществить
     перемещение курсора к следующему символу,  с тем, чтобы используя
     ROM-BIOS-прерывание  напечатать  его.  Для  перемещения   курсора
     целесообразно  использовать  функцию goto_xy(),  которая была уже
     рассмотрена ранее и приводится в этой главе для полноты изложения
     материала.

          /* Перемещение курсора в позицию, специфицированную
             координатами X и Y
          */
     void goto_xy (x,y)
     int x,y;
     {
            union REGS r;

            r.h.ah = 2; /* функция адресации курсора */
            r.h.dl = x; /* координата столбца */
            r.h.dh = y; /* координата строки */
            r.h.bh = 0; /* видеостраница */
            int86(0x10,&r,&r);
     }

          Функция color_puts(),   представленная   ниже,    отображает
     специфицированную пользователем строку в указанном цвете.

          /* Печать строки в цвете   */
     void color_puts(s,color)
     char *s;  /* строка */
     char color; /* цвет строки */
     {
           union REGS r;
           char x,y;
           read_cursor_xy(&x,&y); /* получение текущей позиции курсора
                           */
           while (*s) {
           if (*s == '\n') {  /* обработка символа новой строки */
               printf("\n");
               s++;
               x = 0; y++;  /* переход на следующую строку */
               continue;
      }
         r.h.ah = 9; /* функция отображения символа и его атрибутов */
         r.h.al = *s++;    /* отображаемый символ */
         r.h.bl = color;   /* атрибуты цвета */
         r.h.bh = 0;       /*видеостраница 0 */
         r.x.cx = 1; /* отобразить за единицу времени ( такт ) */
          int86(0x10,&r,&r);
          x++;
          goto_xy(x,y); /* перемещение курсора */
      }
     }

          Как вы можете видеть,  отображаемый  символ  запоминается  в
     регистре  AL,  атрибуты  цвета  символа  -  в регистре BL,  номер
     видеостраницы - в регистре BH,  а количество  интервалов  времени
     (тактов  процессора),  за  которое  будет  отображен  символ  - в
     регистре CX.  Заметим, что функция также обрабатывает специальный
     символ   новой  строки  ('\n').  Вы  можете  также,  по  желанию,
     организовать обработку символов табуляции ('\t'), двойных кавычек
     (") и других специальных символов.

          Использование функции color_puts() предполагает наличие ряда
     макроопределений в начале вызывающей  функцию программы. Перечень
     макроопределений представлен ниже

            #define BLUE             1
            #define GREEN        2
            #define RED             4
            #define INTENSE      8
            #define BLUE_BACK    16
            #define GREEN_BACK   32
            #define RED_BACK     64
            #define BLINK        128

          Используя эти макросы, вы можете по своему усмотрению выдать
     на экран строку текста на фоне установленного вами цвета, а также
     саму строку в определенном вами цвете.  Вы можете также управлять
     режимом отображения  строки  (повышенная  яркость  или мерцание).
     Комбинируя цвета,  режимы мерцания  или  повышенной  яркости  для
     одного  или  совокупности  символов,  вы  можете  добиться любого
     желаемого вами  эффекта.  Например,  представленная  ниже  строка
     программы приведет  к отображению строки "А это - текст" в режиме
     повышенной яркости в голубом (циановом) цвете:

          color_puts("А это - текст",GREEN | RED | INTENSE );


          Использование цвета.
          --------------------

          Довольно эффективно  использование  многоцветного  текста  в
     различных   приложениях.  Во  всяком  случае  многоцветный  текст
     смотрится всегда намного эстетичней,  чем монохромный. Однако при
     использовании   многоцветного  текста  необходимо  придерживаться
     следующих основных положений:

          - Избегайте использования "нестандартных"  цветов.  Наиболее
     общим  лучшим  вариантом  является отображение белых с имволов на
     черном фоне.  Предпочтительнее вместо отображения какой-то важной
     информации  в контрастном цвете отображать ее в режиме повышенной
     яркости.

          - Наиболее  эффективным признано использование цветных рамок
     экрана и окон.

          - В   ряде   ситуаций   полезным   оказывается   отображение
     отрицательного остатка  (например,  денежной  суммы)  в   красном
     цвете.

          - Отображение  текущей  строки  (или части текущей строки) в
     контрастном цвете является,  пожалуй,  лучшим  приемом  индикации
     положения  действий  пользователя  на  экране  в  текущий  момент
     времени.




                         ИЗМЕНЕНИЕ РАЗМЕРА КУРСОРА
     -----------------------------------------------------------------

          Большинство пользователей  даже  не  представляют  насколько
     велики  возможности  семейства  машин  IBM PC.  В частности,  они
     позволяют  изменять   размер   курсора.   По   умолчанию   курсор
     отображается  в виде одной мерцающей строчки (развертки дисплея).
     Однако пользователь может варьировать размером курсора  от  одной
     строки  развертки дисплея до полного размера (высоты) символа.  В
     цветном текстовом режиме курсор может иметь  высоту  от  0  до  8
     строк развертки.  (В монохромном режиме курсор может иметь высоту
     от 0 до 14 строк развертки,  однако в данном параграфе  мы  будем
     рассматривать  только  цветной  режим).  Нижняя  строка развертки

     имеет номер 0. Лучше всего рассматривать изменение курсора именно
     относительно  строки  развертки  0,  так  как  применение другого
     метода может привести к значительным расхождениям  результатов на
     различных  компьютерах.  (В  принципе  применение  других методов
     возможно, однако вам необходимо помнить, что при их использовании
     вы можете не добиться соответствия форм курсора при решении одной
     и той же задачи на  разных  компьютерах).  При  условии,  что  вы
     будете рассматривать изменение формы курсора относительно нулевой
     строки  развертки,  изменение  формы  курсора  будет  выполняться
     аналогично изображенному на рис.8-1.

          Для установления размера курсора вам необходимо использовать
     ROM-BIOS-прерывание 10Н,  функцию 1, которая устанавливает размер
     курсора.   Начало   курсора   (начальная   строка   развертки)  -
     запоминается в регистре CН, а конец (конечная строка развертки) в
     регистре CL.





     ┌───────────────────────────────────────────────────────────────┐
     │   Строка развертки                                            │
     │                                                               │
     │   7                                            ┌───┐          │
     │                                                │   │          │
     │   6                                     ┌───┐  │   │          │
     │                                         │   │  │   │          │
     │   5                              ┌───┐  │   │  │   │          │
     │                                  │   │  │   │  │   │          │
     │   4                       ┌───┐  │   │  │   │  │   │          │
     │                           │   │  │   │  │   │  │   │          │
     │   3                ┌───┐  │   │  │   │  │   │  │   │          │
     │                    │   │  │   │  │   │  │   │  │   │          │
     │   2         ┌───┐  │   │  │   │  │   │  │   │  │   │          │
     │             │   │  │   │  │   │  │   │  │   │  │   │          │
     │   1  ┌───┐  │   │  │   │  │   │  │   │  │   │  │   │          │
     │      │   │  │   │  │   │  │   │  │   │  │   │  │   │          │
     │   0  │   │  │   │  │   │  │   │  │   │  │   │  │   │          │
     │      └───┘  └───┘  └───┘  └───┘  └───┘  └───┘  └───┘          │
     └───────────────────────────────────────────────────────────────┘
        Рис. 8-1.  Возможность изменения формы курсора в
                   цветном режиме.
          Функция size_cursor(),  представленная  ниже,  устанавливает
     размер курсора.

          /* Установление размера курсора */
     void size_cursor(start,end)
     char start,end; /* начальная и конечная строки развертки */
     {
          union REGS r;

          r.h.ah = 1; /* функция адресации курсора */
          r.h.ch = start;
          r.h.cl = end;
          int86(0x10,&r,&r);
     }

          При использовании  функции  size_cursor()  укажите  желаемые
     начальную  и  конечную  строки  развертки,  определяющие   размер
     курсора.  Например,  следующая  конструкция  позволяет установить
     высоту курсора в три строки развертки:

               size_cursor(0,2);

          Форма курсора может быть  изменена  либо  очередным  вызовом
     функции size_cursor(), либо изменением видеорежима.

          Использование курсоров  различной  формы позволяет не только
     полностью  удовлетворить  ваши  эстетические  требования,  но   и
     повысит   наглядность  программы.  Имейте  в  виду,  что  большой
     мерцающий курсор вызывает у пользователей раздражение.



                           СКРОЛЛИНГ ЧАСТИ ЭКРАНА
     -----------------------------------------------------------------

          Две   совместно  используемые   функции  ROM-BIOS-прерывания
     позволяют осуществлять скроллинг вперед и назад части экрана. Эти
     функции  были  включены  в  ROM-BIOS  для  поддержки многооконных
     интерфейсов. Как вы знаете,  когда курсор расположен  в  двадцать
     пятой  строке  и  вы  нажали  клавишу  <ВВОД>,  то  автоматически
     осуществляется перемещение текста на одну строку  вверх  с  целью
     отображения новой строки в нижней части экрана.  Точно так же,  с
     помощью функций 6 и 7 прерывания ROM-BIOS 10Н,  можно осуществить
     скроллинг лишь   части  экрана.  Функция  6  позволяет  выполнить
     скроллинг в окне вниз (вперед), а функция 7 - вверх (назад).

          Обе функции при вызове  используют  информацию,  хранимую  в
     определенных  регистрах.  Занесите  количество строк,  на которые
     будет "прокручиваться" текст (мощность скроллинга) в  регистр AL.
     Номер верхней левой строки,  ограничивающей ваше "окно", занесите
     в регистр CH,  а номер верхнего левого столбца -  в  регистр  CL.
     Номер нижней левой строки занесите в регистр DH,  а номер нижнего
     правого столбца - в регистр DL.  В конце запомните в регистре  BH
     атрибуты режима отображения, которые будут определять, как именно
     будут отображаться в процессе скроллинга  новые  строки.  Функция
     scroll_window() представлена ниже.

          /* Скроллинг в окне вперед и назад */

     void scroll_window(startx,starty,endx,endy,lines,direct)
     char startx,starty;/* верхний левый угол */
     char endx,endy;    /* нижний правый угол */
     char lines;        /* число строк прокрутки */
     char direct;       /* вперед или назад */
     {
          union REGS r;

          if ( direct == UP ) r.h.ah = 6; /* скроллинг вперед */
          else r.h.ah = 7; /* скроллинг вниз (назад) */
          r.h.al = lines;
          r.h.ch = starty;
          r.h.cl = startx;
          r.h.dh = endy;
          r.h.dl = endx;
          r.h.bh = 0;     /* режим отображения */
          int86(0x10,&r,&r);
     }

          Вы можете  определить  макрос  UP  как   имеющий   некоторое
     значение.  Вы  также  можете  определить  макрос  DOWN,  значение
     которого  будет  отлично  от  UP,  а   затем   использовать   при
     необходимости     осуществления    скроллинга    в    окне    эти
     макроопределения.   Такой   прием   значительно   упростит   вашу
     программу.   Функция   scroll_window()  присваивает  регистру  ВН
     значение 0 для сохранения пустых строк, однако вы можете изменить
     это значение по своему усмотрению.



                   ПРОСТЕЙШАЯ ДЕМОНСТРАЦИОННАЯ ПРОГРАММА
     -----------------------------------------------------------------

          Эта программа позволяет продемонстрировать  работу  функций,
     рассмотренных  в данной главе до настоящего момента.  Эти функции
     позволяют изменить форму курсора,  выдать сообщение  в  цвете,  а
     также использовать скроллинг части экрана.  Результат работы этой
     программы представлен на рис.8-2.


     ┌───────────────────────────────────────────────────────────────┐
     │
     │   a)     Это - тест
     │     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa    │
     │     bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb    │
     │     cccccccccccccccccccccccccccccccccccccccccccccccccccccc    │
     │     dddddddddddddddddddddddddddddddddddddddddddddddddddddd    │
     │     eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee    │
     │     ffffffffffffffffffffffffffffffffffffffffffffffffffffff    │
     │     gggggggggggggggggggggggggggggggggggggggggggggggggggggg    │
     │     hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh    │
     │     iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii    │
     │     jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj    │
     │     kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk    │
     │     llllllllllllllllllllllllllllllllllllllllllllllllllllll    │
     │     mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm    │
     │     nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn    │
     │     oooooooooooooooooooooooooooooooooooooooooooooooooooooo    │
     │     pppppppppppppppppppppppppppppppppppppppppppppppppppppp    │
     │     qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq    │
     │     rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr    │
     │     ssssssssssssssssssssssssssssssssssssssssssssssssssssss    │
     │     tttttttttttttttttttttttttttttttttttttttttttttttttttttt    │
     │     uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu    │
     │     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv    │
     │                                                               │
     │     б) Это - тест.                                            │
     │     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa    │
     │     bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb    │
     │     cccccccccccccccccccccccccccccccccccccccccccccccccccccc    │
     │     dddddddddddddddddddddddddddddddddddddddddddddddddddddd    │
     │     eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee    │
     │     ffffffffffffffffffffffffffffffffffffffffffffffffffffff    │
     │     gggggggggggggggggggggggggggggggggggggggggggggggggggggg    │
     │     hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh    │
     │     iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii    │
     │     jjjjjjjjjj                     jjjjjjjjjjjjjjjjjjjjjjj    │
     │     kkkkkkkkkk                     kkkkkkkkkkkkkkkkkkkkkkk    │
     │     llllllllll                     lllllllllllllllllllllll    │
     │     mmmmmmmmmmjjjjjjjjjjjjjjjjjjjjjmmmmmmmmmmmmmmmmmmmmmmm    │
     │     nnnnnnnnnnkkkkkkkkkkkkkkkkkkkkknnnnnnnnnnnnnnnnnnnnnnn    │
     │     oooooooooolllllllllllllllllllllooooooooooooooooooooooo    │
     │     pppppppppppppppppppppppppppppppppppppppppppppppppppppp    │
     │     qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq    │
     │     rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr    │
     │     ssssssssssssssssssssssssssssssssssssssssssssssssssssss    │
     │     tttttttttttttttttttttttttttttttttttttttttttttttttttttt    │
     │     uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu    │
     │     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv    │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

      Рис. 8-2 Результат работы программы.


          /* Демонстрационная программа печати текста в цвете,
             изменения формы курсора и скроллинга в окне
          */

            #include "dos.h"

            #define BLUE         1
            #define GREEN        2
            #define RED          4
            #define INTENSE      8
            #define BLUE_BACK   16
            #define GREEN_BACK  32
            #define RED_BACK    64
            #define BLINK      128

               #define UP        0
            #define DOWN         1

            void mode(),color_puts(),palette(), read_cursor_xy();
            void goto_xy(),size_cursor(),scroll_window();

               main()
               {
                int i,j;

             mode(3); /* режим текстовый, цветной */

                size_cursor(0,3);
                goto_xy(0,0);
                color_puts(" Это - тест\n",BLUE |RED | INTENSE);
                for ( i=0;i<22;i++) {
                    for ( j=0;j<79;j++)
                    printf("%c",i+'a');
                    printf("\n");
               }
               getche();
               scroll_window(10,10,50,15,3,DOWN);
               getche();
     }
          /* Печать строки в цвете */

               void color_puts(s,color)
               char *s;      /* строка */
               char color;   /* цвет строки */
               {
                    union REGS r;
                    char x,y;

                    read_cursor_xy(&x,&y); /* чтение текущей позиции
                                              курсора   */
                    while (*s) {
                     if (*s == '\n') { /* обработка символа новой
                                          строки */
                     printf("\n");
                     s++;
                     x = 0; y++;  /* переход к новой строке */
                     continue;
                    }

                    r.h.ah = 9;/* отображение символов по атрибутам */
                    r.h.al = *s++; /* выдаваемый символ */
                    r.h.bl = color;  /* атрибут цвета */
                    r.h.bh = 0; /*     видеостраница 0 */
                    r.x.cx = 1; /* выдача символа за один такт */
                    int86(0x10,&r,&r);
                    x++;
                    goto_xy(x,y);      /* перемещение курсора */
                    }
               }
          /* чтение текущей позиции курсора */
               void read_cursor_xy(x,y)
               char *x,*y;
               {
                union REGS r;

                r.h.ah = 3; /* чтение позиции курсора */
                r.h.bh = 0; /* видеостраница 0 */
                int86(0x10,&r,&r);
                *y = r.h.dl;
                *x = r.h.dh;
               }

          /* установка палитры */
               void palette(pnum)
               int pnum;
               {
                union REGS r;

                r.h.bh = 1;  /* код для графического режима 4 */
                r.h.bl = pnum;
                r.h.ah = 11; /* функция установки палитры */
                int86(0x10,&r,&r);
               }

          /* установка видеорежима */
               void mode(mode_code)
               int mode_code;
               {
                union REGS r;

                r.h.al = mode_code;
                r.h.ah = 0;
                int86(0x10,&r,&r);
               }

          /* перемещение курсора в позицию x,y */
               void goto_xy(x,y)
               int x,y;
               {
                union REGS r;

                r.h.ah = 2; /* функция адресации курсора */
                r.h.dl = x; /* координаты столбца */
                r.h.dh = y; /* координаты строки */
                r.h.bh = 0; /* видеостраница 0 */
                int86(0x10,&r,&r);
               }

          /* установка размера (формы) курсора */
               void size_cursor(start,end)
               char start,end; /* начальная и конечная строки
                         развертки */
               {
                union REGS r;

                r.h.ah = 1; /* функция адресации курсора */
                r.h.ch = start;
                r.h.cl = end;
                int86(0x10,&r,&r);
               }

          /* скроллинг в окне вперед и назад */
         void scroll_window(startx,starty,endx,endy,lines,direct)
         char startx,starty; /* верхний левый угол */
         char endx,endy;     /* нижний правый угол */
         char lines;         /* мощность скроллинга */
         char direct;        /* вверх или вниз */
          {
           union REGS r;

           if ( direct == UP ) r.h.ah = 6; /* скроллинг вверх */
            else r.h.ah = 7; /* скроллинг вниз */

          r.h.al = lines;
          r.h.ch = starty;
          r.h.cl = startx;
          r.h.dh = endy;
          r.h.dl = endx;
          r.h.bh = 0; /* режим отображения */
          int86(0x10,&r,&r);
          }



                  СОХРАНЕНИЕ КОПИИ ЭКРАНА В ДИСКОВОМ ФАЙЛЕ
     -----------------------------------------------------------------

          Ни в  DOS,  ни в OS/2 нет утилит,  сходных с утилитой печати
     копии экрана,  позволяющей сохранять  текущее  содержимое  экрана
     дисплея в  дисковом  файле.  В этом разделе вы найдете пояснение,
     как можно создать программу,  которая  выполняла  бы  именно  эту
     функцию.

          Эта программа использует ROM-BIOS-прерывание 10Н,  функцию 8
     для чтения  символа из  текущей позиции курсора,  после чего этот
     символ записывается в файл на диске.  Как и в предыдущем разделе,
     вы опять встретитесь с функцией goto_xy(),  которая в этом случае
     используется  для  перемещения  курсора  последовательно  по всем
     строкам экрана,  начиная с левого верхнего угла экрана до правого
     нижнего угла.

          Имя файла,   в   котором   будет   храниться  копия  экрана,
     указываетя в качестве аргумента программы.  Если,  к примеру,  вы
     назовете  свою программу,  копирующую экран на диск,  screen,  то
     представленная ниже командная строка приведет  к  созданию  копии
     экрана в файле с именем scr.sav:

     C> screen scr.sav

          А вот исходный текст самой программы копирования:

               /* Эта программа копирует содержимое экрана вашего
                  дисплея в файл, имя которого указано в командной
                  строке
               */

          #include "dos.h"
          #include "stdio.h"

          void save_screen(),goto_xy();

          main(argc,argv)
          int argc;
          char *argv[];
          {
            if ( argc != 2 ) {
               printf(" используйте формат : screen <имя файла>");
               exit(1);
            }
            save_screen(argv[1]);
          }

          /* сохранение содержимого экрана в дисковом файле */
               void save_screen(fname)
               char *fname;
          {
           FILE *fp;
           union REGS r;
           register char x,y;

           if ( !( fp=fopen(fname,"w"))) {
               printf(" Файл не может быть открыт ");
               exit(1);
           }

           for (y=0;y<25;y++)
               for (x=0;x<80;x++) {
               goto_xy(x,y);
               r.h.ah = 8; /* чтение символа */
               r.h.bh = 0; /* видеостраница */
               int86(0x10,&r,&r);
               putc(r.h.al,fp); /* выдача (печать) символа */
           }
          fclose(fp);
          }

          /* Перемещение курсора в позицию (x,y) */
          void goto_xy(x,y)
          int x,y;
          {
            union REGS r;

            r.h.ah = 2; /* функция адресации курсора */
            r.h.dl = x; /* координата столбца */
            r.h.dh = y; /* координата строки */
            r.h.bh = 0; /* видеостраница */
            int86(0x10,&r,&r);
          }

          Создаваемый файл  представляет собой стандартный ASCII файл,
     который  может  быть  отредактирован  и  распечатан  как  обычный
     текстовый  файл.  Программа  позволяет  записывать  лишь символы,
     отображенные на экране, но не позволяет сохранить соответствующие
     атрибуты  отображения  символов.  Однако  дополнить программу для
     того, чтобы она записывала и атрибуты символов несложно, и вы при
     желании можете это сделать самостоятельно.



                           А ТЕПЕРЬ ДОБАВИМ ЗВУК.
     -----------------------------------------------------------------

          Использование со   вкусом   звука    значительно    повышает
     привлекательность программ. Звук может быть использован в широком
     спектре от тоненького "писка" машины  до  исполнения  музыки  или
     различных  специальных  эффектов.  В этом параграфе вы научитесь,
     как можно управлять высотой и  продолжительностью  звучания  нот,
     генерируемых динамиком компьютера.  Мы также продемонстрируем вам
     некоторые наиболее интересные звуковые эффекты.


          Программируемый таймер 8253.
          -----------------------------

          Генерация звуков  в  компьютере  PC  выполняется  с  помощью
     программируемого таймера 8253, который применяется для управления
     колебаниями   динамика.    Управление     колебаниями    динамика
     определяется  частотой,  которая,  в  свою очередь,  определяется
     содержимым  различных   внутренних   регистров.   Значения   этих
     регистров  устанавливаются при записи в определенные порты.  Порт
     66 используется для  спецификации  счетчика,  который  использует
     таймер  при  определении  интервала  колебаний  динамика.  Таймер
     работает в строгом соответствии с частотой системного  таймера  и
     специфицированным   значением  счетчика,  определяющим  колебания
     динамика.  Затем,  после обнуления счетчика происходит  установка
     нового   значения   счетчика,   и   весь   цикл  функционирования
     программируемого таймера повторяется сначала.  Значение  счетчика
     определяется по следующей формуле:

          count = 1,193,180/требуемая частота

     где 1,193,180 есть тактовая частота системного таймера.

          Регистр-счетчик таймера  8253  устанавливается  в  следующей
     последовательности (значение   счетчика   задается    двухбайтным
     числом):

       1.  Выдать в порт  67  значение  182  (означающее,  что   будет
           устанавливаться счетчик).

       2.  Выдать в порт 66 младший байт числа, определяющего значение
           счетчика.

       3.  Выдать в порт 66 старший байт числа, определяющего значение
           счетчика.

          Динамики большинства  компьютеров  класса  PC  не  позволяют
     воспроизводить полный спектр частот,  воспринимаемых человеческим
     слухом (от  20  Гц  до  18.000  Гц).  Однако  динамик   позволяет
     воспроизводить  ноты  лучше,  чем  динамики  других компьютеров в
     пределах 12000 Гц и даже выше. В основном же динамик используется
     в пределах 100-5000 Гц.

          Итак, таймер   установлен.   Однако  динамик  еще  не  будет
     воспроизводить звук,  так как не  включен.  Таймер  8253  активен
     постоянно,  а  динамик  требует дополнительной команды включения.
     Активизация  динамика  осуществляется  путем  установки  значений
     битов  0  и 1 регистра программируемого периферийного интерфейса,
     задание  значений  которого  выполняется  через  порт   97.  Если
     значения этих двух битов установлены (равны 1), то динамик издает
     звук частотой,  установленной счетчиком 8253.  Если значения этих
     битов равны 0, то никакой звук генерироваться не будет. Остальные
     биты  этого  байта  используются  другими  устройствами,  поэтому
     интерпретация  значения левых битов не может быть изменена. Таким
     образом, для  установки  значений   управляющих   динамиком   бит
     необходимо выполнить следующую последовательность действий:

      1. Получить текущее значение регистра из порта 97.
      2. Сравнить это значение с 3 или установить равным 3.
      3. Записать результат в порт 97.

          Для того,  чтобы  выключить динамик,  необходимо переслать в
     порт значение 253.

          Простейшим приемом,  позволяющим читать и писать байт из или
     в  порт,  в Си является использование соответствующих функций.  В
     Турбо Cи - это функции inportb() и outportb().  В Microsoft Cи  -
     это функции inp() и outp(). Они имеют следующий общий формат:

               int inportb(int port);
               void outportb(int port, char value);
               int inp(unsigned port);
               int outp(unsigned port, int value);

          В  других  компиляторах  Си  эти  функции  могут  иметь иные
     названия, но обязательно будут присутствовать в вашей библиотеке,
     так как являются одними из базовых функций версий Си  для ПЭВМ. В
     программах,  приведенных в этом  параграфе,  используются функции
     Турбо Cи.


          Простейший способ проверки слуха.
          ---------------------------------

          Вы обладаете  возможностью  сделать  несколько  грубый,   но
     эффективный тест слуха,  который в состоянии обнаружить некоторые
     типы дефекта слуха.  Как вы  ранее  узнали,  динамик  большинства
     компьютеров серии PC не воспроизводит звуки выше 12000 Гц. Однако
     ряд людей,  у которых отмечены  некоторые  отклонения  слуха,  не
     могут услышать звук даже такой частоты. Фактически, тестируя свой
     слух,  вы  будете  несколько  удивлены  тем,  насколько   высоким
     окажется звук с частотой 12000 Гц.  (Предупреждение: тестирование
     слуха с помощью этого теста можно производить  лишь  ради  шутки.
     Он,   естественно,   не   позволяет  действительно  оценить  слух
     испытуемого.  Поэтому,  если вы заметили у себя дефекты слуха или
     хотите  действительно  проверить  свой  слух,  обратитесь лучше к
     своему врачу).

          Для получения звука в тесте  используется  функция  sound(),
     которая  генерирует  непродолжительное звучание специфицированной
     ноты. Как показано ниже, эта функция содержит все необходимое для
     того,   чтобы   сгенерировать   любой  звук  с  помощью  динамика
     компьютера.

               /* Звучание динамика на заданной частоте */

          void sound(freq)
          int freq;
          {
            unsigned i;
            union {
               long divisor;
               unsigned char c[2];
            } count;

            unsigned char p;

            count.divisor = 1193280 / freq; /* вычисление небходимого
                                             значения счетчика */
            outportb(67,182); /* обращение к таймеру 8253 после
                                 установки счетчика */
            outportb(66,count.c[0]); /* пересылка младшего байта */
            outportb(66,count.c[1]); /* пересылка старшего байта */
            p = inportb(97); /* чтение существующего шаблона бит */
            outportb(97,p|3); /* установка битов 0 и 1 */

            for (i=0;i<64000;++i); /* цикл задержки */

            outportb(97,p); /* восстановление первоначального значения
                               шаблона бит для отключения динамика */
          }



          Заметим, что  частота  звучания  ноты  специфицирована   как
     аргумент функции. Цикл задержки необходим, так как без него вы бы
     услышали  только  мгновенный  "щелчок"  или  "писк".  Вы   можете
     изменить  частоту  работы  системного  таймера  процессора вашего
     компьютера.  При этом,  оформив  его  как  параметр  функции,  вы
     добьетесь  определенной  эффективности  вашей программы.  Функция
     sound()  может  использоваться   и   для   получения   банального
     "пищания" компьютера.

          Управляющая функция  для  программы теста слуха представлена
     ниже.


               /* Простейший тест слуха */

          #include "dos.h"

          void sound();

          main()
          {
               int freq;

               do {
                 printf(" Введите частоту ( 0 - выход ): ");
                 scanf("%d",&freq);
                 if ( freq ) sound(freq);
               } while(freq);
          }



          При использовании теста,  в возрастающем порядке  указывайте
     частоту звука до тех пор,  пока звук воспринимается на слух.  Для
     выхода введите 0.


          Имитация звука сирены и взврывы.
          --------------------------------

          Вы можете использовать возможность  управления динамиком для
     создания  различных  звуковых  эффектов,  которые,  в  частности,
     делают видеоигры очень интересными и  привлекательными.  В основе
     всех звуковых эффектов лежит варьирование  частоты звука  - часто
     самым необычным образом.

          Например, для создания эффекта  звучания  сирены  вы  должны
     варьировать  частоту звука между двумя конечными точками.  Высота
     звука должна изменяться от меньшей к большей, а затем уменьшаться
     от  большей  к  меньшей.  Функция  siren(),  представленная ниже,
     использует этот метод для создания эффекта звучания сирены.


          #define DELAY 10000

          /* Создание эффекта звучания сирены */
          void siren()
          {
            unsigned i,freq;
            union {
               long divisor;
               unsigned char c[2];
            } count;

            unsigned char p;

            p = inportb(97); /* чтение существующего шаблона бит */
            outportb(97,p|3); /* установка бит 0 и 1 */
               /* повышение звука сирены */
            for (freq = 1000;freq<3000;freq+=RATE) {
               count.divisor = 1193280 / freq; /* вычисление нужного
                                                  значения счетчика */
               outportb(67,182); /* обращение к таймеру 8253 после
                                      определения значения счетчика */
               outportb(66,count.c[0]); /* пересылка младшего байта */
               outportb(66,count.c[1]); /* пересылка старшего байта */

               for (i=0;i<DELAY;++i);
            }

               /* понижение звука сирены */
            for (;freq>1000;freq-=RATE) {
               count.divisor = 1193280 / freq; /* вычисление нужного
                                                  значения счетчика */
               outportb(67,182); /* обращение к таймеру 8253 после
                                      определения значения счетчика */
               outportb(66,count.c[0]); /* пересылка младшего байта */
               outportb(66,count.c[1]); /* пересылка старшего байта */

               for (i=0;i<DELAY;++i);
            }
            outportb(97,p); /* восстановление начального вида шаблона
                                        бит для отключения динамика */
          }

          Вы можете    переопределить   значение   макроса   DELAY   в
     зависимости от  производительности  вашего  компьютера  и  вашего
     вкуса. Как вы видите,  функция siren() выполняет один полный цикл
     звучания сирены и на этом завершает свою  работу.  Для  получения
     эффекта  продолжительного  звучания  сирены  вам  надо  поместить
     обращение к siren() в цикл.

          Для имитации звука взрыва,  который используется  во  многих
     видеоиграх,  можно  модифицировать функцию siren() таким образом,
     чтобы она позволяла генерировать звук  лишь  нисходящей  частоты.
     Функция  laser(),  представленная  ниже,  позволяет получить этот
     эффект.


          #define DELAY 10000
          /* получение эффекта взрыва */
          void laser()
          {
            unsigned i,freq;
            union {
               long divisor;
               unsigned char c[2];
            } count;

            unsigned char p;

            p = inportb(97); /* чтение существующего шаблона бит */
            outportb(97,p|3); /* установка бит 0 и 1 */
               /* взрыв */
               for (;freq>1000;freq-=RATE) {
               count.divisor = 1193280 / freq; /* вычисление нужного
                         значения счетчика */
               outportb(67,182); /* обращение к таймеру 8253 после
                         определения значения счетчика */
               outportb(66,count.c[0]); /* пересылка младшего байта */
               outportb(66,count.c[1]); /* пересылка старшего байта */

               for (i = 0;i<DELAY;++i);
            }
            outportb(97,p); /* восстановление начального вида шаблона
                               бит для отключения динамика */
          }



          После небольшого   экспериментирования   вы   сможете   сами
     создавать широкий спектр звуковых эффектов.  Интерес представляет
     варьирование скоростью  изменения  частоты  звука  для  получения
     определенных эффектов.


          Создание "космической музыки".
          ------------------------------

          Соединив воедино произвольное количество стандартных функций
     Си rend() и sound(),  вы создадите  "космическую"  музыку.  Звук,
     получаемый   при   выполнении   программы,  представленной  ниже,
     напоминает "музыку звезд" в старых научно-фантастических фильмах.
     Несмотря на то,  что все звуки генерируются произвольным образом,
     ритм  и  рисунок   мелодии,   возникающие   время   от   времени,
     действительно оставляют впечатление "небесной музыки".
                                                                               
               /* Космическая музыка звезд */

          #define DELAY 64000

          #include "dos.h"

          void sound();

          main()
          {
               int freq;

               do {
                    do {
                         freq = rand();
                    } while (freq>5000); /* после персонального
                                            прослушивания */
                    sound(freq);
               } while (!kbhit());
          }

          /* звучание динамика на специфицированной частоте */                 
          void sound(freq)
          int freq;
          {
            unsigned i;
            union {
               long divisor;
               unsigned char c[2];
            } count;

            unsigned char p;
            count.divisor = 1193280 / freq; /* вычисление нужного
                                               значения счетчика */
               outportb(67,182); /* обращение к таймеру 8253 после
                                    определения значения счетчика */
               outportb(66,count.c[0]); /* пересылка младшего байта */
               outportb(66,count.c[1]); /* пересылка старшего байта */

               p = inportb(97); /* чтение существующего шаблона бит */
               outportb(97,p|3); /* установка бит 0 и 1 */

               for (i = 0;i<DELAY;++i); /* задержка 64000 для 10+ Мгц
                                           компьютеров                         
                                        32000 для 6 МГц PC/AT
                                        20000 для стандарта PC и XT */

               outportb(97,p); /* восстановление начального вида
                    шаблона бит для отключения динамика */
          }

          Эта программа генерирует звуки частотой менее 5000  Гц,  так
     как   звуки   именно  в  пределах  этой  частоты  наиболее  мягко
     воспринимаются слухом и не  выходят  за  границы,  воспринимаемые
     ухом человека.

          Рекомендуем вам   поэкспериментировать  с  этой  программой,
     установив произвольную длину интервала времени между  звуками или
     фильтруя  значения,  передаваемые  в  sound().  Возможны и другие
     варианты развития вашего творчества.



                                  ГЛАВА 9
                                  -------
                                                                               
                            ИНТЕРФЕЙС С "МЫШЬЮ"
     -----------------------------------------------------------------

          Наиболее   популярным   устройством   ввода   данных   после
     клавиатуры является "мышь"  (mouse). Несмотря на то, что "мышь" и
     сходные  технологии,  такие  как "roller ball",  получили широкое
     распространение   лишь  в  последнее  время,  популярность "мыши"
     берет свое начало с момента выхода на  рынок очередной разработки
     фирмы  Apple  компьютера  Apple  Lisa,  в  котором  впервые  была
     применена технология "мышь" для работы с  пиктограммным (иконным)
     интерфейсом операционной  системы этого компьютера.  Модель Apple
     Lisa  произвела форменный переворот  в  фирме  Macintosh, которая
     пошла по пути использования "мыши"  и пиктограммного интерфейса в
     своих  программных продуктах.  Перед выходом на  рынок  серии IBM
     PS/2  "мышь",  по существу, была третьим дополнением к РС. Тем не
     менее уже при анонсировании системы IBM  PS/2 сообщалось, что она
     снабжена  портом  для  подключения  "мыши",   и  "мышь"  занимает
     значительное место среди РС.

          Наилучшее   использование   "мыши"   -   предмет  постоянных
     дискуссий.  Не все программисты  (или  пользователи) воспринимают
     пиктограмный  интерфейс.  В связи с тем,  что "мышь" впервые была         
     использована   именно  с   пиктограммным   интерфейсом,   вопросы
     использования "мыши"  чаще всего сводятся именно к нему, а это в,
     свою очередь,  отталкивает от "мыши"  большой круг программистов,
     негативно относящихся к  такому  интерфейсу.  Однако  "мышь" ведь
     может  использоваться   и   без   такого   интерфейса.  Например,
     практически все  согласны  с  тем,  что  "мышь"  эффективно может
     использоваться при работе  с  интерактивной  графикой.

          Некоторые модели манипуляторов  типа  "мышь",  равно  как  и
     выполняемые  ими  функции,  могут  значительно отличаться друг от
     друга.  Поэтому заметим,  что все программы,  приведенные в  этой
     главе,  ориентированы  на  использование  "мыши" фирмы Microsoft,
     которая функционально идентична "мыши", используемой в моделях PS
     /2.  Для  обеспечения  интерфейса  с  "мышью" фирмы Microsoft вам
     необходимо  иметь  по  крайней  мере  саму  "мышь",   руководство
     пользователя  по программному обеспечению "мыши" (Microsoft Mouse
     Programmer's Reference Guide) и поставляемый с  этим руководством
     диск.  На  этом диске расположена специальная библиотека с именем
     MOUSE.LIB, выполняющая поддержку функционирования "мыши" на самом
     нижнем уровне. Мы будем использовать функции из этой библиотеки в
     качестве базовых функций при рассмотрении  программ, предлагаемых
     вам в этой главе.  вы должны помнить, что ваш компилятор С должен         
     быть совместим с подключаемыми  на  этапе  редактирования  связей
     подпрограммами  из  библиотеки  подпрограмм поставляемых на диске
     фирмой Microsoft.  вам также надлежит  помнить,  что  обязательно
     необходимо наличие драйвера устройства MOUSE.SYS.

          После беглого  обзора  основ использования манипулятора типа
     "мышь" в этой главе вы  получите  информацию  о  том,  как  можно
     модифицировать  ранее  рассмотренную программу "рисования" с тем,
     чтобы она могла работать с "мышью" (с учетом того,  что  основные
     концепции  применения  "мыши",  а  также разработанные в процессе
     изложения материала подпрограммы,  могут  использоваться  вами  в
     дальнейшем при создании различных конкретных приложений).




                   НЕКОТОРЫЕ НАЧАЛЬНЫЕ СВЕДЕНИЯ О "МЫШИ"
     -----------------------------------------------------------------

          Для того, чтобы использовать "мышь", прежде всего необходимо
     инсталировать соответствующий драйвер. Для "мыши" фирмы Microsoft
     в файл CONFIG.SYS должна быть добавлена следующая строка:                 

                             device = mouse.sys

          Для инсталяции   драйвера   "мыши"  фирмы  IBM  должна  быть
     запущена программа MOUSE.COM.  С этой целью в  файл  AUTOEXEC.BAT
     может быть добавлена строка вида:

                                   mouse

          После того,  как драйвер размещен в  системе, любые действия
     по  перемещению  "мыши"  или  нажатию  ее  клавиш  будут вызывать
     генерацию прерывания 33Н.  Процесс, управляющий "мышью", вызывает
     прерывание,    затем   устанавливает   значения   соответствующих
     внутренних переменных и продолжает свою работу.  Вследствие того,
     что прерывание  генерируется  лишь  при изменении  "мышью" своего
     положения, неподвижная "мышь" не вызывает необходимости выделения
     на нее ресурсов компьтера.

          Точно так же,  как  с  клавиатурой  ассоциирован  курсор,  с
     "мышью"  также  ассоциирован  некий  маркер на экране (называемый
     далее указатель).  Подпрограммы в библиотеке в  поддержке  "мыши"
     фирмы   Microsoft   определяют   по   умолчанию  следующую  форму         
     указателя:  в графических режимах - это стрелка,  а  в  текстовых
     режимах  -  прямоугольник  в  рамках габаритных размеров символа.
     Аналогично  курсору  клавиатуры  указатель-курсор  "мыши"   может
     отображаться    лишь    тогда,   когда   "мышь"   непосредственно
     используется.  В  противном  случае  указатель-курсор  "мыши"  не
     отображается на экране так, как будто интерфейса с "мышью" вообще
     не существует.

          Несмотря на то,  что "мышь" и экран физически отделены  друг
     от друга,  связь  между  ними  все  же  имеется,  так как драйвер
     "мыши" автоматически    отслеживает     содержимое     счетчиков,
     индицирующих   текущее   состояние  указателя-курсора  "мыши"  на
     экране.  При перемещении "мыши" курсор автоматически перемещается
     на  экране  в  точном соответствии с изменением координат "мыши".
     Расстояние,  на которое  была  перемещана  "мышь",  измеряется  в
     "мышиных"  шагах.  Один  такой  шаг  равен 1/200 дюйма.  Однако в
     большинстве случаев знать на сколько переместилась  "мышь" совсем
     необязательно.



                                                                               
                       ВИРТУАЛИЗАЦИЯ И РЕАЛЬНЫЙ ЭКРАН
     -----------------------------------------------------------------

          Библиотека подпрограмм  поддержки  "мыши"  фирмы   Microsoft
     работает  с  виртуальным  экраном  в  виде  массива  точек растра
     (массива из  единиц  минимального  изображения,  цвет  и  яркость
     которых  можно  задать  независимо  от  остального  изображения),
     который может отличаться от  реального  экрана.  При  перемещении
     "мыши"  счетчики  местоположения  курсора изменяют свое значение.
     Перед  отображением  курсора   виртуальные   координаты   курсора
     преобразуются  в  координаты реального экрана.  В видеорежимах 6,
     14,  15 и 16 это преобразование осуществляется один к  одному.  В
     режимах  4 и 5 не каждая точка виртуальной горизонтальной позиции
     преобразуется в координты реального  экрана,  а  через  одну.  вы
     должны   обратить  внимание  на  этот  факт,  так  как  программа
     рисования, к которой будет добавлен интерфейс с "мышью" и которая
     будет  рассматриваться  в  данной  главе,  работает  именно  в  4
     графическом режиме.



                        БИБЛИОТЕКА ПОДДЕРЖКИ "МЫШИ"                            
     -----------------------------------------------------------------

          Подпрограммы внутри MOUSE.LIB ассоциируются у пользователя с
     одной функцией, использующей в качестве входного аргумента число,
     специфицирующее  номер  функции  поддержки "мыши".  (Этот процесс
     некоторым образом сходен  с  процессом  доступа  к  функциям  DOS
     посредством  прерывания  21Н  с указанием номера нужной функции).
     Имя   этой   функции   определяется   моделью   памяти,   которая
     используется  при  компиляции  вашей  программы.  Используйте имя
     cmouses() для  модели  маленькой  памяти,  cmousec()  для  модели
     компактной памяти,   cmousem()   для   модели  средней  памяти  и
     cmousel() для модели большой и самой большой  (огромной)  памяти.
     (Заметим,  что функция не может работать в модели самой маленькой
     памяти).  Пример,  представленный в этой главе, использует модель
     маленькой памяти,  однако вы можете изменить тип модели памяти по
     своему усмотрению.

          Основным форматом функции cmouses() является:

          void cmouses(fnum, arg2, arg3, arg4);
               int *fnum, *arg2, *arg3, *arg4;
          Как видно,  fnum  является номером функции поддержки "мыши",         
     которую необходимо вызвать. Другие параметры содержат информацию,
     необходимую  для  спецификации  функции.  Обратите внимание,  что
     функции передаются не сами аргументы, а указатели на их значения.
     Функция  cmouses() возвращает результаты работы в виде параметров
     и,  следовательно,  нуждается в  их  адресации.  Фирма  Microsoft
     определила тридцать функций поддержки "мыши".  Однако в программе
     рисования будут использованы лишь  пять  из  них.  Ниже  приведен
     краткий  обзор функций поддержки "мыши" фирмы Microsoft,  которые
     будут использованы нами в этой главе.


          Привести в исходное состояние, выдать статус.
          ---------------------------------------------

          Функция 0 приводит "мышь" в начальное  состояние (сбрасывает
     "мышь")  Она  перемещает курсор-указатель "мыши" в центр экрана и
     "выключает  "  его.  Функция  возвращает  номер  нажатой  клавиши
     "мыши"   в качестве значения arg2.  После завершения функции fnum
     принимает значение 0,  если "мышь" и соответствующее  программное
     обеспечение не инсталированы, и -1 в противном случае.

                                                                               
          Отобразить курсор
          -----------------

          Функция 1   отображает   указатель-курсор   "мыши".  Она  не
     возвращает никакого значения.


          Переместить курсор
          ------------------

          Функция 2 перемещает курсор по  экрану.  Она  не  возвращает
     никакого значения.


          Выдать статус клавиши и позицию курсора
          ---------------------------------------

          Функция 3  возвращает  статус  клавиши  в arg2,  виртуальную
     горизонтальную позицию курсора в arg3, а виртуальную вертикальную
     позицию курсора в arg4.

          Статус клавиши  кодируется  в  битах 0 и 1 байта arg2.  Если         
     значение бита 0 установлено  (равно  1),  то  была  нажата  левая
     клавиша  "мыши",  если значение бита 1 установлено (равно 1),  то
     была  нажата  правая  клавиша.  Если  значения  обоих  битов   не
     установлены (равны 0), то никакая клавиша нажата не была.


          Установить координаты курсора
          ------------------------------

          Функция 4  устанавливает  месторасположение  курсора "мыши".
     Значение arg3  определяет горизонтальную позицию, а значение arg4
     -  вертикальную  позицию курсора.  вы всегда должны  помнить, что
     значения  не  должны  выходить  за  пределы  виртуального экрана,
     который вы используете.


          Индикация движения
          ------------------

          Функция 11  возвращает  число  вертикальных и горизонтальных
     "мышиных" шагов,  которое "мышь"  прошла  со  времени  последнего
     обращения   к   функции  11,  другими  словами  -  это  изменение         
     вертикальных и горизонтальных  координат  "мыши".  Функция  также
     сбрасывает внутренний регистр-счетчик в 0. Значение вертикального
     счетчика возвращается в arg3,  а горизонтального -  в  arg4.  Это
     позволяет,  если  "мышь"  после последнего обращения к функции не
     перемещалась на плоскости, получить значения как горизонтального,
     так и вертикального счетчиков равными 0.  Если значение одного из
     счетчиков (или обоих) отлично от 0,  то  "мышь"  перемещалась  на
     плоскости.

          Положительное значение   изменения   вертикальных  "мышиных"
     шагов   позволяет   заключить,   что   "мышь"   двигалась   вниз.
     Отрицательное  же  значение  свидетельствует  о  движении  "мыши"
     вверх.

          Положительное значение изменения числа  горизонтальных шагов
     свидетельствует   о   том,  что  "мышь"  перемещалась  вправо,  а
     отрицательное значение показывает на то,  что "мышь" перемещалась
     влево.



                  ФУНКЦИИ ПОДДЕРЖКИ "МЫШИ" ВЕРХНЕГО УРОВНЯ                     
     -----------------------------------------------------------------

          Используя функцию cmouses() вы можете создать  набор функций
     языка  Си  высокого  уровня,  которые  значительно  облегчат  вам
     программирование интерфейсов,  ориентированных на  использованием
     "мыши". Посмотрите, как это делается.


          Установка "мыши" в исходное состояние.
          --------------------------------------

          Функция, представленная ниже, mouse_reset() используется для
     установки "мыши"  в  исходное  состояние.  Заметим,  что  функция
     требует   наличия  соответствующего  программного  обеспечения  и
     аппаратной части компьютера,  а  также  инсталяции  двухклавишной
     "мыши".

     /* Установка "мыши" в исходное состояние */

     void mouse_reset()
     {
          int fnum, arg2, arg3, arg4;                                          

          fnum = 0;  /* Установка "мыши" в исходное состояние  */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          if(fnum!=-1) {
          printf("Аппаратные или программные средства поддержки ");
          printf("'мыши' не инсталированы");
               exit(1);
          }
          if(arg2!=2) {
       printf("Разрешено использование только двухклавишной 'мыши'");
               exit(1);
          }
     }


          Отображение и перемещение курсора "мыши".
          -----------------------------------------

          Взаимодополняющие друг   друга   функции    cursor_on()    и
     cursor_off(),  представленные  ниже,  позволяют  активизировать и
     деактивизировать изображение курсора на экране дисплея.
                                                                               

     /*  Включение курсора "мыши"  */
     void cursor_on()
     {
          int fnum;

          fnum = 1; /* отобразить курсор */
          cmouses( &fnum,  &fnum,  &fnum,  &fnum);
     }

     /*  Выключение курсора "мыши"  */
     void cursor_off()
     {
          int fnum;

          fnum = 2; /* стереть курсор */
          cmouses( &fnum,  &fnum,  &fnum,  &fnum);
     }


          Какая из клавиш "мыши" была нажата?
          -----------------------------------                                  

          Другой парой  взаимодополняющих  друг друга функций являются
     функции rightb_pressed() и leftb_pressed(),  представленные ниже.
     Эти функции возвращают значение "истина",  если нажата правая или
     левая клавиши.


     /* Возвращает значение "истина", если нажата правая клавиша,
          и "ложь" в противном случае                            */

     rightb_pressed()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3;   /* Чтение позиции и статуса клавиши */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          return arg2 & 2;
     }



     /* Возвращает значение "истина", если нажата левая клавиша,               
          и "ложь" в противном случае                            */

     leftb_pressed()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3;   /* Чтение позиции и статуса клавиши */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          return arg2 & 1;
     }


          Как обнаружить перемещение "мыши"?
          ----------------------------------

          Функция 11,  которая  возвращает изменение значения счетчика
     "мыши" (в "мышиных" шагах)  после  последнего  обращения  к  ней,
     позволяет    определить    факт   перемещения   "мыши".   Функция
     mouse_motion(),   представленная   ниже,   возвращает   изменение
     местоположения    "мыши"    в   горизонтальном   и   вертикальном
     направлениях в переменных,  чьи  указатели  являются  аргументами
     функции.  Если  оба  значения  deltax  и deltay равны 0,  то факт         
     движения "мыши" не регистрируется.

     /*  Возвращает направление движения  */
     void mouse_motion(deltax, deltay)
     char *deltax, *deltay;
     {
          int fnum, arg2, arg3, arg4;

          fnum = 11; /* получить направление движения */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          if(arg3>0) *deltax = RIGHT;
          else if(arg3<0) *deltax = LEFT;
          else *deltax = NOT_MOVED;

          if(arg4>0) *deltay = DOWN;
          else if(arg4<0) *deltay = UP;
          else *deltay = NOT_MOVED;
     }


          Макросы RIGHT, LEFT, UP, DOWN и NOT_MOVED определены
     следующим образом:                                                        

     #define NOT_MOVED 0
     #define RIGHT     1
     #define LEFT      2
     #define UP        3
     #define DOWN      4



          Чтение и установка позиции курсора.
          -----------------------------------

          Функции set_mouse_position()       и       mouse_position(),
     представленные  ниже,  используются  для установки чтения текущей
     позиции курсора "мыши".


     /* Установить координаты курсора "мыши" */
     void set_mouse_position(x, y)
     int x, y;
     {
                                                                               
          int fnum, arg2;

          fnum = 4; /* установка позиции */
          cmouses(&fnum, &arg2, &x, &y);
     }

     /* Возвращает координаты курсора "мыши" */
     void mouse_position(x, y)
     int *x, *y;
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3; /* получить позицию и статус клавиши */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          *x = arg3;
          *y = arg4;
     }




                   ПРОСТЕЙШАЯ ДЕМОНСТРАЦИОННАЯ ПРОГРАММА                       
     -----------------------------------------------------------------

          Программа, представленная   ниже,  демонстрирует  применение
     функций поддержки "мыши" высокого уровня.  вы можете сразу ввести
     ее в ваш компьютер и попробовать ее в деле.

     /*  Интерфейс с "мышью" Microsoft/IBM */

     #include "dos.h"
     #define NOT_MOVED 0
     #define RIGHT     1
     #define LEFT      2
     #define UP        3
     #define DOWN      4
     void mouse_position(), mode(), goto_xy(), mouse_motion();
     void cursor_on(), cursor_off(), mouse_reset();

     main(argc, argv)
     int argc;
     char *argv[];
     {
          char deltax, deltay, x, y;                                           

          if(argc!=2) {
               printf(" Используйте формат: mouser <видеорежим> ");
               exit(1);
          }

          mode(atoi(argv[1]));

          mouse_reset();  /* инициализация "мыши"  */
          cursor_on();    /* "включение" курсора   */

          do {
               goto_xy(0, 0);
               if(leftb_presed()) printf("Левая клавиша");
               if(rightb_pressed()) {
                    printf("Правая клавиша");
                    mouse_position(&x, &y);
                    printf("%d %d - ", x, y);
               }

               /* Отображение местоположения "мыши" */
               mouse_motion(&deltax, &deltay);                                 
               if(deltax || deltay) {
                    printf("Перемещение");
                    switch(deltax) {
                         case NOT_MOVED: break;
                         case RIGHT: printf("Вправо");
                              break;
                         case LEFT: printf("Влево");
                              break;
                    }
                    switch(deltay) {
                         case NOT_MOVED: break;
                         case UP: printf("Вверх");
                              break;
                         case DOWN: printf("Вниз");
                              break;
                    }
               }
          /* Цикл выполняется пока обе клавиши нажаты одновременно */
          } while(!(leftb_pressed() && rightb_pressed()));
          mode(3);
     }
                                                                               
     /* Установка видеорежима  */
     void mode(mode_code)
     int mode_code;
     {
          union REGS r;

          r.h.al = mode_code;
          r.h.ah = 0;
          int86(0x10, &r, &r);
     }

     /* Пересылка курсора в позицию, специфицированную
          координатами х и у */
     void goto_xy(x, y)
     int x, y;
     {
          union REGS r;

          r.h.ah=2;  /* функция адресации курсора  */
          r.h.dl = y; /* координаты столбца */
          r.h.dh = x; /* координаты строки */
          r.h.bh = 0; /* видеостраница */                                      
          int86(0x10, &r, &r);
     }

     /**********************************************************/
     /* Функции, обеспечивающие интерфейс с "мышью"            */
     /**********************************************************/

     /*  Включение курсора "мыши"  */
     void cursor_on()
     {
          int fnum;

          fnum = 1; /* отобразить курсор */
          cmouses( &fnum,  &fnum,  &fnum,  &fnum);
     }


     /*  Выключение курсора "мыши"  */
     void cursor_off()
     {
          int fnum;
                                                                               
          fnum = 2; /* стереть курсор */
          cmouses( &fnum,  &fnum,  &fnum,  &fnum);
     }


     /* Возвращает значение "истина", если нажата правая клавиша,
          и "ложь" в противном случае                            */

     rightb_pressed()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3;   /* Чтение позиции и статуса клавиши   */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          return arg2 & 2;
     }


     /* Возвращает значение "истина", если нажата левая клавиша,
          и "ложь" в противном случае                            */

     leftb_pressed()                                                           
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3;   /* Чтение позиции и статуса клавиши   */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          return arg2 & 1;
     }


     /*  Возвращает направление движения  */
     void mouse_motion(deltax, deltay)
     char *deltax, *deltay;
     {
          int fnum, arg2, arg3, arg4;

          fnum = 11; /* получить направление движения */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          if(arg3>0) *deltax = RIGHT;
          else if(arg3<0) *deltax = LEFT;
          else *deltax = NOT_MOVED;

          if(arg4>0) *deltay = DOWN;                                           
          else if(arg4<0) *deltay = UP;
          else *deltay = NOT_MOVED;
     }



     /* Установить координаты курсора "мыши" */
     void set_mouse_position(x, y)
     int x, y;
     {
          int fnum, arg2;

          fnum = 4; /* установка позиции */
          cmouses(&fnum, &arg2, &x, &y);
     }

     /* Возвращает координаты курсора "мыши" */
     void mouse_position(x, y)
     int *x, *y;
     {
          int fnum, arg2, arg3, arg4;
                                                                               
          fnum = 3; /* получить позицию и статус клавиши */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          *x = arg3;
          *y = arg4;
     }




     /* Установка "мыши" в исходное состояние   */

     void mouse_reset()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 0;  /* Установка "мыши" в исходное состояние  */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          if(fnum!=-1) {
          printf("Аппаратные или программные средства поддержки ");
          printf("'мыши' не инсталированы");
               exit(1);
                                                                               
          }
          if(arg2!=2) {
          printf("Разрешено использование только двухклавишной ");
          printf("'мыши'");
               exit(1);
          }
     }

          Перед использованием  этой  программы в командной строке DOS
     специфицируйте  видеорежим,  в  котором  вы   желаете   работать.
     Программа  будет  сообщать вам о направлении перемещения "мыши",а
     также о нажатых  клавишах  "мыши".  Вдобавок  ко  всему,  нажатие
     правой  клавиши будет вызывать отображение текущей позиции Х,  У.
     Нажатие обеих клавиш  вызовет  завершение  программы.  Попробуйте
     выполнить  эту  программу  в  различных  видеорежиах  и  обратите
     внимание на возникающие при этом эффекты.





           ВВОД ИНФОРМАЦИИ С ПОМОЩЬЮ "МЫШИ" В ПРОГРАММЕ РИСОВАНИЯ              
     -----------------------------------------------------------------
          Итак, вы   теперь   готовы   к   тому,   чтобы   разработать
     подпрограммы,  позволяющие  с помощью "мыши" управлять программой
     рисования. Интерфейс с "мышью" может быть добавлен в существующие
     подпрограммы    управления,   что,   естественно,   будет   более
     предпочтительно, чем разработка новых подпрограмм или модификация
     существующих.
           Такой путь выгоден  прежде  всего  тем,  что  функциональные
     возможности  клавиш  управления  курсором  сохраняются на все 100
     процентов,  и пользователь в  каждой  конкретной  ситуации  может
     выбрать   наиболее   подходящее   устройство   для  ввода  данных
     (клавиатура или "мышь").
           Прежде, чем "мышь" будет включена  как  устройство  ввода  в
     программу  рисования,  необходимо  разработать  две подпрограммы,
     учитывающие специфику "мыши".  Первая  подпрограмма  -  wait_on()
     позволяет  реализовать процесс ожидания отпускания (освобождения)
     специфицированной клавиши пользователем.  Анализ  подобного  рода
     имеет весьма большое значение, так как соответствующие прерывания
     генерируются  постоянно,  пока   клавиша   не   нажата.   (Однако
     невозможно  обеспечить  такое  мгновенное  нажатие на клавишу,  в
     результате которого сформировалось бы лишь одно  прерывание).  Во
     многих  подпрограммах  наоборот  важно  избежать такой ситуации и         
     поэтому в них каждое нажатие на клавишу генерирует  (точнее будет
     сказать  кажется,  что  генерирует)  только одно прерывание за то
     время, пока клавиша нажата. В соответствии с этим, ваша программа
     должна   обращаться  к  фунции  wait_on(),  представленной  ниже,
     непосредственно перед выполнением  и  после  того,  когда  нажата
     соответствующая клавиша.


     /* Возвращает 1, если специфицированная клавиша не нажата */

     void wait_on(button)
     int button;
     {
          if(button== LEFTB)
               while(leftb_pressed());
          else
               while(rightb_pressed());
     }

          Макросы LEFTB  и RIGHTB,  представленные ниже,  используются
     при обращении к wait_on().
                                                                               

     #define LEFTB     1
     #define RIGHTB    2

          Второй необходимой  вам функцией является mouse_menu().  Эта
     функция отображает однострочное  меню  и  позволяет  пользователю
     осуществлять  выбор из него элементов путем перемещения "мыши" на
     плоскости (и, соответственно, курсора "мыши" по экрану) и нажатия
     любой  клавиши  "мыши".  Эта  функция  может  работать только в 4
     графическом режиме. Функции передается двумерный массив символов,
     который   содержит   элементы   меню   (которые   может   выбрать
     пользователь),  значение каждого элемента меню (его код),а  также
     координаты  Х  и  У  отображения меню на экране.  Массив символов
     определяет  максимальную  длину  каждого  элемента  меню   в   19
     символов.   Функция   возвращает   в  качестве  результата  номер
     выбранного пользователем элемента меню, начиная с 0, или -1, если
     пользователь  не выбрал ни один из элементов меню.  Когда функция
     начинает свою работу,  то она вначале вычисляет длину в  пикселах
     (элементах растра) каждого элемента меню,  после чего резервирует
     пространство по начальной и конечной  точке  растра  для  каждого
     элемента  меню,  одновременно  запоминая эту информацию в массиве
     len. (В четвертом графическом режиме каждый символ имеет высоту в         
     8   точек  растра  и  ширину  в  16  точек  растра.)  После  этих
     вычислений, функция переходит в состояние ожидаения прерывания от
     клавиш  "мыши".  При  этом  осуществляется  анализ нажата или нет
     клавиша "мыши" в момент нахождения ее курсора в области  меню, и,
     если  да,  то в месте расположения какого элемента меню.  Функция
     mouse_menu() приведена ниже.


     /* Отображает однострочное меню для "мыши" и возвращает
        код выбранного пользователем элемента меню          */

     mouse_menu(count, item, x, y)
     int count;           /* количество элементов меню */
     char item[][20];      /* элементы меню */
     int x, y;           /* позиции отображения */
     {
          int i, len[MENU_MAX][2], t;
          int mousex, mousey;

          goto_xy(x, y);
          t = 0;
          for(i=0; i<count; i++) {                                             
               printf("%s   ", item[i]);
               len[i][0] = t;
               /* каждый символ имеет ширину в 16 точек растра */
               len[i][1] = t + strlen(item[i])*16;
               t = len[i][1] + 32; /* добавляется два пробела между
                                   элементами меню */
          }

          /* ожидание выбора пользователем элемента меню */
          do {
               if(rightb_pressed() || leftb_pressed()) break;
          } while(!kbhit());
          /* ожидание нажатия клавиши */
          while(rightb_pressed() || leftb_pressed());

          /* получить текущую позицию курсора "мыши" */
          mouse_position(&mousex, &mousey);

          /* анализируется, находится ли курсор в пределах меню */
               if(mousey>=0 && mousey<8)  /* символ имеет высоту
                                   8 точек растра */
                    for(i=0; i<count; i++) {                                   
                         if(mousex>len[i][0] && mousex<len[i][1])
                              return i;
                    }
               return i;
          }
           returtn -1; /* выбор из меню не осуществлялся */
       }



                       ОСНОВНОЙ ЦИКЛ РАБОТЫ ПРОГРАММЫ
     -----------------------------------------------------------------

          В отличие  от  всей  остальной  части  программы  рисования,
     фрагмент  функции   main()   претерпел   наиболее   зеначительные
     изменения.  В  функцию  main() добавлены,  в частности,  функции,
     обеспечивающие интерфейвс с мышью.  Текст функции  main  приведен
     ниже.

     main()
     {
          char done=0;                                                         

          mode(4); /* переключатель в 4 графический режим для
                    адаптеров CGA/EGA  */
          palette(0); /* палитра 0  */
          mouse_reset(); /* инсталяция "мыши" */

          xhairs(x, y); /* установить графический курсор */
          set_mouse_position(y*2, x); /* установить начальную позицию
                                         курсора "мыши" */
          do {
               /* просматривается, перемещалась ли "мышь" */
               mouse_motion(&deltax, &deltay);
               if(deltax || deltay) read_mouse();
               /* проверка нажатия клавиши */
               if(leftb_pressed() || rightb_pressed())
                    read_mouse();
               if(kbhit()) {
                    done = read_kb();
               /* перемещение "мыши" в соответствием с размещением
                    графического курсора */
                    set_mouse_position(y*2, x);
               }                                                               
          } while (!done);
          mode(2);
     }



          Как вы можете видеть, функции main(), за исключением функции
     done(),  не  оперируют  локальными переменными.  Вместо этого все
     управляющие и  вычисляемые  переменные,  необходимые  для  работы
     программы,  являются  глобальными,  что  позволяет  как  функциям
     работы с клавиатурой,  так и функциям работы с "мышью", избавится
     от  длинного  списка  аргументов  при  обращении  к ним,  а также
     упростить их использование в программе.  Как  вы  видите,  анализ
     типа  прерывания  (от  клавиатуры  или  от "мыши") осуществляется
     внутри  цикла.  При  поступлении  прерывания  от  этих  устройств
     вызываются соответствующие функции.  Заметьте,  что курсор "мыши"
     при  этом  не  выключается.  Взамен  этого  во  время  выполнения
     рисующей  части  программы  графический  курсор  используется для
     индикации текущей позиции на экране. Курсор "мыши" активизируется
     лишь при работе с однострочным меню.

          Функция read_kb(),  которая  обеспечивает  процесс  ввода  с         
     клавиатуры, представлена ниже. В основном она ничем не отличается
     от оригинальной версии и выполняет довольно значительные по своей
     роли функции.

     /* Чтение и обработка команд, вводимых с клавиатуры */

     read_kb()
     {
          union k{
               char c[2];
               int i;
          } key;

          key.i = bioskey(0);
          xhairs(x, y); /* стереть графический курсор */
          if(!key.c[0]) switch(key.c[1]){
               case 75:  /* влево */
                    if(on_flag) line(x, y, x, y-inc, cc);
                    y -= inc;
                    break;
               case 77:  /* вправо */
                    if(on_flag) line(x, y, x, y+inc, cc);                      
                    y += inc;
                    break;
               case 72:  /* вверх */
                    if(on_flag) line(x, y, x-inc, y, cc);
                    x -= inc;
                    break;
               case 80:  /* вниз */
                    if(on_flag) line(x, y, x+inc, y, cc);
                    x += inc;
                    break;
               case 71:  /* влево вверх */
                    if(on_flag) line(x, y, x-inc, y-inc, cc);
                    y -= inc; x -= inc;
                    break;
               case 73:  /* вправо вверх */
                    if(on_flag) line(x, y, x-inc, y+inc, cc);
                    y += inc; x -= inc;
                    break;
               case 79: /* влево вниз */
                    if(on_flag) line(x, y, x+inc, y-inc, cc);
                    y -= inc; x += inc;
                    break;                                                     
               case 81:  /* вправо вниз */
                    if(on_flag) line(x, y, x+inc, y+inc, cc);
                    y += inc; x += inc;
                    break;
               case 59: inc = 1; /* F1 - уменьшить скорость */
                    break;
               case 60: inc = 5; /* F2 - увеличить скорость */
                    break;
          }
          else switch(tolower(key.c[0])) {
               case 'o': on_flag = !on_flag; /* переключатеоль
                                   шаблона цвета */
                    break;
               case '1': cc = 1; /* цвет 1 */
                    break;
               case '2': cc = 2; /* цвет 2 */
                    break;
               case '3': cc = 3; /* цвет 3 */
                    break;
               case '0': cc = 0; /* цвет 0 */
                    break;
               case 'b': box(startx, starty, endx, endy, cc);                  
                    break;
               case 'f': fill_box(startx, starty, endx, endy, cc);
                    break;
               case 'l': line(startx, starty, endx, endy, cc);
                    break;
               case 'c': circle(startx, starty, endy-starty, cc);
                    break;
               case 'h': fill_circle(startx, starty, endy-starty, cc);
                    break;
               case 's': save_pic();
                    break;
               case 'r': load_pic();
                    break;
               case 'm': /* переместить область */
                    move(startx, starty, endx, endy, x, y);
                    break;
               case 'x': /* копировать область */
                    copy(startx, starty, endx, endy, x, y);
                    break;
               case 'd': /* определить объект для вращения */
                    sides = define_object(object, x, y);
                    break;                                                     
               case 'a': /* вращать объект */
                    rotate_object(object, 0.05, x, y, sides);
                    break;
               case '\r': /* установить конечную точку для линии,
                             окружности или прямоугольника */
                    if(first_point) {
                         startx = x; starty = y;
                    }
                    else {
                         endx = x; endy = y;
                    }
                    first_point = !first_point;
                    break;
               case 'p': pal_num = pal_num==1 ? 2:1;
                    palette(pal_num);
          }
          /* восстановить изображение графического курсора */
          xhairs(x, y);
          if(tolowel(key.c[0])=='q') return 1;
          return 0;
     }
                                                                               
          Функция read_mouse(),  которая обрабатывает ввод от  "мыши",
     представлена ниже.


     /* Чтение и обработка команд, вводимых с помощью "мыши" */

     read_mouse()
     {
          int oldx, oldy;
          int choice;

          oldx = x; oldy = y;
          xhairs(x, y); /* стереть с текущей позиции */

          /* нажаты обе клавиши для активизации меню */
          if(rightb_pressed() && leftb_pressed()) {
               choice = menu(); /* получить результат выбора
                                   из меню */
               switch(choice) {
                case 0: box(startx, starty, endx, endy, cc);
                     break;
                case 1: circle(startx, starty, endy-starty, cc);               
                     break;
                case 2: line(startx, starty, endx, endy, cc);
                     break;
                case 3: fill_box(startx, starty, endx, endy, cc);
                     break;
                case 4: fill_circle(startx, starty, endy-starty, cc);
                     break;
               }
          }

          /* правая клавиша определяет конечную точку фигуры */

          else if(rightb_pressed()) {
               if(first_point) {
                    startx = x; starty = y;
               }
               else {
                    endx = x; endy = y;
               }
               first_point = !first_point;
               wait_on(RIGHTB); /* ожидание освобождения клавиши */
          }                                                                    

          if(deltax || deltay) {
               mouse_position(&y, &x);
               y = y / 2; /* нормализация координат виртуального
                         экрана */
               /* нажмите левую клавишу для рисования */
               if(leftb_pressed()) mouse_on_flag = 1;
               else mouse_on_flag = 0;
               if(mouse_on_flag) line(oldx, oldy, x, y, cc);
          }
          /* восстановить изображение графического курсора */
          xhairs(x, y);
     }

          Функция read_mouse() работает следующим  образом. Во-первых,
     анализируется факт одновременного нажатия двух клавиш.  Если факт
     имеет место,  то путем обращения к функции menu()  активизируется
     меню,  которое  устанавливается  и  управляется путем обращения к
     mouse_menu().  Если  пользователь  осуществил  выбор  одного   из
     элементов меню, то инициируется соответствующее действие. Так как
     в состав  текущего  меню  входят  различные  фигуры,  из  которых
     складывается изображение,  - прямоугольники,  окружности, линии и         
     действия,  позволяющие,  например,  закрашивать эти фигуры,  то с
     помощью  "мыши" вы можете выбрать один из этих элементов будущего
     рисунка или действие.  (вы можете также включить в меню средства,
     позволяющие пользователю выбирать цвета и устанавливать палитру).

          Правая клавиша  используется  для определения конечной точки
     линий,  прямоугольников и окружностей,  точно так же, как клавиша
     <ВВОД>  используется  для этих же целей при работе с клавиатурой.
     Установите "мышь" в  первой  конечной  точке  объекта  и  нажмите
     правую клавишу. Затем переместите "мышь" во вторую конечную точку
     и опять нажмите клавишу. Так вы получите изображение интересующей
     вас фигуры.

          Когда левая клавиша не нажата,  "мышь" может перемещаться по
     экрану,  не оставляя за  собой  никакого  следа.  Это  происходит
     потому,  что  по  умолчанию  перо "мыши" считается поднятым.  Для
     того,  чтобы получить возможность "писать мышью" (опустить перо),
     необходимо  нажать  левую  клавишу.  Пока  клавиша  нажата,  перо
     считается опущенным.

          В конце концов,  если "мышь" изменила свои координаты, будут
     обновлены значения счетчиков X и Y.                                       

          Функция menu(),    представленная   ниже,   использует   для
     установки  и  управления  меню  функцию  mouse_menu(),  описанную
     ранее.

     /*  Отображение меню */
     menu()
     {
          register int i, j;
          char far *ptr = (char far *) 0xB8000000; /* Указатель на
                                                       CGA-память */
          char far *temp;
          unsigned char buf[14][80]; /* для хранения содержимого
                                        экрана */
          int x, y, choice;
          char items[][20] = {
               "BOX",
               "CIRCLE",
               "LINE",
               "FILL BOX",
               "FILL CIRCLE"
          };                                                                   

          temp = ptr;
          /* сохранение верхней части текущего экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт */
                    *temp = 0; *(temp+8152) = 0; /* очистка верхней
                                                  части экрана */
                    temp++;
               }

          goto_xy(0, 0);
          /* ожидание, которое будет прервано в результате нажатия на
             клавишу */
          while(rightb_pressed() || leftb_pressed());

          cursor_on();

          choice = mouse_menu(5, items, 0, 0);

          cursor_off();                                                        
          temp = ptr;
          /* восстановление изображения верхней части экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    *temp = buf[i][j];
                    *(temp+8152) = buf[i][j+1];
                    temp++;
               }
          return choice;
     }

          В процессе работы функция прежде всего сохраняет изображение
     верхней части  текущего  экрана,  не  ожидая  нажатия  какой-либо
     клавиши.  Затем  следует "включение" курсора "мыши" и обращение к
     функции mouse_menu(). После передачи управления от функции mouse_
     menu()    курсор    включается,    восстанавливается   предыдущее
     изображение  верхней   части   экрана,   и   функция   возвращает
     соответствующий код выбранного элемента меню.



                   ОПРЕДЕЛЕНИЕ ОБЪЕКТОВ С ПОМОЩЬЮ "МЫШИ"                       
     -----------------------------------------------------------------

          Оригинальная версия    программы     рисования     допускает
     использование    объектов,   определяемых   с   помощью   функции
     define_object(),  путем специфицирования конечных  точек  каждого
     сегмента  линии.  Каждый  определенный  ранее  объект  может быть
     подвергнут    вращению.    Версия    функции     define_object(),
     представленная  ниже,  также позволяет с помощью "мыши" указывать
     конечные точки (габариты) объектов.


     /* Определение объекта по его габаритным точкам с помощью
        клавиатуры или "мыши" */
     define_object(ob, x, y)
     double ob[][4];
     int x, y;
     {
          union k{
               char c[2];
               int i;
          } key;
          register int i, j;                                                   
          char far *ptr = (char far *) 0xB8000000; /* Указатель на
                                   CGA-память */
          char far *temp;
          unsigned char buf[14][80];
          int sides=0;
          int deltax, deltay, oldx, oldy;

          temp = ptr;
          /* сохранение верхней части текущего экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт */
                    *temp = 0; *(temp+8152) = 0; /* очистка верхней
                                                    части экрана */
                    temp++;
               }

          i = 0;
          key.i = 0;
          xhairs(x, y);
          do {                                                                 
               goto_xy(0, 0);
               printf("Определите сторону %d", sides+1);
               if(i==0) printf("Укажите первую габаритную точку");
               else printf("Укажите вторую габаритную точку");

               do {
     /************** Добавочная часть для мыши. *******************/
               /* Просматривается, если "мышь" перемещается */

                    mouse_motion(&deltax, &deltay);
               /* Используйте левую клавишу для определения точки*/
                    if(leftb_pressed()) {
                         /* стирание графического курсора */
                         xhairs(x, y);
                         /* запоминание координат точки */
                         ob[sides][i++] = (double) x;
                         ob[sides][i++] = (double) y;
                         if(i==4) {
                              i = 0;
                              sides++;
                         }
                         break;                                                
                    }
               } while(!kbhit() && !deltax && ! deltay);
               if(leftb_pressed()) wait_on(LEFTB);

               if(deltax || deltay) {
               /* если "мышь" переместилась, то пересчет координат*/
                    oldx = x; oldy = y;
                    mouse_position(&y, &x);
                    y = y / 2; /* нормализация коодинат виртуального
                                   экрана*/
                    /* стирание графического курсора */
                    xhairs(oldx, oldy);
               }
     /********** Конец добавочной части для "мыши" *****************/

               else if(kbhit()) {
                    key.i = bioskey(0);
                    /* изображение графического курсора */
                    xhairs(x, y);
                    if(key.c[0]==13) {
                        /* используйте <ВВОД> для определения точки*/
                         ob[sides][i++] = (double) x;                          
                         ob[sides][i++] = (double) y;
                         if(i==4) {
                              i = 0;
                              sides++;
                         }
                    }

                   /* если клавиши управления курсором, то перемещение
                        графического курсора */
                    if(!key.c[0]) switch(key.c[1]) {
                         case 75: /* влево */
                              y-=1;
                              break;
                         case 77: /* вправо */
                              y+=1;
                              break;
                         case 72: /* вверх */
                              x-=1;
                              break;
                         case 80: /* вниз */
                              x+=1;
                              break;                                           
                         case 71: /* влево вверх */
                              x-=1; y-=1;
                              break;
                         case 73: /* вправо вверх */
                              x-=1; y+=1;
                              break;
                         case 79: /* влево вниз */
                              x+=1; y-=1;
                              break;
                         case 81: /* вправо вниз */
                              x+=1; y+=1;
                              break;
                    }
               }
               if(key.c[1] != 59) xhairs(x, y);
          } while(key.c[1] != 59); /* нажмите F1 для остановки */

          temp = ptr;
          /* востановление изображения в верхней части экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                                                                               
                    *temp = buf[i][j];
                    *(temp+8152) = buf[i][j+1];
                    temp++;
               }
          return sides;
     }


          Как вы   можете   видеть,  левая  клавиша  используется  для
     указания габаритных точек.  Движение "мыши" кодируется точно  так
     же,  как  и  в функции read_mouse().  За исключением того,  что в
     функцию добавлен фрагмент исходного текста  для  поддержки  ввода
     информации   с   помощью   "мыши",  оригинальная  версия  функции
     define_object()  больше  никаких  изменений  не  претерпела.  Для
     указания  очередной  габаритной точки переместите "мышь" в нужную
     позицию и нажмите клавишу.





                ПОЛНЫЙ ТЕКСТ МОДИФИЦИРОВАННОЙ ПРОГРАММЫ РИСОВАНИЯ              
     -----------------------------------------------------------------

          Ниже приведен  исходный  текст  программы рисования с учетом
     всех изменений и дополнений, обсужденных выше.

     /* Эта версия программы рисования для адаптеров  CGA/EGA
        позволяет использовать "мышь" фирмы Microsoft/IBM,
        а также альтернативное устройство ввода (клавиатуру)
     */
     #define NUM_SIDES 20 /* Максимальное число сторон фигуры.
                               По желанию можно увеличить */
     #define NOT_MOVED 0
     #define RIGHT     1
     #define LEFT      2
     #define UP        3
     #define DOWN      4
     #define LEFTB     1
     #define RIGHTB    2

     #define MENU_MAX 20 /* Максимальное число элементов меню */

     #include "dos.h"                                                          
     #include "stdio.h"
     #include "math.h"

     void mode(), line(), box(), fill_box();
     void mempoint(), palette(), xhairs();
     void circle(), plot_circle(), fill_circle();
     void rotate_point(), rotate_object(), goto_xy();
     void display_object(), copy(), move();
     void save_pic(), load_pic();
     void set_mouse_position(), mouse_position(), mouse_motion();
     void cursor_on(), cursor_off(), wait_on(), mouse_reset();

     unsigned char read_point();

     /* Это массив предназначен для хранения координат динамически
           определяемой фигуры   */

     double object[NUM_SIDES][4];

     double asp_ratio; /* коэффициент сжатия окружностей */

          int x=10, y=10; /* текущая позиция экрана */                         
          int cc=2; /* текущий цвет */
          int on_flag=1, mouse_on_flag=0; /* перо опущено или
                                              поднято */
          int pal_num=1;                 /* номер палитры */

          /* Габаритные точки, определяющие линию, окружность
          или прямоугольник */
          int startx=0, starty=0, endx=0, endy=0, first_point=1;
          int inc=1;       /* приращение движения */
          int sides=0;     /* номер стороны определяемой фигуры */
          int deltax, deltay;    /* "мышь" изменяет данные в
                                     индицированной позиции */


     main()
     {
          char done=0;

          mode(4); /* переключатель в 4 графический режим для
                         адаптеров CGA/EGA  */
          palette(0);    /* палитра 0  */
          mouse_reset(); /* инсталяция "мыши" */                               

          xhairs(x, y);  /* установить графический курсор */
          set_mouse_position(y*2, x); /* установить начальную позицию
                                        курсора "мыши" */
          do {
               /* просматривается, перемещалась ли "мышь" */
               mouse_motion(&deltax, &deltay);
               if(deltax || deltay) read_mouse();
               /* проверка нажатия клавиши */
               if(leftb_pressed() || rightb_pressed())
                    read_mouse();
               if(kbhit()) {
                    done = read_kb();
               /* перемещение "мыши" в соответствии с размещением
                    графического курсора */
                    set_mouse_position(y*2, x);
               }
          } while (!done);
          mode(2);
     }

                                                                               
     /* Чтение и обработка команд, вводимых с помощью "мыши" */
     read_mouse()
     {
          int oldx, oldy;
          int choice;

          oldx = x; oldy = y;
          xhairs(x, y); /* стереть с текущей позиции */

          /* нажаты обе клавиши для активизации меню */
          if(rightb_pressed() && leftb_pressed()) {
               choice = menu(); /* получить результат выбора
                                   из меню */
               switch(choice) {
                 case 0: box(startx, starty, endx, endy, cc);
                      break;
                 case 1: circle(startx, starty, endy-starty, cc);
                      break;
                 case 2: line(startx, starty, endx, endy, cc);
                      break;
                 case 3: fill_box(startx, starty, endx, endy, cc);
                      break;                                                   
                 case 4: fill_circle(startx, starty, endy-starty, cc);
                      break;
               }
          }

          /* правая клавиша определяет конечную точку фигуры */
          else if(rightb_pressed()) {
               if(first_point) {
                    startx = x; starty = y;
               }
               else {
                    endx = x; endy = y;
               }
               first_point = !first_point;
               wait_on(RIGHTB); /* ожидание освобождения клавиши */
          }

          if(deltax || deltay) {
               mouse_position(&y, &x);
               y = y / 2; /* нормализация координат виртуального
                         экрана */
               /* нажмите левую клавишу для рисования */                       
               if(leftb_pressed()) mouse_on_flag = 1;
               else mouse_on_flag = 0;
               if(mouse_on_flag) line(oldx, oldy, x, y, cc);
          }
          /* восстановить изображение графического курсора */
          xhairs(x, y);
     }

     /* Чтение и обработка команд, вводимых с клавиатуры */
     read_kb()
     {
          union k{
               char c[2];
               int i;
          } key;

          key.i = bioskey(0);
          xhairs(x, y); /* стереть графический курсор */
          if(!key.c[0]) switch(key.c[1]){
               case 75:  /* влево */
                    if(on_flag) line(x, y, x, y-inc, cc);
                    y -= inc;                                                  
                    break;
               case 77:  /* вправо */
                    if(on_flag) line(x, y, x, y+inc, cc);
                    y += inc;
                    break;
               case 72:  /* вверх */
                    if(on_flag) line(x, y, x-inc, y, cc);
                    x -= inc;
                    break;
               case 80:  /* вниз */
                    if(on_flag) line(x, y, x+inc, y, cc);
                    x += inc;
                    break;
               case 71:  /* влево вверх */
                    if(on_flag) line(x, y, x-inc, y-inc, cc);
                    y -= inc; x -= inc;
                    break;
               case 73:  /* вправо вверх */
                    if(on_flag) line(x, y, x-inc, y+inc, cc);
                    y += inc; x -= inc;
                    break;
               case 79: /* влево вниз */                                       
                    if(on_flag) line(x, y, x+inc, y-inc, cc);
                    y -= inc; x += inc;
                    break;
               case 81:  /* вправо вниз */
                    if(on_flag) line(x, y, x+inc, y+inc, cc);
                    y += inc; x += inc;
                    break;
               case 59: inc = 1; /* F1 - уменьшить скорость */
                    break;
               case 60: inc = 5; /* F2 - увеличить скорость */
                    break;
          }
          else switch(tolower(key.c[0])) {
               case 'o': on_flag = !on_flag; /* переключатель
                                                шаблона цвета */
                    break;
               case '1': cc = 1; /* цвет 1 */
                    break;
               case '2': cc = 2; /* цвет 2 */
                    break;
               case '3': cc = 3; /* цвет 3 */
                    break;                                                     
               case '0': cc = 0; /* цвет 0 */
                    break;
               case 'b': box(startx, starty, endx, endy, cc);
                    break;
               case 'f': fill_box(startx, starty, endx, endy, cc);
                    break;
               case 'l': line(startx, starty, endx, endy, cc);
                    break;
               case 'c': circle(startx, starty, endy-starty, cc);
                    break;
               case 'h': fill_circle(startx, starty, endy-starty, cc);
                    break;
               case 's': save_pic();
                    break;
               case 'r': load_pic();
                    break;
               case 'm': /* переместить область */
                    move(startx, starty, endx, endy, x, y);
                    break;
               case 'x': /* копировать область */
                    copy(startx, starty, endx, endy, x, y);
                    break;                                                     
               case 'd': /* определить объект для вращения */
                    sides = define_object(object, x, y);
                    break;
               case 'a': /* вращать объект */
                    rotate_object(object, 0.05, x, y, sides);
                    break;
               case '\r': /* установить конечную точку для линии,
                         окружности или прямоугольника */
                    if(first_point) {
                         startx = x; starty = y;
                    }
                    else {
                         endx = x; endy = y;
                    }
                    first_point = !first_point;
                    break;
               case 'p': pal_num = pal_num==1 ? 2:1;
                    palette(pal_num);
          }
          /* восстановить изображение графического курсора */
          xhairs(x, y);
          if(tolowel(key.c[0])=='q') return 1;                                 
          return 0;
     }

     /* Установить палитру */
     void palette(pnum)
     int pnum;
     {
          union REGS r;

          r.h.bh = 1; /* кодирование 4 графического режима */
          r.h.bl = pnum;
          r.h.ah = 11; /* функцкия установления палитры */
          int86(0x10, &r, &r);
     }

     /* Установить видеорежим */
     void mode(mode_code)
     int mode_code;
     {
          union REGS r;

          r.h.al = mode_code;                                                  
          r.h.ah = 0;
          int86(0x10, &r, &r);
     }

     /* Рисование прямоугольника */
     void box(startx, starty, endx, endy, color_code)
     int startx, starty, endx, endy, color_code;
     {
          line(startx, starty, endx, starty, color_code);
          line(startx, starty, startx, endy, color_code);
          line(startx, endy, endx, endy, color_code);
          line(endx, starty, endx, endy, color_code);
     }


     /* Рисование линии в специфицированном цвете с использованием
        основного алгоритма Брезенхама  */
     void line(startx, starty, endx, endy, color)
     int startx, starty, endx, endy, color;
     {
          register int t, distance;
          int x=0, y=0, delta_x, delta_y;                                      
          int incx, incy;

          /* определение расстояния в обоих направлениях */
          delta_x = endx-startx;
          delta_y = endy-starty;

          /* Вычисление направления приращения. Приращение
          вычисляется относительно 0 как для горизонтальной,
          так и для вертикальной линии
          */
          if(delta_x>0) incx = 1;
          else if(delta_x==0) incx = 0;
          else incx=-1;

          if(delta_y>0) incy = 1;
          else if(delta_y==0) incy = 0;
          else incy=-1;

          /* Определяется, какое расстояние больше */
          delta_x = abs(delta_x);
          delta_y = abs(delta_y);
          if(delta_x>delta_y) distance = delta_x;                              
          else distance = delta_y;

          /* Вычерчиывние линии */
          for(t=0; t<=distance+1; t++) {
               mempoint(startx, starty, color);
               x+=delta_x;
               y+=delta_y;
               if(x>distance) {
                    x-=distance;
                    startx+=incx;
               }
               if(y>distance) {
                    y-=distance;
                    starty+=incy;
               }
          }
     }

     /* Закрашивание прямоугольника специфицированным цветом */
     void fill_box(startx, starty, endx, endy, color_code)
     int startx, starty, endx, endy, color_code;
     {                                                                         
          register int i, begin, end;

          begin = startx<endx ? startx : endx;
          end = startx>endx ? startx : endx;

          for(i=begin; i<=end; i++)
               line(i, starty, i, endy, color_code);
     }

     /* Рисование окружности с использованием целочисленного алгоритма
        Брезенхама */
     void circle(x_center, y_center, radius, color_code)
     int x_center, y_center, radius, color_code;
     {
          register int x, y, delta;

          asp_ratio = 1.0; /* Если Вас не удовлетворяют предлагаемые
                              пропорции фигуры, измените значение этой
                              переменной */
          y = radius;
          delta = 3 - 2 * radius;
                                                                               
          for(x=0; x<y; ) {
               plot_circle(x, y, x_center, y_center, color_code);

               if(delta < 0)
                    delta += 4*x+6;
               else {
                    delta += 4*(x-y)+10;
                    y--;
               }
               x++;
          }
          x=y;
          if(y) plot_circle(x, y, x_center, y_center, color_code);
     }


     /* Непосредственное вычерчивание окружности по определенным
        пользователем точкам */
     void plot_circle(x, y, x_center, y_center, color_code)
     int x, y, x_center, y_center, color_code;
     {
          int startx, endx, x1, starty, endy, y1;                              

          starty = y*asp_ratio;
          endy = (y+1)*asp_ratio;
          startx = x*asp_ratio;
          endx = (x+1)*asp_ratio;

          for(x1=startx; x1<endx; ++x1) {
               mempoint(x1+x_center, y+y_center, color_code);
               mempoint(x1+x_center, y_center-y, color_code);
               mempoint(x_center-x1, y_center-y, color_code);
               mempoint(x_center-x1, y+y_center, color_code);
          }

          for(y1=starty; y1<endy; ++y1) {
               mempoint(y1+x_center, x+y_center, color_code);
               mempoint(y1+x_center, y_center-x, color_code);
               mempoint(x_center-y1, y_center-x, color_code);
               mempoint(x_center-y1, x+y_center, color_code);
          }
     }

                                                                               
     /* Закрашивание окружности путем циклического обращения к функции
        circle() с меньшим радиусом */
     void fill_circle(x, y, r, c)
     int x, y, r, c;
     {
          while(r) {
               circle(x, y, r, c);
               r--;
          }
     }


     /* Отображение графического курсора  */
     void xhairs(x, y)
     int x, y;
     {
          line(x-4, y, x+3, y, 1 | 128);
          line(x, y+4, x, y-3, 1 | 128);
     }


     /* Запись точки непосредственно в CGA/EGA */                              
     void mempoint(x, y, color_code)
     int x, y, color_code;
     {
          union mask {
               char c[2];
               int i;
          } bit_mask;
          int i, index, bit_position;
          unsigned char t;
          char xor; /* xor - цвет изображения записывается или
                       перезаписывается */
          char far *ptr = (char far *) 0xB8000000; /* Указатель
                                                      CGA памяти */
          bit_mask.i=0xFF3F;  /* 11111111 00111111 в двоичном
                              коде   */

          /* проверка значений для 4 режима */
          if(x<0 || x>199 || y<0 || y>319) return;

          xor= color_code & 128; /* просматривается, если режим
                         установлен */
          color_code = color_code & 127; /* маска старшего бита */             

          /* установка маски бита и кода цвета для правой ячейки
             памяти */
           bit_position = y%4;
           color_code<<=2*(3-bit_position);
           bit_mask.i>>=2*bit_position;

           /* поиск байта для корректировки в видеопамяти */
           index = x*40 +(y >> 2);
           if(x % 2) index += 8152; /* если дополнительно
                                       использовался 2-й сегмент
                                       памяти */

           /* запись цвета */
           if(!xor) { /* режим перезаписи */
                t = *(ptr+index) & bit_mask.c[0];
                *(ptr+index) = t | color_code;
           }
           else { /* режим записи цвета */
                t = *(ptr+index) | (char)0;
                *(ptr+index) = t ^ color_code;
           }                                                                   
     }


     /* Непосредственное чтение байта из видеопамяти CGA/EGA
        в режиме 4 */
     unsigned char read_point(x, y)
     int x, y;
     {
          union mask {
               char c[2];
               int i;
          } bit_mask;
          int i, index, bit_position;
          unsigned char t;
          char xor; /* xor - цвет изображения записывается или
                       перезаписывается */
          char far *ptr = (char far *) 0xB8000000; /* Указатель
                                                      CGA памяти */
          bit_mask.i=0xFF3F;  /* 11111111 00111111 в двоичном коде */

          /* проверка значений для 4 режима */
          if(x<0 || x>199 || y<0 || y>319) return;                             

          /* установка маски бита и кода цвета для правой ячейки
             памяти */
           bit_position = y%4;
           bit_mask.i<<=2*(3-bit_position);

           /* поиск нужного байта в видеопамяти */
           index = x*40 +(y >> 2);
           if(x % 2) index += 8152; /* если дополнительно
                                       использовался 2-й блок
                                       памяти */

          /* чтение цвета */
           t = *(ptr+index) & bit_mask.c[0];
          t >>=2*(3-bit_position);
          return t;
     }



     /* сохранение видео изображения на экране */
     void save_pic()                                                           
     {
          char fname[80];
          FILE *fp;
          register int i, j;
          char far *ptr = (char far *) 0xB8000000; /* Указатель
                                                      CGA памяти */
          char far *temp;
          unsigned char buf[14][80]; /* буфер содержимого экрана */


          temp = ptr;
          /* сохранение верхней части текущего экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт */
                    *temp = 0; *(temp+8152) = 0; /* очистка верхней
                                                    части экрана */
                    temp++;
               }

          goto_xy(0, 0);                                                       
          printf("Имя файла : ");
          gets(fname);
          if(!(fp=fopen(fname, "wb"))) {
               printf("Файл не может быть открыт\n");
               return;
          }

          temp = ptr;
          /* восстановление изображения верхней части экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    *temp = buf[i][j];
                    *(temp+8152) = buf[i][j+1];
                    temp++;
               }

          /* запись изображения в файл */
          for(i=0; i<8152; i++) {
               putc(*ptr, fp); /* четный байт */
               putc(*(ptr+8152), fp); /* нечетный байт */
               ptr++;
          }                                                                    
          fclose(fp);
     }


     /* загрузка в память изображения из файла */
     void load_pic()
     {
          char fname[80];
          FILE *fp;
          register int i, j;
          char far *ptr = (char far *) 0xB8000000; /* Указатель
                                   CGA памяти */
          char far *temp;
          unsigned char buf[14][80]; /* буфер содержимого экрана */


          temp = ptr;
          /* сохранение верхней части текущего экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт */            
                    *temp = 0; *(temp+8152) = 0; /* очистка верхней
                                                    части экрана */
                    temp++;
               }

          goto_xy(0, 0);
          printf("Имя файла : ");
          gets(fname);
          if(!(fp=fopen(fname, "rb"))) {
               goto_xy(0, 0);
               printf("Файл не может быть открыт\n");
               temp = ptr;
               /* восстановление изображения верхней части экрана */
               for(i=0; i<14; i++)
                    for(j=0; j<80; j+=2) {
                         *temp = buf[i][j];
                         *(temp+8152) = buf[i][j+1];
                         temp++;
                    }
               return;
          }
                                                                               
          /* Загрузка изображения из файла */
          for(i=0; i<8152; i++) {
               *ptr = getc(fp); /* четный байт */
               *(ptr+8152) = getc(fp); /* нечетный байт */
               ptr++;
          }
          fclose(fp);
     }


     /* Перемещение курсора в специфицированную позицию */
     void goto_xy(x, y)
     int x, y;
     {
          union REGS r;

          r.h.ah=2; /* функция адресации курсора */
          r.h.dl = y; /* координаты столбца */
          r.h.dh = x; /* координаты строки */
          r.h.bh = 0; /* видеостраница */
          int86(0x10, &r, &r);
     }                                                                         



     /* Перемещение области в другое место */
     void move(startx, starty, endx, endy, x, y)
     int startx, starty; /* верхняя левая координата */
     int endx, endy; /* нижняя правая координата места, куда будет
                        перемещена область */
     int x, y; /* верхняя левая координата области, откуда будет
                  перемещено изображение*/
     {
          int i, j;
          unsigned char c;

          for(; startx<=endx; startx++, endx++)
               for(i=starty, j=y; i<=endy; i++, j++) {
                    c = read_point(startx, i); /* чтение точки */
                    mempoint(startx, i, 0); /* стирание предыдущего
                                               изображения */
                    mempoint(x, j, c); /* запись его в новое место */
               }
     }                                                                         



     /* Копировать область в другое место */
     void copy (startx, starty, endx, endy, x, y)
     int startx, starty; /* верхняя левая координата */
     int endx, endy; /* нижняя правая координата места, куда будет
                        скопирована область */
     int x, y; /* верхняя левая координата области, откуда будет
                  перемещено изображение */
     {
          int i, j;
          unsigned char c;

          for(; startx<=endx; startx++, endx++)
               for(i=starty, j=y; i<=endy; i++, j++) {
                    c = read_point(startx, i); /* чтение точки */
                    mempoint(x, j, c); /* запись ее в новое место */
               }
     }

                                                                               

     /* Вращение точки относительно специфицированной пользователем
        начальной точки x_org и y_org на угол theta */

     void rotate_point(theta, x, y, x_org, y_org)
     double theta, *x, *y;
     int x_org, y_org;
     {
          double tx, ty;

          /* нормализация координат х и у исходной точки */
          tx = *x - x_org;
          ty = *y - y_org;

          /* вращение */
          *x = tx * cos(theta) - ty * sin(theta);
          *y = tx * sin(theta) + ty * cos(theta);

          /* возврат значений координат */
          *x += x_org;
          *y += y_org;
     }                                                                         

     /* Вращение специфицированного объекта */
     void rotate_object(ob, theta, x, y, sides)
     double ob[][4]; /* определение объекта */
     double theta; /* угол поворота в радианах */
     int x, y; /* центр вращения */
     int sides;
     {
          register int i, j;
          double tempx, tempy; /* это вспомогательные переменные,
                    используемые при преобразовании типов */
          char ch;

          for(;;){
               ch = getch(); /* просматривается, если указывается
                                направление врашения */
               switch(tolower(ch)) {
                    case 'l': /* вращение против часовой стрелки */
                         theta = theta < 0 ? -theta : theta;
                         break;
                    case 'r': /* вращение по часовой стрелке */
                         theta = theta > 0 ? -theta : theta;                   
                         break;
                    default: return;
               }

               for(j=0; j<sides; j++) {
                    /* стирание предыдущей линии */
                    line((int) ob[j][0], (int) ob[j][1],
                         (int) ob[j][2], (int) ob[j][3], 0);

                    rotate_point(theta, &ob[j][0], &ob[j][1], x, y);

                    rotate_point(theta, &ob[j][2], &ob[j][3], x, y);

                    line((int) ob[j][0], (int) ob[j][1],
                         (int) ob[j][2], (int) ob[j][3], 2);
               }
          }
     }


     /* отображение объекта */
     void display_object(ob, sides)                                            
     double ob[][4];
     int sides;
     {
          register int i;

          for(i=0; i<sides; i++)
               line((int) ob[i][0], (int) ob[i][1],
                    (int) ob[i][2], (int) ob[i][3], 2);
     }

     /* Определение объекта по его габаритным точкам с помощью
        клавиатуры или "мыши" */
     define_object(ob, x, y)
     double ob[][4];
     int x, y;
     {
          union k{
               char c[2];
               int i;
          } key;
          register int i, j;
          char far *ptr = (char far *) 0xB8000000; /* Указатель на             
                                                      CGA-память */
          char far *temp;
          unsigned char buf[14][80];
          int sides=0;
          int deltax, deltay, oldx, oldy;

          temp = ptr;
          /* сохранение верхней части текущего экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт */
                    *temp = 0; *(temp+8152) = 0; /* очистка верхней
                                                    части экрана */
                    temp++;
               }

          i = 0;
          key.i = 0;
          xhairs(x, y);
          do {
               goto_xy(0, 0);                                                  
               printf("Определите сторону %d", sides+1);
               if(i==0) printf("Укажите первую габаритную точку");
               else printf("Укажите вторую габаритную точку");

               do {
     /**************** Добавочная часть для мыши *******************/
               /* Просматривается если "мышь" перемещается */
                 mouse_motion(&deltax, &deltay);
                 /* используйте левую клавишу для определения точки*/
                 if(leftb_pressed()) {
                   xhairs(x, y); /* стирание графического курсора */
                   /* запоминание координат точки */
                   ob[sides][i++] = (double) x;
                   ob[sides][i++] = (double) y;
                   if(i==4) {
                        i = 0;
                        sides++;
                   }
                   break;
                 }
               } while(!kbhit() && !deltax && ! deltay);
               if(leftb_pressed()) wait_on(LEFTB);                             

               if(deltax || deltay) {
                 /* если "мышь" переместилась, то пересчет координат*/
                 oldx = x; oldy = y;
                 mouse_position(&y, &x);
                 y = y / 2; /* нормализация координат виртуального
                                экрана*/
                 /* стирание графического курсора */
                 xhairs(oldx, oldy);
               }
     /*********** Конец добавочной части для "мыши" *****************/

               else if(kbhit()) {
                    key.i = bioskey(0);
                    /* изображение графического курсора */
                    xhairs(x, y);
                    if(key.c[0]==13) {
                         /* используйте <ВВОД> для определения точки*/
                         ob[sides][i++] = (double) x;
                         ob[sides][i++] = (double) y;
                         if(i==4) {
                              i = 0;                                           
                              sides++;
                         }
                    }

                    /* если клавиши управления курсором, то
                       перемещение графического курсора */
                    if(!key.c[0]) switch(key.c[1]) {
                         case 75: /* влево */
                              y-=1;
                              break;
                         case 77: /* вправо */
                              y+=1;
                              break;
                         case 72: /* вверх */
                              x-=1;
                              break;
                         case 80: /* вниз */
                              x+=1;
                              break;
                         case 71: /* влево вверх */
                              x-=1; y-=1;
                              break;                                           
                         case 73: /* вправо вверх */
                              x-=1; y+=1;
                              break;
                         case 79: /* влево вниз */
                              x+=1; y-=1;
                              break;
                         case 81: /* вправо вниз */
                              x+=1; y+=1;
                              break;
                    }
               }
               if(key.c[1] != 59) xhairs(x, y);
          } while(key.c[1] != 59); /* нажмите F1 для остановки */

          temp = ptr;
          /* восстановление изображения в верхней части экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    *temp = buf[i][j];
                    *(temp+8152) = buf[i][j+1];
                    temp++;
               }                                                               
          return sides;
     }

     /*  Отображение меню */
     menu()
     {
          register int i, j;
          char far *ptr = (char far *) 0xB8000000; /* Указатель на
                                                      CGA-память */
          char far *temp;
          unsigned char buf[14][80]; /* для хранения содержимого
                                        экрана */
          int x, y, choice;
          char items[][20] = {
               "BOX",
               "CIRCLE",
               "LINE",
               "FILL BOX",
               "FILL CIRCLE"
          };

          temp = ptr;                                                          
          /* сохранение верхней части текущего экрана */
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт */
                    *temp = 0; *(temp+8152) = 0; /* очистка верхней
                                                    части экрана */
                    temp++;
               }

          goto_xy(0, 0);
          /* ожидание, которое будет прервано в результате нажатия на
             клавишу */
          while(rightb_pressed() || leftb_pressed());

          cursor_on();

          choice = mouse_menu(5, items, 0, 0);

          cursor_off();
          temp = ptr;
          /* восстановление изображения верхней части экрана */                
          for(i=0; i<14; i++)
               for(j=0; j<80; j+=2) {
                    *temp = buf[i][j];
                    *(temp+8152) = buf[i][j+1];
                    temp++;
               }
          return choice;
     }


     /**********************************************************/
     /* Функции, обеспечивающие интерфейс с "мышью"            */
     /**********************************************************/

     /*  Включение курсора "мыши"  */
     void cursor_on()
     {
          int fnum;

          fnum = 1; /* отобразить курсор */
          cmouses( &fnum,  &fnum,  &fnum,  &fnum);
     }                                                                         


     /*  Выключение курсора "мыши"  */
     void cursor_off()
     {
          int fnum;

          fnum = 2; /* стереть курсор */
          cmouses( &fnum,  &fnum,  &fnum,  &fnum);
     }



     /* Возвращает значение "истина", если нажата правая клавиша,
          и "ложь" в противном случае                           */

     rightb_pressed()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3;   /* Чтение позиции и статуса клавиши   */
          cmouses( &fnum, &arg2, &arg3, &arg4);                                
          return arg2 & 2;
     }



     /* Возвращает значение "истина", если нажата левая клавиша,
          и "ложь" в противном случае */

     leftb_pressed()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3;   /* Чтение позиции и статуса клавиши   */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          return arg2 & 1;
     }


     /* Установить координаты курсора "мыши" */
     void set_mouse_position(x, y)
     int x, y;
     {                                                                         
          int fnum, arg2;

          fnum = 4; /* установка позиции */
          cmouses(&fnum, &arg2, &x, &y);
     }

     /* Возвращает координаты курсора "мыши" */
     void mouse_position(x, y)
     int *x, *y;
     {
          int fnum, arg2, arg3, arg4;

          fnum = 3; /* получить позицию и статус клавиши */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          *x = arg3;
          *y = arg4;
     }

     /*  Возвращает направление движения  */
     void mouse_motion(deltax, deltay)
     char *deltax, *deltay;
     {                                                                         
          int fnum, arg2, arg3, arg4;

          fnum = 11; /* получить направление движения */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          if(arg3>0) *deltax = RIGHT;
          else if(arg3<0) *deltax = LEFT;
          else *deltax = NOT_MOVED;

          if(arg4>0) *deltay = DOWN;
          else if(arg4<0) *deltay = UP;
          else *deltay = NOT_MOVED;
     }

     /* Отображает однострочное меню для "мыши" и возвращает
          код выбранного пользователем элемента меню */
     mouse_menu(count, item, x, y)
     int count;           /* количество элементов меню */
     char item[][20];      /* элементы меню */
     int x, y;           /* позиции отображения */
     {
          int i, len[MENU_MAX][2], t;
          int mousex, mousey;                                                  

          goto_xy(x, y);
          t = 0;
          for(i=0; i<count; i++) {
               printf("%s   ", item[i]);
               len[i][0] = t;
               /* каждый символ имеет ширину в 16 точек растра */
               len[i][1] = t + strlen(item[i])*16;
               t = len[i][1] + 32; /* добавляется два пробела между
                                      элементами меню */
          }

          /* ожидание выбора пользователем элемента меню */
          do {
               if(rightb_pressed() || leftb_pressed()) break;
          } while(!kbhit());
          /* ожидание нажатия клавиши */
          while(rightb_pressed() || leftb_pressed());

          /* получить текущую позицию курсора "мыши" */
          mouse_position(&mousex, &mousey);
                                                                               
          /* анализируется, находится ли курсор в пределах меню */
               if(mousey>=0 && mousey<8)  /* символ имеет высоту
                                   8 точек растра */
                    for(i=0; i<count; i++) {
                         if(mousex>len[i][0] && mousex<len[i][1])
                              return i;
                    }
               return i;
          }


     /* Возвращает 1, если специфицированная клавиша не нажата */
     void wait_on(button)
     int button;
     {
          if(button== LEFTB)
               while(leftb_pressed());
          else
               while(rightb_pressed());
     }

                                                                               

     /* Установка "мыши" в исходное состояние   */
     void mouse_reset()
     {
          int fnum, arg2, arg3, arg4;

          fnum = 0;  /* Установка "мыши" в исходное состояние  */
          cmouses( &fnum, &arg2, &arg3, &arg4);
          if(fnum!=-1) {
          printf("Аппаратные или программные средства поддержки ");
          printf("'мыши' не инсталированы");
               exit(1);
          }
          if(arg2!=2) {
        printf("Разрешено использование только двухклавишной 'мыши'");
               exit(1);
          }
     }


          Программа рисования, предложенная вам в этой главе, довольно
     удобна  в обращении,  так как позволяет вам рисовать произвольные         
     рисунки (естественно используя стандартные линии),  двигаясь  при
     этом  в  любых  произвольных  направлениях  по экрану.  Например,
     рисунок  9.1  был  нарисован  на  экране  дисплея  буквально   за
     несколько  минут.  Рис.  9.2  иллюстрирует,  что  изображается на
     экране при вызове меню "мыши" (форма курсора - стрелка принята по
     умолчанию).



                НЕКОТОРЫЕ ВОЗМОЖНОСТИ РАСШИРЕНИЯ ВЫПОЛНЯЕМЫХ
                             ФУНКЦИЙ ПРОГРАММЫ
     -----------------------------------------------------------------

          Во-первых,  вам возможно понадобится  модифицировать функцию
     mouse_menu()  с  тем,  чтобы  возможно  было  обрабатывать  меню,
     занимающее более  одной строки экрана.  Фактически для реализации
     этого  наиболее  приемлемым  путем   будет   объединение  функции
     обработки меню "мыши"  с функциями обработки "всплывающего" меню,
     рассмотренными в главе 1.

          Если вы привыкли работать с иконным интерфейсом,  то  вы,  в
     принципе,  можете  модифицировать  функции  обработки меню "мыши"         
     таким  образом,  чтобы  вместо  слов  в  меню   фигурировали   на
     соответствующих  местах  пиктограммы,  обозначающие  тот или иной
     элемент  меню.  Возможно  также  модифицировать   функции   таким
     образом,  чтобы  обеспечить  полиэкраный  режим работы "мыши",  а
     также  копирование  (а  не   перемещение)   части   экрана   (или
     изображения) с одного места в другое.



                                  ГЛАВА 10
                                  --------

                       СОЗДАНИЕ КОММЕРЧЕСКИХ ДИАГРАММ
     -----------------------------------------------------------------

          В данной  главе  мы разработаем и опишем программы,  которые
     могут быть  использованы  для  создания  наиболее  удобного  вида
     представления   коммерческих   данных   -  диаграмм.  Возможность
     получить числовую информацию в визуальной форме часто оказывается
     очень  полезной.  Как  вы вскоре убедитесь,  создание диаграмм не
     представляет таких трудностей, как это первоначально кажется.
                                                                               
          Глава начинается    описанием    простого    инструментария,
     позволяющего  строить  диаграммы.  Вторая  часть  главы  содержит
     описания,  как этот  инстументарий  может  быть  использован  для
     построения  простых,  но  полезных  программ,  которые  позволяют
     выводить несколько диаграмм одновременно.

          Примеры в главе написаны  для  компьютеров  семейства  РС  с
     цветным графическим адаптером. Используется четвертый видеорежим,
     так как он поддерживает все виды цветных  адаптеров.  Однако,  вы
     можете  легко  изменить  предложенные  функции  для  того,  чтобы
     работать с другими типами адаптеров.



                            НОРМАЛИЗАЦИЯ ДАННЫХ
     -----------------------------------------------------------------

          Перед разработкой программы отображения данных на экране вам
     следует   уяснить,   как   численные   значения   переводятся   в
     соответствующие  координаты экрана.  Как вы помните,  размерность
     экрана  в   четвертом   видеорежиме   320*200,   причем   320   -
     горизонтальная  размерность и 200 - вертикальная.  Учитывая,  что         
     диаграммы изображаются вертикальными полосами, данные должны быть
     преобразованы  таким  образом,  чтобы  они  принимали  значения в
     диапазоне от 0 до 199.  Данный процесс преобразования  называется
     нормализацией.

          Чтобы нормализовать  значение,  необходимо  умножить  его на
     некоторый  коэффициент,  гарантирующий  получение  результата   в
     диапазоне   размера   экрана.   Для   определения   коэффициента,
     необходимо  знать  максимальное  и  минимальное  значения  чисел,
     выводимых   в   виде   диаграммы.   Для  определения  подходящего
     коэффициента,  необходимо   вычесть   минимальное   значение   из
     максимального  и  поделить  вертикальную  размерность  экрана  на
     полученную  разность.  Иными  словами,   для   4-го   видеорежима
     нормирующий множитель определяется по формуле:

                  нормирующий_множитель = 200 / (мах - min)

          Таким образом,   каждый   элемент  данных  нормализуется  по
     формуле:

       нормализованное_данное = необработанное_данное * норм_множитель
                                                                               


                   РАЗРАБОТКА ФУНКЦИЙ ПОСТРОЕНИЯ ДИАГРАММ
     -----------------------------------------------------------------

          Прежде,   чем  разрабатывать  функцию,  рисующую  диаграммы,
     необходимо точно определить, что она будет делать. Во-первых, она
     должна выполнять свою  главную задачу  -  выводить данные  в виде
     диаграмм.  Функция  должна  допускать  использование  в  качестве
     входного  параметра   массива   чисел   с   плавающей   точкой  и
     преобразовывать их в нормализованные целые эквиваленты. Программа
     должна  быть  реентерабельной  и  позволять   рисовать  несколько
     диаграмм одновременно.  Функция должна также  содержать аргумент,
     определяющий  расстояние   между   диаграммами,  соответствующими
     разным  последовательностям   данных,   и,  наконец,  она  должна
     позволять определять толщину линий диаграммы.

          Программа    функции    bargraph(),     приведенная    ниже,
     удовлетворяет этим требованиям.


          /* Вывод диаграммы */                                                
     void bargraph(data,num,offset,min,max,width)
     double *data;      /* массив данных */
     int num;           /* количество элементов в массиве */
     int offset;        /* расстояние между диаграммами */
     int min,max;       /* мин. и мак. выводимые значения */
     int width;         /* толщина линий */
     {
          int y,t,incr;
          double norm_data,norm_ratio,spread;
          char s[80];
          static int color = 0;
          int tempwidth;

          /* всегда используйте различные цвета */
          color++;
          if ( color > 3 ) color = 1;

          /* определение нормирующего множителя */
          spread = (double)max-min;
          norm_ratio = 180/spread;

          incr = 280/num;/* определение промежутка между значениями */         
          tempwidth = width;
          for (t=0;t<num;++t) {
               norm_data = data[t];

          /* подгонка отрицательных значений */
               norm_data = norm_data-(double)min;
               norm_data *= norm_ratio; /* нормирование */
               y = (int)norm_data; /* преобразование типа */
               do {
                    Line(179,((t*incr)+20+offset+width),179-y,
                      ((t*incr)+20+offset+width),color);
               width--;
               } while(width);
               width = tempwidth;
               }
          }

          Давайте тщательно   разберем   данную   программу.   Функция
     bargraph() получает через входные параметры: массив данных, число
     элементов  в  массиве,  расстояние  между диаграммами (для случая
     одновременного  вывода  нескольких   диаграмм),   минимальное   и
     максимальное  значения  данных  и  ширину  линий диаграмм (ширина         
     линии задается в единицах растра).  Статическая переменная  color
     определяет  новый  цвет  при  повторных  обращениях к bargraph().
     Таким  образом,  различные  последовательности  данных   при   их
     одновременном  выводе  будут  изображены  диаграммами  различного
     цвета.  При вычислении нормирующего множителя вместо максимальной
     высоты  экрана  (200  для  4-го видеорежима) использовано меньшее
     число - 180,  что в последующем позволит использовать две  строки
     экрана  для  вывода поясняющей информации.  Обычно удобнее,  если
     диаграмма  полностью  занимает  экран  независимо  от  количества
     выводимых  чисел.  Например,  диаграмма,  отражающая малые наборы
     данных,  выглядит более привлекательной,  если она занимает  весь
     экран,  а  не  совокупность сбившихся в кучу вертикальных полос в
     одном из углов  экрана.  Для  размещения  диаграммы  относительно
     ширины  экрана последняя (здесь также целесообразнее использовать
     меньшее число 280 вместо 300)  делится  на  количество  выводимых
     элементов,  полученный результат затем используют при определении
     горизонтальных координат стержней диаграммы.  В  конце  программы
     выполняется  циклическая нормализация данных и вычерчивание линий
     заданной толщины с указанным смещением.

          Функция bargraph() - ключевая функция, но это только одно из
     многих  средств,  позволяющих вам рисовать диаграммы почти любого         
     вида.  Основные из этих средств вы узнаете в процессе дальнейшего
     изложения материала.


          Вычерчивание линии нулевого уровня.
          -----------------------------------

          Диаграмма будет выглядеть более привлекательной и наглядной,
     если  вдоль  нижнего  края  вычертить  линию   нулевого   уровня.
     Программа функции grid(), представленная в данном разделе, служит
     именно для этих целей.

          /* Вывод линии нулевого уровня */
     void grid(min,max)
     int min,max;
     {
          register int t;

          goto_xy(22,0); printf("%d",min);
          goto_xy(0,0); printf("%d",max);
          line(180,10,180,300,1);
     }                                                                         

          Вы видите,  что  функция  grid()  так  же,  как и bargraph()
     оставляет внизу две строки для вывода поясняющих меток  и  другой
     справочной информации.


          Вывод меток элементов диаграмм.
          -------------------------------

          Часто пользователю  необходимо помечать значения,  выводимые
     диаграммой.  Например,  на  диаграмме,   показывающей   изменение
     прибыли  корпорации  за  пять лет,  целесообразно каждый стержень
     диаграммы пометить  соответствующим  годом.  Конечно,  вы  всегда
     можете   это  сделать  вручную,  используя  функции  goto_xy()  и
     printf();  функция label(), представленная ниже, освободит вас от
     этой рутинной работы, она автоматически выводит необходимые метки
     в нужном  месте  экрана.  Входными  параметрами  функции  label()
     являются:  массив  меток  и  их  количество.  Длина  каждой метки
     ограничена 20 символами ( включая указатель конца ),  но  это  не
     является  жестким ограничением и при небходимости вы можете легко
     изменить максимальную длину меток.
                                                                               

               /* Вывод меток на экран */
     void label(str,num)
     char str[][20]; /* массив меток */
     int num; /* количество меток */
     {
          int i,j,inc;

          inc = 38/num;
          i = 2; /* определение начальной точки */
          for (j=0;j<num;j++) {
               goto_xy(23,i);
               printf(str[j]);
               i += inc;
          }
     }





          Вычерчивание вспомогательных линий.                                  
          -----------------------------------

          В некоторых  случаях  полезно выводить горизонтальные полосы
     для сравнения высот стержней диаграммы.  Так как  сплошные  линии
     могут отвлекать пользователя, то для этой цели лучше использовать
     пунктирные линии.  Функция hashlines(),  приведенная ниже, рисует
     требуемые пунктирные линии.

               /* Вывод пунктирных линий */
     void hashlines()
     {
          int i,j;
          for (i=10;1<180;i+=10) {
               for (j=10;j<300;j+=5)
                    mempoint(i,j,3); /* одна точка на каждые 5 единиц
                                        растра */
          }
     }

          Вывод надписей.
          ---------------
                                                                               
          При одновременном выводе нескольких наборов в  виде диаграмм
     полезно   определить   цвет  диаграммы,  соответствующий  каждому
     набору.  Это можно сделать,  например,  выдав надпись, содержащую
     наименование  набора  и  используемый  для  него  цвет диаграммы.
     Функция legend(), приведенная здесь, выводит наименования наборов
     и   прямоугольник  соответствующего  цвета,  в  качестве  входных
     параметров она использует список наименований  и  их  количество.
     Функция legend() использует функцию fill_box(),  описанную ранее,
     для вывода цветного прямоугольника.

               /* Вывод надписи */
     void legend(names,num)
     char names[][20];
     int num;            /* количество наименований */
     {
          int color = 1,i,j;

          goto_xy(24,0); /* надпись производится в последней строке */
          j = 0;
          for (i=0;i<num;i++) {
               /* вывод наименования */
               printf("%s   ",names[i]);                                       
               /* определение координаты цветного прямоугольника. В 4
                  режиме каждому литерному символу отводится 8 единиц
                  растра (в ширину)  */
               j += strlen(names[i]) * 8 + 4;
               fill_box(192,j,198,j+12,color);
               j += 28; /* продвижение к следующему полю вывода */
               color ++;
               if ( color>3 ) color = 1;
          }
     }

     _________________________________________________________________

           Графический рисунок на стр 355 не может быть воиспроизведен
           имеющимися средствами. (Ред. перевода И.Бычковский.)
     _________________________________________________________________

     Рис.10-1. Результат работы программы построения диаграмм



          Простейшая программа вывода диаграмм.                                
          ------------------------------------

          Следующая программа  показывает  все  описанные  функции   в
     действии.  Результат ее работы представлен на рис.10-1. Программа
     выводит среднюю стоимость акций трех мнимых  корпораций  за  пять
     лет.

          /* Программная демонстрация построения диаграмм */
     #include "dos.h"

     void bargraph(),mode(),mempoint();
     void line(),goto_xy(),grid(),label();
     void hashlines(),legend(),read_cursor_xy();
     void palette(),color_puts(),fill_box();

     main()
     {
          double widget[] = {
               10.1,20,30,35.34,50
               };
          double global[] = {
               19,20,8.8,30,40                                                 
               };
          double tower[] = {
               25.25,19,17.4,33,29
               };
          int min,max;

          char n[][20] = {
               "widget",
               "global",
               "tower"
               };
          char lab[][20] = {
               "1983",
               "1984",
               "1985",
               "1986",
               "1987"
               };
          mode(4);       /* выбор режима 320*200 */
          palette(0);
          grid(0,50);    /* построение линии нулевого уровня */
          hashlines();   /* вывод пунктирных линий */                          
          label(lab,5);  /* вывод чисел */
          legend(n,3);   /* вывод надписей */

          /* вывод курса акций трех кампаний */
          bargraph(widget,5,0,0,50,4);
          bargraph(global,5,10,0,50,4);
          bargraph(tower,5,20,0,50,4);

          getch();
          mode(3);
     }

     /* Вывод линии нулевого уровня диаграммы */
     void grid(min,max)
     int min,max;
     {
          register int t;

          goto_xy(22,0); printf("%d",min);
          goto_xy(0,0); printf("%d",max);
          line(180,10,180,300,1);
     }                                                                         

     /* вывод меток на экран */
     void label(str,num)
     char str[][20]; /* массив меток */
     int num; /* количество меток */
     {
          int i,j,inc;

          inc = 38/num;
          i = 2; /* определение начальной точки */
          for (j=0;j<num;j++) {
               goto_xy(23,i);
               printf(str[j]);
               i += inc;
          }
     }

     /* Вывод пунктирных линий на экран */
     void hashlines()
     {
          int i,j;
                                                                               
          for (i=10;1<180;i+=10) {
               for (j=10;j<300;j+=5)
                    mempoint(i,j,3); /* одна точка на каждые 5 единиц
                                        растра */
          }
     }

     /* вывод надписи */
     void legend(names,num)
     char names[][20];
     int num; /* количество наименований */
     {
          int color = 1,i,j;

          goto_xy(24,0); /* надпись производится в последней строке */
          j = 0;
          for (i=0;i<num;i++) {
               /* вывод наименования */
               printf("%s   ",names[i]);
               /* определение координаты цветного прямоугольника. В 4
                  режиме каждому литерному символу отводится 8 единиц
                  растра ( в ширину )  */                                      
               j++ = strlen(names[i]*8+4);
               fill_box(192,j,198,j+12,color);
               j++ = 28; /* продвижение к следующему полю вывода */
               color ++;
               if ( color>3 ) color = 1;
          }
     }

     /* Вычерчивание диаграммы */

     void bargraph(data,num,offset,min,max,width)
     double *data; /* массив данных */
     int num; /* количество элементов в массиве */
     int offset; /* расстояние между диаграммами */
     int min,max; /* минимальное и максимальное выводимые значения */
     int width; /* толщина линий */
     {
          int y,t,incr;
          double norm_data,norm_ratio,spread;
          char s[80];
          static int color = 0;
          int tempwidth;                                                       

          /* всегда используйте различные цвета */
          color++;
          if ( color > 3 ) color = 1;

          /* определение нормирующего множителя */
          spread = (double)max-min;
          norm_ratio = 180/spread;

          incr = 280/num; /* определение промежутка между значениями*/
          tempwidth = width;
          for (t=0;t<num;++t) {
               norm_data = data[t];

          /* подгонка отрицательных значений */
               norm_data = norm_data-(double)min;
               norm_data *= norm_ratio; /* нормирование */
               y = (int)norm_data; /* преобразование типа */
               do {
                    line(179,((t*incr)+20+offset+width),179-y,
                      ((t*incr)+20+offset+width),color);
               width--;                                                        
               } while(width);
               width = tempwidth;
               }
          }

     /* Вывод линии заданного цвета, используя базовый алгоритм
          Брезенхама */
     void line(startx,starty,endx,endy,color)
     int startx,starty,endx,endy,color;
     {
          register int t,distance;
          int x=0,y=0,delta_x,delta_y;
          int incx,incy;

     /* вычисление расстояний по обоим направлениям */
          delta_x = endx - startx;
          delta_y = endy - starty;
     /* определение направлений увеличения координат, нулевое
        увеличение соответствует либо вертикальной, либо
        горизонтальной линии */
          if ( delta_x > 0 ) incx = 1 ;
          else  if (delta_x == 0 ) incx = 0;                                   
          else incx = -1;
          if ( delta_y > 0 ) incy = 1 ;
          else  if (delta_y == 0 ) incy = 0;
          else incy = -1;
     /* определение максимума изменения координат */
          delta_x = abs(delta_x);
          delta_y = abs(delta_y);
          if ( delta_x > delta_y ) distance = delta_x;
          else distance = delta_y;
     /* вычерчивание линии */
          for (t=0;t<=distance+1;t++) {
               mempoint(startx,starty,color);
               x+= delta_x;
               y+= delta_y;
               if (x>distance) {
               x-=distance;
               startx+=incx;
               }
               if (y>distance) {
               y-=distance;
               starty+=incy;
               }                                                               
          }
     }
     /* наполнение прямоугольника заданным цветом */
     void fill_box(startx,starty,endx,endy,color_code)
     int startx, starty, endx, endy, color_code;
     {
          register int i,begin,end;

          begin = startx < endx ? startx : endx;
          end = startx > endx ? startx : endx;

          for (i=begin;i<=end;i++)
               line(i,starty,i,endy,color_code);
     }
     /* запись точки в CGA/EGA память */
     void mempoint(x,y,color_code)
     int x,y,color_code;
     {
          union mask {
               char c[2];
               int i;
          } bit_mask;                                                          
          int i,index,bit_position;
          unsigned char t;
          char xor; /* xor - цвет или наложение */
          char far *ptr = (char far *) 0xB8000000; /* указатель на
                                                       CGA  */
          bit_mask.i = 0xFF3F; /* 11111111 00111111 в двоичном коде */
          /* контроль координат для 4 режима */
          if (x<0 || x>199 || y<0 || y>319) return;

          xor = color_code & 128; /* проверка установки режима xor */
          color_code = color_code & 127; /* маска 7 старших бит */

     /* установка bit_mask и color_code в правильное положение */
          bit_position = y%4;
          color_code <<= 2*(3-bit_position);
          bit_mask.i >>= 2*bit_position;

     /* поиск соответствующего байта в памяти экрана */
          index = x*40 + (y>>2);
          if (x%2) index+=8152; /* если нечетный, использовать второй
                                   байт */
     /* запись цвета */                                                        
          if (!xor) { /* режим наложения */
               t = *(ptr + index) & bit_mask.c[0];
               *(ptr + index) = t | color_code;
          }
          else { /* режим xor */
                t = *(ptr + index) | (char)0;
               *(ptr + index) = t | color_code;
          }
     }

     /* установка видеорежима */
     void mode(mode_code)
     int mode_code;
     {
          union REGS r;

          r.h.al = mode_code;
          r.h.ah = 0;
          int86(0x10,&r,&r);
     }

     /* установка курсора в координаты x,y */                                  
     void goto_xy(x,y)
     int x,y;
     {
          union REGS r;

          r.h.ah = 2; /* функция адресации курсора */
          r.h.dl = y; /* горизонтальная координата */
          r.h.dh = x; /* вертикальная координата */
          r.h.bh = 0; /* видеостраница */
          int86(0x10,&r,&r);
     }

     /* установка цветов диаграмм */
     void palette(pnum)
     int pnum;
     {
          union REGS r;

          r.h.bh = 1; /* код 4 режима */
          r.h.bl = pnum;
          r.h.ah = 11; /* установка функции цвета */
          int86(0x10,&r,&r);                                                   
     }



                      ПРОГРАММА ВЫЧЕРЧИВАНИЯ ДИАГРАММ
     -----------------------------------------------------------------

          Вы можете  использовать  описанные  функции  для  построения
     программы создания  диаграмм.  Программа  позволяет  пользователю
     вводить количество наборов данных,  количество элементов в каждом
     наборе,  наименования и метки  соответствующих  данных,  а  также
     толщину   линий  и  расстояния  между  диаграммами.  После  ввода
     указанных данных программа автоматически  вычерчивает  диаграмму.
     Вы   также   можете  написать  программу  сохранения  построенной
     диаграммы в файле для ее дальнейшего использования.


          Главная программа.
          ------------------

          Здесь приводится  основная   функция   main(),   описывающая
     алгоритм построения диаграмм и содержащая несколько макросов.             


     #define MAX_SETS 3
     #define MAX_ENTRIES 50
     #define MAX_LABELS 20
     #define MAX_NAMES 20

     main()
     {
          double v[MAX_SETS][MAX_ENTRIES]; /* размещение данных */
          int num_entries;
          int num_sets;
          int min,max,i;
          int lines,offset;
          char save = 0; /* признак сохранения диаграммы */
          char names[MAX_NAMES][20];
          char lab[MAX_LABELS][20];

     /* считывание данных */
          enter(v,&num_entries,&num_sets);

     /* поиск минимального и максимального значения */                         
          min_max(v,num_entries,num_sets,&min,&max);

     /* ввод наименований данных */
          get_names(names,num_sets);

     /* ввод меток для диаграммы */
          get_labels(lab,num_entries);

     /* ввод толщины линии */
          lines = get_line_size();

     /* ввод интервала между диаграммами */
          offset = get_offset();

     /* сохранить диаграмму в файле ? */
          printf(" сохранить диаграмму в файле ? (y/n) ");
          if (tolower(getche()) == 'y') save = 1;

          mode(4); /* графический режим 320*200 */
          palette(0);

          grid(min,max); /* вывод линии нулевого уровня */                     
          hashlines(); /* вывод пунктирных линий */
          label(lab,num_entries); /* вывод меток диаграммы */
          legend(names,num_sets); /* вывод пояснительных надписей */

          /* вывод значений в виде диаграммы */
          for (i=0;i<num_sets;i++)
               bargraph(v[i],num_entries,i*offset,min,max,lines);

          if (save) save_pic();
          getch();
          mode(3);
     }

          Как вы   видите,   функция   main()   начинается   описанием
     переменных, значения которых устанавливает пользователь. Массив v
     определен  достаточно  большим,  чтобы  содержать до трех наборов
     данных  до   50   элементов   каждый.   (Эти   размеры   являются
     произвольными и при желании вы можете их изменить.) Затем функция
     считывает  выводимые  пользователем  в  виде  диаграмм  данные  и
     определяет  минимальное  и  максимальное  значение данных.  После
     этого на экран выводятся линия нулевого уровня,  пунктирные линии
     уровня,  метки  диаграммы  и  наименование наборов.  В завершение         
     вычерчивается сама диаграмма. Перед выходом происходит сохранение
     диаграммы  при  помощи  функции  save_pic().  Давайте  рассмотрим
     некоторые используемые в программе  main()  функции,  которые  не
     входят в описанные выше инструментарии построения диаграмм.


          Функция enter().
          ----------------

          Приведенная здесь  функция  enter()  использует  в  качестве
     своих параметров адрес массива, в котором будут размещены данные,
     и  адреса  переменных для размещения числа количества элементов в
     наборе и числа самих наборов.  Функция  начинает  свою  работу  с
     запроса   у   пользователя  количества  наборов  данных  и  затем
     количества элементов данных в каждом наборе. После получения этой
     информации производится считывание данных для каждого набора.

          /* Считывание данных */
     enter(v,entries,sets)
     double v[][MAX_ENTRIES]; /*  массив данных */
     int *entries; /* количество элементов в каждом наборе данных */
                                                                               
     int *sets; /* количество наборов данных */
     {
          int i,j,count,num;
          char s[80];

     printf("Введите число наборов данных (от 1 до %d)",MAX_SETS);
          scanf("%d%c",&count,&j);
          if (count>MAX_SETS) count = MAX_SETS; /* выход за границы
                                                   массива */
          *sets = count;
     printf("Введите количество элементов (от 1 до %d) ",MAX_ENTRIES);
          scanf("%d%c",&num,&j);
          if (num>MAX_SETS) num = MAX_ENTRIES; /* выход за границы
                                                  массива */
          *entries = num;

          j = 0;

          /* считывание значений данных */
          while((j<count)) {
               printf("Набор данных %d\n",j+1);
               for (i=0;i<num;i++) {                                           
                    printf("%d:",i+1);
                    gets(s);
                    sscanf(s,"%lf",&v[j][i]);
               }
               j++;
          }
          return count;
     }


          Функция min_max().
          ------------------

          Так как   функция   bargraph()   использует  максимальное  и
     минимальное  значения  выводимых  данных,  то   нам   потребуется
     специальная  функция  для  определения этих значений.  Необходимо
     также отметить,  что эта  функция  должна  не  просто  определять
     минимальное  и  максимальное  значения набора данных,  а находить
     наименьшее минимальное и  наибольшее  максимальное  значения  для
     нескольких   наборов   данных,  что  обеспечит  соответствие  при
     одновременном  построении  сразу  нескольких  диаграмм.   Функция
     min_max(),   приведенная   здесь,   вместе  с  двумя  внутренними         
     функциями удовлетворяет этому требованию.

          /* Поиск наименьшего минимума и наибольшего максимума
             среди всех наборов данных */
     void min_max(v,entries,sets,min,max)
     double v[][MAX_ENTRIES]; /*  значения */
     int entries; /* количество входов для каждого набора
                      данных */

     int sets; /* количество наборов данных */
     int *min,*max; /* возвращает минимальное и максимальное
                       значение */
     {
          int i,j;
          int tmin,tmax;

          *min = *max = 0;

          for (i=0;i<sets;i++) {
               tmax = getmax(v[i],entries);
               tmin = getmin(v[i],entries);
               if (tmax>*max) *max = tmax;                                     
               if (tmin <*min) *min = tmin;
          }
     }
      /* Возврат максимального значения данных */
     getmax(data,num)
     double *data;
     int num;
     {
          int t,max;

          max = (int)data[0];
          for (t=1;t<num;++t)
               if (data[t]>max) max = (int)data[t];
          return max;
     }

     /* Возврат минимального значения данных */
     getmin(data,num)
     double *data;
     int num;
     {
          int t,min;                                                           

          min = (int)data[0];
          for (t=1;t<num;++t)
               if (data[t]<min) min = (int)data[t];
          return min;
     }


          Полный текст программы вычерчивания диаграмм.
          ---------------------------------------------

          Полный  текст  программы  вычерчивания  диаграмм представлен
     ниже.


          /* Программа генерации диаграмм */

     #include "dos.h"
     #include "stdio.h"

     #define MAX_SETS 3
     #define MAX_ENTRIES 50                                                    
     #define MAX_LABELS 20
     #define MAX_NAMES 20

     void bargraph(),mode(),mempoint();
     void line(),goto_xy(),grid(),label();
     void hashlines(),legend(),read_cursor_xy();
     void palette(),color_puts(),fill_box();
     void get_labels(),get_names(),min_max();
     void save_pic();

     main()
     {
          double v[MAX_SETS][MAX_ENTRIES]; /* размещение данных */
          int num_entries;
          int num_sets;
          int min,max,i;
          int lines,offset;
          char save = 0; /* признак записи диаграммы */
          char names[MAX_NAMES][20];
          char lab[MAX_LABELS][20];
     /* считывание данных */
          enter(v,&num_entries,&num_sets);                                     

     /* поиск минимального и максимального значения */
          min_max(v,num_entries,num_sets,&min,&max);

     /* ввод наименований данных */
          get_names(names,num_sets);

     /* ввод меток для диаграммы */
          get_labels(lab,num_entries);

     /* ввод толщины линии */
          lines = get_line_size();

     /* ввод интервала между диаграммами */
          offset = get_offset();

     /* сохранить диаграмму в файле ? */
          printf(" сохранить диаграмму в файле ? (y/n) ");
          if (tolower(getche()) == 'y') save = 1;

          mode(4); /* графический режим 320*200 */
          palette(0);                                                          

          grid(min,max); /* вывод линии нулевого уровня */
          hashlines(); /* вывод пунктирных линий */
          label(lab,num_entries); /* вывод меток диаграммы */
          legend(names,num_sets); /* вывод пояснительных надписей */

          /* вывод значений в виде диаграммы */
          for (i=0;i<num_sets;i++)
               bargraph(v[i],num_entries,i*offset,min,max,lines);

          if (save) save_pic();
          getch();
          mode(3);
     }
          /* считывание данных */
     enter(v,entries,sets)
     double v[][MAX_ENTRIES]; /*  массив данных */
     int *entries;      /* количество элементов данных в каждом наборе
                           данных */

     int *sets; /* количество наборов данных */
     {                                                                         
          int i,j,count,num;
          char s[80];

     printf("Введите число наборов данных (от 1 до %d)",MAX_SETS);
          scanf("%d%c",&count,&j);
          if (count>MAX_SETS) count = MAX_SETS; /* выход за границы
                                                   массива */
          *sets = count;
     printf("Ведите число элементов данных (от 1 до %d)",MAX_ENTRIES);
          scanf("%d%c",&num,&j);
          if (num>MAX_ENTRIES) num = MAX_ENTRIES; /* выход за границы
                                                  массива */
          *entries = num;

          j = 0;

          /* считывание значений */
     while((j<count)) {
          printf(" Набор данных %d\n",j+1);
          for (i = 0;i<num;i++) {
          printf("%d:",i+1);
          gets(s);                                                             
          sscanf(s,"%lf",&v[j][i]);
          }
          j++;
        }
        return count;
     }

     /* Ввод имен наборов */
     void get_names(n,num)
     char n[][20];         /* массив для имен */
     int num;              /* число наборов */
     {
          int i;

          for (i=0;i<num;i++) {
               printf(" Введите имя: ");
               gets(n[i]);
          }
     }

     /* Ввод метки каждого входа */
     void get_labels(l,num)                                                    
     char l[][20]; /* массив для меток */
     int num; /* число входов */
     {
          int i;

          for (i=0;i<num;i++) {
               printf(" Введите имя метки: ");
               gets(l[i]);
          }
     }

     /* Ввод интервала между диаграммами в единицах растра */
     get_offset()
     {
          int i;

     printf(" Введите интервал между диаграммами в единицах растра");
          scanf("%d%*c",&i);
          return i;
     }

     /* Ввод толщины диаграмм в единицах растра */                             
     get_line_size()
     {
          int i;

     printf("Введите толщину диаграммы в единицах растра : ");
          scanf("%d",&i);
          return i;
     }
     /* Вывод линии нулевого уровня диаграммы */
     void grid(min,max)
     int min,max;
     {
          register int t;

          goto_xy(22,0); printf("%d",min);
          goto_xy(0,0); printf("%d",max);
          line(180,10,180,300,1);
     }

     /* Вывод меток на экран */
     void label(str,num)
     char str[][20]; /* массив меток */                                        
     int num; /* количество меток */
     {
          int i,j,inc;

          inc = 38/num;
          i = 2; /* определение начальной точки */
          for (j=0;j<num;j++) {
               goto_xy(23,i);
               printf(str[j]);
               i += inc;
          }
     }

     /* Вывод пунктирных линий на экран */
     void hashlines()
     {
          int i,j;

          for (i=10;1<180;i+=10) {
               for (j=10;j<300;j+=5)
                    mempoint(i,j,3); /* одна точка на каждые 5 единиц
                                        растра */                              
          }
     }

     /* Вывод надписи */
     void legend(names,num)
     char names[][20];
     int num; /* количество наименований */
     {
          int color = 1,i,j;

          goto_xy(24,0); /* надпись производится в последней строке */
          j = 0;
          for (i=0;i<num;i++) {
               /* Вывод наименования */
               printf("%s   ",names[i]);
               /* определение координаты цветного прямоугольника. В 4
                  режиме каждому литерному символу отводится 8 единиц
                  растра ( в ширину )  */
               j += strlen(names[i]) * 8 + 4;
               fill_box(192,j,198,j+12,color);
               j += 28; /* продвижение к следующему полю вывода */
               color ++;                                                       
               if ( color>3 ) color = 1;
          }
     }

     void bargraph(data,num,offset,min,max,width)
     double *data;          /* массив данных */
     int num;               /* количество элементов в массиве */
     int offset;            /* расстояние между диаграммами */
     int min,max;  /* минимальное и максимальное выводимые значения */
     int width;             /* толщина линий */
     {
          int y,t,incr;
          double norm_data,norm_ratio,spread;
          char s[80];
          static int color = 0;
          int tempwidth;

          /* всегда используйте различные цвета */
          color++;
          if ( color > 3 ) color = 1;

          /* определение нормирующего множителя */                             
          spread = (double)max-min;
          norm_ratio = 180/spread;

          incr = 280/num; /* определение промежутка между значениями*/
          tempwidth = width;
          for (t=0;t<num;++t) {
               norm_data = data[t];

          /* подгонка отрицательных значений */
               norm_data = norm_data-(double)min;
               norm_data *= norm_ratio; /* нормирование */
               y = (int)norm_data; /* преобразование типа */
               do {
                    Line(179,((t*incr)+20+offset+width),179-y,
                      ((t*incr)+20+offset+width),color);
               width--;
               } while(width);
               width = tempwidth;
               }
          }

          /* поиск наименьшего минимума и наибольшего максимума                
             среди всех наборов данных */
     void min_max(v,entries,sets,min,max)
     double v[][MAX_ENTRIES]; /*  значения */
     int entries; /* количество входов для каждого набора
                      данных */

     int sets; /* количество наборов данных */
     int *min,*max; /* возвращает минимальное и максимальное
                       значение */
     {
          int i,j;
          int tmin,tmax;

          *min = *max = 0;

          for (i=0;i<sets;i++) {
               tmax = getmax(v[i],entries);
               tmin = getmin(v[i],entries);
               if (tmax>*max) *max = tmax;
               if (tmin <*min) *min = tmin;
          }
     }                                                                         
      /* Возврат максимального значения данных */
     getmax(data,num)
     double *data;
     int num;
     {
          int t,max;

          max = (int)data[0];
          for (t=1;t<num;++t)
               if (data[t]>max) max = (int)data[t];
          return max;
     }

     /* Возврат минимального значения данных */
     getmin(data,num)
     double *data;
     int num;
     {
          int t,min;

          min = (int)data[0];
          for (t=1;t<num;++t)                                                  
               if (data[t]<min) min = (int)data[t];
          return min;
     }

     /* Вывод линии заданного цвета, используя базовый алгоритм
          Брезенхама */
     void line(startx,starty,endx,endy,color)
     int startx,starty,endx,endy,color;
     {
          register int t,distance;
          int x=0,y=0,delta_x,delta_y;
          int incx,incy;

     /* вычисление расстояний по обоим направлениям */
          delta_x = endx - startx;
          delta_y = endy - starty;
     /* определение направлений увеличения координат, нулевое
        увеличение соответствует либо вертикальной, либо
        горизонтальной линии */
          if ( delta_x > 0 ) incx = 1 ;
          else  if (delta_x == 0 ) incx = 0;
          else incx = -1;                                                      
          if ( delta_y > 0 ) incy = 1 ;
          else  if (delta_y == 0 ) incy = 0;
          else incy = -1;
     /* определение максимума изменения координат */
          delta_x = abs(delta_x);
          delta_y = abs(delta_y);
          if ( delta_x > delta_y ) distance = delta_x;
          else distance = delta_y;
     /* вычерчивание линии */
          for (t=0;t<=distance+1;t++) {
               mempoint(startx,starty,color);
               x+= delta_x;
               y+= delta_y;
               if (x>distance) {
               x-=distance;
               startx+=incx;
               }
               if (y>distance) {
               y-=distance;
               starty+=incy;
               }
          }                                                                    
     }
     /* наполнение прямоугольника заданным цветом */
     void fill_box(startx,starty,endx,endy,color_code)
     int startx,starty,endx,endy,color_code;
     {
          register int i,begin,end;

          begin = startx < endx ? startx : endx;
          end = startx > endx ? startx : endx;

          for (i=begin;i<=end;i++)
               line(i,starty,i,endy,color_code);
     }
     /* запись точки в CGA/EGA память */
     void mempoint(x,y,color_code)
     int x,y,color_code;
     {
          union mask {
               char c[2];
               int i;
          } bit_mask;
          int i,index,bit_position;                                            
          unsigned char t;
          char xor; /* xor - цвет или наложение */
          char far *ptr = (char far *) 0xB8000000; /* указатель на
                                                      CGA  */
          bit_mask.i = 0xFF3F; /* 11111111 00111111 в двоичном коде */
          /* контроль координат для 4 режима */
          if (x<0 || x>199 || y<0 || y>319) return;

          xor = color_code & 128; /* проверка установки режима xor */
          color_code = color_code & 127; /* маска 7 старших бит */

     /* установка bit_mask и color_code в правильное положение */
          bit_position = y%4;
          color_code <<= 2*(3-bit_position);
          bit_mask.i >>= 2*bit_position;

     /* поиск соответствующего байта в памяти экрана */
          index = x*40 + (y>>2);
          if (x%2) index+=8152; /* если нечетный, использовать второй
                                   банк */
     /* запись цвета */
          if (!xor) { /* режим наложения */                                    
               t = *(ptr + index) & bit_mask.c[0];
               *(ptr + index) = t | color_code;
          }
          else { /* режим xor */
                t = *(ptr + index) | (char)0;
               *(ptr + index) = t ^ color_code;
          }
     }

     /* установка видеорежима */
     void mode(mode_code)
     int mode_code;
     {
          union REGS r;

          r.h.al = mode_code;
          r.h.ah = 0;
          int86(0x10,&r,&r);
     }

     /* установка курсора в координаты x,y */
     void goto_xy(x,y)                                                         
     int x,y;
     {
          union REGS r;

          r.h.ah = 2; /* функция адресации курсора */
          r.h.dl = y; /* горизонтальная координата */
          r.h.dh = x; /* вертикальная координата */
          r.h.bh = 0; /* видеостраница */
          int86(0x10,&r,&r);
     }

     /* установка цветов диаграмм */
     void palette(pnum)
     int pnum;
     {
          union REGS r;

          r.h.bh = 1; /* код 4 режима */
          r.h.bl = pnum;
          r.h.ah = 11; /* установка функции цвета */
          int86(0x10,&r,&r);
     }                                                                         

     /* сохранение выведенного видеографика */
     void save_pic()
     {
          char fname[80];
          FILE *fp;
          register int i,j;
          char far *ptr = (char far *) 0xB8000000; /* указатель
               на CGA память */
          char far *temp;
          unsigned char buf[14][80]; /* для размещения содержимого
                                        экрана */

          temp = ptr;
          /* сохранение верхней части текущего экрана */
          for (i=0;i<14;i++)
               for (j=0;j<80;j+=2) {
                    buf[i][j] = *temp; /* четный байт */
                    buf[i][j+1] = *(temp+8152); /* нечетный байт*/
                    *temp = 0;
                    *(temp+8152) = 0; /* чистка верхней части
                                         экрана */                             
                    temp++;
               }
          goto_xy(0,0);
          printf(" Имя файла : ");
          gets(fname);
          if (!(fp=fopen(fname,"wb"))) {
               printf(" Невозможно открыть файл \n");
               return;
          }
          temp = ptr;
          /* восстановление верхней части экрана */
          for (i=0;i<14;i++)
               for (j=0;j<80;j+=2) {
                    *temp = buf[i][j];
                    *(temp+8152) = buf[i][j+1];
                    temp++;
               }
          /* сохранение рисунка в файле */
          for (i=0;i<8152;i++) {
               putc(*ptr,fp); /* четный байт */
               putc(*(ptr+8152),fp); /* нечетный байт */
               ptr++;                                                          
          }
          fclose(fp);
     }



                   ОТОБРАЖЕНИЕ ДИАГРАММ НА ЭКРАНЕ ДИСПЛЕЯ
     -----------------------------------------------------------------

          Если вы  сохранили построенную диаграмму в файле,  то всегда
     можете повторно получить изображение данной диаграммы.  Для  этой
     цели служит программа SHOW, описанная в данном разделе. Программа
     выводит диаграмму, находящуюся в файле, имя файла задается в виде
     аргумента команды. Например, чтобы вывести диаграмму, находящуюся
     в файле backlog, необходимо ввести команду

                        show backlog

          Программа show      использует      функцию      load_pic(),
     предназначенную  для  изображения  диаграмм на экране.  (Вы также
     можете использовать  эту  программу  для  отображения  на  экране
     дисплея  других  графических образов,  предварительно созданных и
     записанных в файл.)

     /* Простейшая программа восстановления графических образов */

     #include "stdio.h"
     #include "dos.h"

     void load_pic(),mode(),palette(),goto_xy();

     main(argc,argv)
     int argc;
     char *argv[];
     {
          if (argc != 2) {
               printf(" Обращение: показать <имя файла>");
               exit(1);
          }
          mode(4);
          palette(0);
          load_pic(argv[1]);
          getch();
          mode(3);
     }

     /* загрузка графического изображения */
     void load_pic(fname)
     char *fname;
     {
          FILE *fp;
          register int i,j;
          char far *ptr = (char far *) 0xB8000000; /* указатель
               на CGA память */
          char far *temp;
          unsigned char buf[14][80]; /* для размещения содержимого
                                        экрана */
          if (!(fp=fopen(fname,"rb"))) {
               goto_xy(0,0);
               printf(" невозможно открыть файл \n");
               return;
          }
          /* загрузка изображения из файла */
          for (i=0;i<8152;i++) {
               *ptr = getc(fp); /* четный байт */
               *(ptr+8152) = getc(fp); /* нечетный байт */
               ptr++;
          }
          fclose(fp);
     }

     /* установка видеорежима */
     void mode(mode_code)
     int mode_code;
     {
          union REGS r;

          r.h.al = mode_code;
          r.h.ah = 0;
          int86(0x10,&r,&r);
     }

     /* установка цветов диаграмм */
     void palette(pnum)
     int pnum;
     {
          union REGS r;

          r.h.bh = 1; /* код 4 режима */
          r.h.bl = pnum;
          r.h.ah = 11; /* установка функции цвета */
          int86(0x10,&r,&r);
     }

      /* установка курсора в координаты x,y */
     void goto_xy(x,y)
     int x,y;
     {
          union REGS r;

          r.h.ah = 2; /* функция адресации курсора */
          r.h.dl = y; /* горизонтальная координата */
          r.h.dh = x; /* вертикальная координата */
          r.h.bh = 0; /* видеостраница */
          int86(0x10,&r,&r);
     }




               НЕКОТОРЫЕ ИНТЕРЕСНЫЕ ИДЕИ ПО МОДИФИКАЦИИ ПРОГРАММ
     -----------------------------------------------------------------

          Вы можете  расширить  описанные  функции,  введя  параметры,
     задающие  размеры  и  расположение  диаграмм так,  чтобы выводить
     диаграммы разных размеров в различных  частях  экрана.  Например,
     может быть удобен вывод четырех малых диаграмм, каждая из которых
     расположена  в  одном  из  квадрантов  экрана.  Вы  также  можете
     изменить  предложенные функции и работать с графическими режимами
     более высокой разрешающей способности.
