<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0043)http://rtfm.vn.ua/prog/tech/sort/sort_6.htm -->
<HTML><HEAD><TITLE>Метод Шелла</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META content="MSHTML 5.00.2614.3401" name=GENERATOR></HEAD>
<BODY bgColor=#000000 link=#ffffff text=#00ffff>
<P align=right><A href="http://www.linkexchange.ru/users/010865/goto.map" 
target=_blank><IMG alt="Russian LinkExchange Advertising Network" border=0 
height=60 isMap src="" vspace=4 width=468></A></P>
<H2 align=left>&nbsp;&nbsp;&nbsp;&nbsp; <FONT color=#ffff80>Метод 
Шелла</FONT></H2>
<P align=left>&nbsp;&nbsp;&nbsp; Общий метод, который использует сортировку 
вставкой, применяет принцип уменьшения расстояния между сравниваемыми 
элементами. На рис.2 показана схема выполнения сортировки Шелла для мас сива 
"оасве".&nbsp;&nbsp;&nbsp;&nbsp; Сначала сортируются все элементы, которые 
смещены&nbsp; друг от друга на три позиции. Затем сортируются все элементы, 
которые смещены на две позиции. И, наконец, упорядочиваются все соседние 
элементы.<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проход 1 f d a c b 
e<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проход 2 c b a f d 
e<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проход 3 a b c e d 
f<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; полученный результат a b c d 
e f<BR><BR>&nbsp;&nbsp;&nbsp; Рис.2. Сортировка 
Шелла:<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { сортировка Шелла 
}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure Shell(var item: 
DataArray; count:integer);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
const<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = 
5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
var<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k, s, m: 
integer;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h: array[1..t] of 
integer;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x: 
DataItem;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h[1]:=9; h[2]:=5; h[3]:=3; 
h[4]:=2; h[5]:=1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for m := 1 to t 
do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
begin<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
k:=h[m];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
s:=-k;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i := k+1 to count 
do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x := 
item[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j := 
i-k;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s=0 
then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s := 
-k;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s := 
s+1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item[s] := 
x;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
end;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (x&lt;item[j]) and 
(j&lt;count) do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
item[j+k] := 
item[j];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j 
:= j-k;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
end;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item[j+k] := 
x;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
end;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;<BR>&nbsp;&nbsp;&nbsp; 
end; { конец сортировки Шелла }<BR><BR>&nbsp;&nbsp;&nbsp; При поверхностном 
взгляде на алгоритм нельзя сказать, что он&nbsp; дает хороший результат и даже 
то, что в результате получится отсортированный массив.&nbsp;&nbsp;&nbsp; Однако, 
он дает и то и другое. Эффективность этого алгоритма объясняется тем, что при 
каждом проходе используется относительно небольшое число элементов или 
элементы&nbsp; массива уже находятся в относительном порядке, а 
упорядоченность&nbsp;&nbsp; увеличивается при каждом новом просмотре 
данных.<BR>&nbsp;&nbsp;&nbsp; Расстояния между&nbsp;&nbsp;&nbsp;&nbsp; 
сравниваемыми элементами могут изменяться&nbsp; по-разному. Обязательным 
является лишь то, что последний шаг должен равняться единице. Например, хорошие 
результаты дает последовательность шагов 9, 5, 3, 2, 1, которая использована в 
показанном выше примере. Следует избегать последовательностей степени&nbsp; 
двойки, которые, как показывают сложные математические выкладки,<BR>снижают 
эффективность алгоритма сортировки. /Однако, при исполь зовании таких 
последовательностей шагов между сравниваемыми элементами эта сортировка будет 
по-прежнему работать правильно/.<BR>&nbsp;&nbsp;&nbsp; Внутренний цикл имеет два 
условия проверки. Условие&nbsp; "х&lt;item[j]" необходимо для упорядочения 
элементов. Условия "j&gt;0" и "j&lt;= count" необходимы для того, чтобы 
предотвратить выход&nbsp;&nbsp;&nbsp; за&nbsp; пределы массива "item". Эта 
дополнительная проверка в некоторой&nbsp; степени ухудшает сортировку Шелла. 
Слегка измененные версии сор тировки Шелла используют специальные управляющие 
элементы, которые не являются в действительности частью той информации, 
которая&nbsp; должна сортироваться. Управляющие элементы имеют граничные 
для&nbsp;&nbsp; массива данных значения, т.е. наименьшее и наибольшее значения. 
В&nbsp; этом случае не обязательно выполнять проверку на граничные значения. 
Однако, применение таких управляющих элементов требует специальных знаний о той 
информации, которая сортируется, и это сни жает универсальность процедуры 
сортировки.<BR>&nbsp;&nbsp;&nbsp; Анализ сортировки 
Шелла&nbsp;&nbsp;&nbsp;&nbsp; требует решения некоторых сложных&nbsp;&nbsp; 
математических задач,&nbsp;&nbsp;&nbsp; которые выходят за рамки этой книги. 
Время&nbsp; выполнения сортировки&nbsp;&nbsp;&nbsp; Шелла пропорционально 
n**1.2. Эта зависимость значительно лучше квадратичной зависимости, которой 
подчиняются рассмотренные ранее алгоритмы сортировки. Однако, прежде&nbsp;&nbsp; 
чем вы решите использовать сортировку Шелла, следует иметь в виду, что быстрая 
сортировка дает даже еще лучшие результаты.<BR></P>
<P align=left>Метод Шелла<BR><BR>В рассмотренных алгоритмах сортировки запись 
перемещается каждый раз только на одну позицию. При этом среднее время работы 
будет в лучшем случае пропорционально n . Методом, существенно превосходящим 
простые вставки, при котором записи перемещаются большими скачками, является 
метод Шелла (сорти-<BR>ровка с убывающим шагом). Метод состоит в том, что 
упорядочиваемая таблица разделяется на группы элементов, каждая из которых 
упорядочивается методом вставки. В процессе упорядочения размеры 
таких<BR>групп&nbsp;&nbsp;&nbsp; увеличиваются до тех пор, пока все элементы 
таблицы не войдут в упорядоченную группу. Выбор очередной упорядочиваемой группы 
и ее расположение внутри таблицы производятся так, чтобы можно было использовать 
предшествующую упорядоченность. Группой таблицы называют последовательность 
элементов, номера которых образуют арифметическую прогрессию с разностью h (h 
называют шагом группы). В начале процесса упорядочения выбирается первый шаг 
группы h1, который зависит от размера таблицы. Шелл предложил брать</P>
<P align=left>&nbsp;&nbsp;&nbsp; h1=[n/2], а hi=h((i-1)/2).</P>
<P align=left>В более поздних работах Хиббард показал, что для ускорения 
процесса целесообразно определить шаг h1 по формуле:<BR><BR>h1=2**k+1 , где 2**k 
&lt; n &lt;= 2**(k+1).<BR><BR>После выбора h1 методом вставки упорядочиваются 
группы, содержащие элементы с номерами позиций<BR>&nbsp;&nbsp;&nbsp; i, i+h1, 
i+2*h1, ..., i+mi*h1.<BR>При этом i=1,2,...,h1; m[i] - наибольшее целое, 
удовлетворяющее неравенству i+m[i]*hi &lt;= n.<BR>Затем выбирается шаг h2&lt;h1 
и упорядочиваются группы, содержащие элементы с номерами позиций i, i+h2, ..., 
i+m[i]*h2. Эта процедура со все уменьшающимися шагами продолжается до тех пор, 
пока очередной шаг h[l] станет равным единице (h1&gt;h2&gt;...&gt;hl). Этот 
последний этап представляет собой упорядочение всей таблицы методом вставки. Но 
так как исходная таблица упорядочивалась отдельными группами с последовательным 
объединением этих групп, то общее количество сравнений значительно 
меньше,&nbsp;&nbsp;&nbsp;&nbsp; чем n /4, требуемое при методе вставки. Число 
операций сравнения пропорционально n*(log2(n))**2 .<BR></P></BODY></HTML>
