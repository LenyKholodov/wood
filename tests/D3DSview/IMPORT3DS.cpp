
// D3DSView

// Written by William Chin
// Developed in MSDEV C++ v6.0 using the DirectX 7.0 SDK
// Date : 16th May 2000
// File : Import3DS.cpp

// Website: http://members.aol.com/billybop7
// Email:  billybop7@aol.com 

#include "windows.h"
#include <stdio.h>
#include "math.h"
#include "D3DApp.h"
#include "Import3DS.hpp"
#include "Debug.hpp"
#include "d3dtextr.h"

#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

OBJECT3DS oblist[MAX_NUM_3DS_OBJECTS]; //used for temp storage of 3ds model data

D3DVERTEX src_v[100000]; // Structures required by DrawPrimitive to store vert and texture
						// co-ordinate data


BOOL command_found_flag;
BOOL bEnable3dsLogfile = TRUE;
BOOL bEnableDatLogfile = FALSE;

float g_scale;

char **material_list;
char **mapnames;
FILE *logfile;


// for debuging the Render3DS function
bool Rendering3DSModelForFirstTime = true;
bool Loading3DSModelForFirstTime = true;


C3DS* pC3DS;  // global pointer to C3DS class

// class constructor
C3DS::C3DS()
{
	pC3DS = this;
}


BOOL C3DS::Load3dsModel(k3DSMODEL *model, char *filename)
{
	FILE *fp; 
	int done;
	int i;
	int length;
	int	data_length;
	int quad_cnt=0;
	unsigned short	command;
	char temp;
	BOOL process_data_flag;
	int file_ex_start = 0;


	total_num_objects = -1;
	total_num_faces = 0;
	total_num_verts = 0;
	total_num_mcoords = 0;
	total_num_indices = 0;
	num_maps = 0;
	num_materials = 0;	
	g_scale = 1.0f;

	PrintMessage("C3DS::Load3dsModel - Loading :", filename);

	material_list = new char*[MAX_NUM_3DS_TEXTURES];
	
	for(i = 0; i < MAX_NUM_3DS_TEXTURES; i++)
	{
		material_list[i] = new char[MAX_NAME_LENGTH];
		material_list[i][0] = 0;
	}


	mapnames = new char*[MAX_NUM_3DS_TEXTURES];
	
	for(i = 0; i < MAX_NUM_3DS_TEXTURES; i++)
	{
		mapnames[i] = new char[MAX_NAME_LENGTH];
		mapnames[i][0] = 0;
	}



	if ((fp = fopen(filename, "rb")) == 0) 
	{
		PrintMessage("C3DS::Load3dsModel ERROR Can't open ",filename);
		return FALSE;
	}


	if ((logfile = fopen("3dslogfile.txt", "w")) == 0) 
	{
		PrintMessage("C3DS::Load3dsModel ERROR Can't open 3dslogfile.txt for writing",NULL);
		return FALSE;
	}
	
	if(bEnable3dsLogfile)
	{
		fprintf(logfile, "3DS Logfile generated by 3DS View\n");
		fprintf(logfile, "3DS Model filename %s\n\n", filename);

		fprintf(logfile, "This logfile lets you see what's in a 3ds binary file\n");
		fprintf(logfile, "and helps you debug any further code you add to this sample\n\n");
	}


	done = 0;

	while (done == 0)
	{
		process_data_flag  = FALSE;
		command_found_flag = FALSE;

		fread(&command, sizeof(command), 1, fp);
		
		// Test for end of file

		if (feof(fp))
		{
			done = 1;
			break;
		}
		
		fread (&length, sizeof(length), 1, fp);
		data_length = length - 6;

		// Process 3DS file commands


		switch (command)
		{
			// COMMANDS FOUND AT START OF 3DS FILE
			case MAIN3DS:
				PrintLogFile(logfile, "MAIN3DS");
				process_data_flag = TRUE;	
				break;

			case M3DS_VERSION:
				Process3DSVersion(fp);
				process_data_flag = TRUE;
				break;

			case EDIT3DS:
				PrintLogFile(logfile, "EDIT3DS");
				process_data_flag = TRUE;	
				break;

			case MESH_VERSION:
				PrintLogFile(logfile, "MESH_VERSION");
				break;

			//////////////////////////////////////////////

			// MATERIAL AND TEXTURE DEFINTION COMMANDS
			// this block of commands is repeated for each material / texture

			case EDIT_MATERIAL: // start of material definition 
				PrintLogFile(logfile, "\nEDIT_MATERIAL");	
				process_data_flag = TRUE;
				break;

			case MAT_NAME01:
				AddMaterialName(fp);
				process_data_flag = TRUE;
				break;

			case MATERIAL_AMBIENT:
				PrintLogFile(logfile, "MATERIAL_AMBIENT");
				break;

			case MATERIAL_DIFFUSE:
				PrintLogFile(logfile, "MATERIAL_DIFFUSE");
				break;

			case MATERIAL_SPECULAR:
				PrintLogFile(logfile, "MATERIAL_SPECULAR");
				break;

			case MATERIAL_SHININESS:
				PrintLogFile(logfile, "MATERIAL_SHININESS");
				break;

			case MATERIAL_SHIN_STRENGTH:
				PrintLogFile(logfile, "MATERIAL_SHIN_STRENGTH");
				break;
		
			case TRANS_PERCENT:
				PrintLogFile(logfile, "TRANS_PERCENT");
				break;

			case TRANS_FALLOFF_PERCENT:
				PrintLogFile(logfile, "TRANS_FALLOFF_PERCENT");
				break;

			case REFLECTION_BLUR_PER:
				PrintLogFile(logfile, "REFLECTION_BLUR_PER");
				break;

			case RENDER_TYPE:
				PrintLogFile(logfile, "RENDER_TYPE");
				break;
     
			case SELF_ILLUM:
				PrintLogFile(logfile, "SELF_ILLUM");
				break;
				
			case IN_TRANC:
				PrintLogFile(logfile, "IN_TRANC");
				break;

			case SOFTEN:
				PrintLogFile(logfile, "SOFTEN");
				break;

			case WIRE_THICKNESS:
				PrintLogFile(logfile, "WIRE_THICKNESS");
				break;

			case TEXTURE_MAP:
				PrintLogFile(logfile, "TEXTURE_MAP");	
				process_data_flag = TRUE;
				break;
			
			case INT_PERCENTAGE:
				PrintLogFile(logfile, "INT_PERCENTAGE");	
				break;

			case MAPPING_NAME:
				AddMapName(fp);
				process_data_flag = TRUE;
				break;
			
			case MAPPING_PARAMETERS:
				PrintLogFile(logfile, "MAPPING_PARAMETERS");
				break;
				
			case BLUR_PERCENTAGE:
				PrintLogFile(logfile, "BLUR_PERCENTAGE");
				break;

			/////////////////////////////////////////////

			case MASTER_SCALE:
				ProcessMasterScale(fp);
				process_data_flag = TRUE;
				break;		

			/////////////////////////////////////////////

			// 3D OBJECT DATA
			// This block of commands is repeated for each 3ds object
			// Note a 3ds model may contain just one, or many 3ds objects
			// Each object contains a vert, face, and texture co-ordinate list.

			case NAMED_OBJECT: // start of a 3d object chunk
				
				// read name and store
				
				total_num_objects++;
				
				// initialise object  
				oblist[total_num_objects].verts = NULL;
				oblist[total_num_objects].texverts = NULL;
				oblist[total_num_objects].faces = NULL;
				oblist[total_num_objects].numverts = 0;
				oblist[total_num_objects].numtexverts = 0;
				oblist[total_num_objects].numfaces = 0;

				for(i = 0; i < MAX_NAME_LENGTH; i++)
				{
					fread (&temp, 1, 1, fp); 
					
					if(total_num_objects >= MAX_NUM_3DS_OBJECTS )
						return FALSE;

					oblist[total_num_objects].object_name[i] = temp;
					data_length--;
				
					if(temp == 0)
					{
						if(bEnable3dsLogfile)
						{
							fprintf(logfile, "\n\n%s %s\n", "NAMED_OBJECT ", 
								oblist[total_num_objects].object_name);
						}
		
						break;
					}
				}
				process_data_flag = TRUE;
				break;

			
			case TRIANGLE_MESH:  // start of mesh data chunks
				PrintLogFile(logfile, "TRIANGLE_MESH");
				process_data_flag = TRUE;	
				break;

			case TRIANGLE_VERTEXLIST:  // vertex list
				if(ProcessVertexData(fp) == TRUE)
					process_data_flag = TRUE;
				else
				{
					PrintMessage("Too many verts in model", NULL);
					return FALSE;
				}
				break;

			case TRIANGLE_MAPPINGCOORS: // texture mapping co-ordinates
				ProcessMappingData(fp);
				process_data_flag = TRUE;
				break;

			case TRI_LOCAL:
				PrintLogFile(logfile, "TRI_LOCAL");
				ProcessTriLocalData(fp);
				process_data_flag = TRUE;	
				break;

			case TRIANGLE_FACELIST:  // face list
				if(ProcessFaceData(fp) == TRUE)
					process_data_flag = TRUE;
				else
				{
					PrintMessage("Too many faces in model", NULL);
					return FALSE;
				}
				break;
			
			case TRIANGLE_MATERIAL: // texture info for faces
				ProcessTriangleMaterialData(fp);
				process_data_flag = TRUE;
				break;

			case TRIANGLE_SMOOTH:
				PrintLogFile(logfile, "TRIANGLE_SMOOTH");
				ProcessTriSmoothData(fp);
				process_data_flag = TRUE;	
				break;

			case TRIANGLE_MAPPINGSTANDARD:
				PrintLogFile(logfile, "TRIANGLE_MAPPINGSTANDARD");
				break;	

			case TRIANGLE_VERTEXOPTIONS:
				PrintLogFile(logfile, "TRIANGLE_VERTEXOPTIONS");
				break;
	
			case TRI_VISIBLE:
				PrintLogFile(logfile, "TRI_VISIBLE");
				break;

			/////////////////////////////////////////////

			// ANIMATION DATA
			// this chunk and all keyframe sub chunks are being ignored in this sample
			case KEYFRAME:
				PrintLogFile(logfile, "\n\nKEYFRAME");
				//process_data_flag = TRUE;
				break;
		
			break;
		} // end switch


		if(process_data_flag == FALSE)
		{
			if(command_found_flag == FALSE)
			{
				if(bEnable3dsLogfile)
				{
					fprintf(logfile, "\n");
					fprintf(logfile, "%s  %x\n", "UNKNOWN COMMAND ", command);
				}
			}
			// command was unrecognised, so skip it's data
			
			for(i = 0; i < data_length; i++)
			{
				fread (&temp, 1, 1, fp);
			}
			data_length = 0;
		}

	} // end while
	
	fclose (fp);
	
	total_num_objects++;


	
	// Transfer data from oblist list into the model structure
	// and allocate memory dynamically for model

	int v, f, t;
 
	// initialise model
	model->Objects = NULL;
	model->NumObjects = 0;
	
	model->Objects = new OBJECT3DS[total_num_objects];

	for(i = 0; i < total_num_objects; i++)
	{
		// initialise object  
		model->Objects[i].verts    = NULL;
		model->Objects[i].faces    = NULL;
		model->Objects[i].texverts = NULL;
		model->Objects[i].numverts    = 0;
		model->Objects[i].numfaces    = 0;
		model->Objects[i].numtexverts = 0;
		model->Objects[i].texturename[0] = 0;
		model->Objects[i].object_name[0] = 0;

		strcpy(model->Objects[i].object_name, oblist[i].object_name);

		model->Objects[i].verts = new VERT3DS[oblist[i].numverts];
		model->Objects[i].numverts = oblist[i].numverts;

		for(v = 0; v < oblist[i].numverts; v++)
		{
			model->Objects[i].verts[v].x = oblist[i].verts[v].x;
			model->Objects[i].verts[v].y = oblist[i].verts[v].y;
			model->Objects[i].verts[v].z = oblist[i].verts[v].z;
		}

		model->Objects[i].faces = new FACE3DS[oblist[i].numfaces];
		model->Objects[i].numfaces = oblist[i].numfaces;
		
		
		for(f = 0; f < oblist[i].numfaces; f++)
		{
			// first three are indices of triangles
			model->Objects[i].faces[f].indices[0] = oblist[i].faces[f].indices[0];
			model->Objects[i].faces[f].indices[1] = oblist[i].faces[f].indices[1];
			model->Objects[i].faces[f].indices[2] = oblist[i].faces[f].indices[2];

			// this one contains 3ds flags
			model->Objects[i].faces[f].indices[3] = oblist[i].faces[f].indices[3];

			model->Objects[i].faces[f].tex = oblist[i].faces[f].tex;
		}

		model->Objects[i].texverts = new MAPPING_COORDINATES[oblist[i].numtexverts];
		model->Objects[i].numtexverts = oblist[i].numtexverts;

		for(t = 0; t < oblist[i].numtexverts; t++)
		{
			model->Objects[i].texverts[t].x = oblist[i].texverts[t].x;
			model->Objects[i].texverts[t].y = oblist[i].texverts[t].y;
		}
	}
	
	model->NumObjects  = total_num_objects;
	model->NumTextures = num_maps;

	PrintMessage("C3DS::Load3dsModel - Num Objects     = ", ITOA(total_num_objects) );
	PrintMessage("C3DS::Load3dsModel - Num Verts       = ", ITOA(total_num_verts) );
	PrintMessage("C3DS::Load3dsModel - Num Faces       = ", ITOA(total_num_faces) );
	PrintMessage("C3DS::Load3dsModel - Num Indices     = ", ITOA(total_num_faces * 3) );
	PrintMessage("C3DS::Load3dsModel - Num Tex Coords. = ", ITOA(total_num_mcoords) );
	PrintMessage("C3DS::Load3dsModel - Num Materials   = ", ITOA(num_materials) );
	PrintMessage("C3DS::Load3dsModel - Num Textures    = ", ITOA(num_maps) );

	fprintf(logfile, "\n\nEND FILE");
	fclose(logfile);


	if(Loading3DSModelForFirstTime == FALSE)
		Loading3DSModelForFirstTime = FALSE;

	Loading3DSModelForFirstTime = FALSE;
	return TRUE;
}



// PROCESS TRIANGLE DATA ROUTINES


// Read in vertex list from file
BOOL C3DS::ProcessVertexData(FILE *fp)
{
	int	i;
	int temp_int;
	float p, temp_float;
	unsigned short num_vertices;

	fread(&num_vertices, sizeof(num_vertices), 1, fp);
	
	if((total_num_verts + num_vertices) >= MAX_NUM_3DS_VERTICES)
		return FALSE;
			
	oblist[total_num_objects].numverts = (short)num_vertices;

	// test for dummy 3ds object
	if(num_vertices == 0)
	{
		PrintMessage("C3DS::ProcessVertexData - Warning dummy object detected", NULL);
		return TRUE;
	}

	
	oblist[total_num_objects].verts    = new VERT3DS[num_vertices];

	// allocate some memory for texture mapping data now, 
	// in case no mapping data is found. 
	oblist[total_num_objects].texverts = new MAPPING_COORDINATES[num_vertices];

	oblist[total_num_objects].numverts = (short)num_vertices;

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %d\n", "TRIANGLE_VERTEXLIST", num_vertices);


	for (i = 0; i < (int)num_vertices; i++)
	{
		fread(&p, sizeof(float), 1, fp);
		temp_int = (int)( ((p * (float)10000) + (float)0.5));
		temp_float = (float)temp_int / (float)10000;
		oblist[total_num_objects].verts[i].x = g_scale * temp_float;	
		
		fread(&p, sizeof(float), 1, fp);
		temp_int = (int)( ((p * (float)10000) + (float)0.5));
		temp_float = (float)temp_int / (float)10000;
		oblist[total_num_objects].verts[i].y = g_scale * temp_float;	

		fread(&p, sizeof(float), 1, fp);
		temp_int = (int)( ((p * (float)10000) + (float)0.5));
		temp_float = (float)temp_int / (float)10000;
		oblist[total_num_objects].verts[i].z = g_scale * temp_float;	

		if(bEnable3dsLogfile)
		{
			fprintf(logfile, " %f %f %f\n", 
				oblist[total_num_objects].verts[i].x,
				oblist[total_num_objects].verts[i].y,
				oblist[total_num_objects].verts[i].z);
		}

		// set default mapping co-ordinates, in case none are defined in object
		oblist[total_num_objects].texverts[i].x = 0.0f;
		oblist[total_num_objects].texverts[i].y = 0.0f;
		
		total_num_verts++;
	}	
	
	return TRUE;
}

// Read in Face list from file
BOOL C3DS::ProcessFaceData(FILE *fp)
{

	int	i, j, cnt = 0;
	unsigned short num_faces, face_index, ftemp;


	fread(&num_faces, sizeof(num_faces), 1, fp);

	if((total_num_faces + num_faces) >= MAX_NUM_3DS_FACES)
		return FALSE;

	oblist[total_num_objects].numfaces = (short)num_faces;
	
	// test for dummy 3ds object
	if(num_faces == 0)
		return TRUE;

	oblist[total_num_objects].faces = new FACE3DS[(int)num_faces];
	

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %d\n", "TRIANGLE_FACELIST ", num_faces);
			

	for (i = 0; i < (int)num_faces; i++)
	{
		// set texture for face at 0 in case this 3ds object 
		// contains no map / material data

		oblist[total_num_objects].faces[i].tex = 0;

		for (j = 0; j < 4; j++)
		{
			fread(&face_index, sizeof(face_index), 1, fp);
			
			// note faces 1 to 3 are valid face indices, but the 4th one is NOT
			if(j < 3)
			{
				ftemp = (unsigned short)(face_index);
				oblist[total_num_objects].faces[i].indices[j] = ftemp;
				if(bEnable3dsLogfile)
					fprintf(logfile, " %d", face_index);
			}
			else
			{
				if(bEnable3dsLogfile)
				{
					fprintf(logfile, "   flags: %d => ", face_index);

					if((face_index & 0x0001) == 0x0001) 
						fprintf(logfile, "  AC: 1");
					else
						fprintf(logfile, "  AC: 0");


					if((face_index & 0x0002) == 0x0002) 
						fprintf(logfile, "  BC: 1");
					else
						fprintf(logfile, "  BC: 0");


					if((face_index & 0x0004) == 0x0004) 
						fprintf(logfile, "  AB: 1");
					else
						fprintf(logfile, "  AB: 0");
				}
			}
		}
		total_num_faces++;

		if(bEnable3dsLogfile)
			fprintf(logfile, "\n");
	}
	
	return TRUE;
}


// PROCESS TEXTURE, MATERIAL, AND MAPPING DATA ROUTINES

// Read in new texture name from file
void C3DS::AddMapName(FILE *fp)
{
	int	i; 
	BOOL error = TRUE;
	char map_name[256];

	// read in map name from file
	for (i = 0; i < 256; i++)
	{
		fread(&map_name[i], sizeof(char), 1, fp);
		if(map_name[i] == 0)
			break;
	}

	// remove file extention from string and
	// replace with .bmp.
	// Most likely the texture format list in the 
	// 3ds file will be a jpg, and we're gonna be 
	// using bmp files only. 

	for (i = 0; i < 256; i++)
	{	
		if(map_name[i] == '.')
		{
			map_name[i] = 0;
			strcat(&map_name[i], ".bmp");
			break;
		}
	}

	// search for texture name, if it's already there leave this function
	for (i = 0; i < num_maps; i++)
	{
		if(strcmpi(map_name, mapnames[i]) == 0)
		{
			PrintMessage("C3DS::AddMapName - map already loaded ", map_name);
			return;
		}
	}

	// add the new texture name to the list
	strcpy(mapnames[num_maps], map_name);

	// load the bitmap  
	if( D3DTextr_CreateTextureFromFile(map_name) != S_OK )
		PrintMessage("Couldn't load texture : ", map_name);
	else
		PrintMessage("C3DS::AddMapName - loaded ", map_name);

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %s\n", "MAPPING_NAME ", mapnames[num_maps]); 
	num_maps++;

}

// Read in new material name from file
void C3DS::AddMaterialName(FILE *fp)
{	
	int	i; 
	BOOL error = TRUE;
	char mat_name[256];

	// Read in material name
	for (i = 0; i < 256; i++)
	{
		fread(&mat_name[i], sizeof(char), 1, fp);
		if(mat_name[i] == 0)
		{
			error = FALSE;
			break;
		}
	}

	if(error == TRUE)
	{
		PrintMessage("C3DS::AddMaterialName - FAILED", NULL);
		strcpy(material_list[num_materials], "error");
		return;
	}

	if(bEnable3dsLogfile)
		fprintf(logfile,"MAT_NAME01  %s\n",mat_name);
	strcpy(material_list[num_materials], mat_name);
	num_materials++;
}


// This function will be called once for each texture a 
// 3ds object uses. 

void C3DS::ProcessTriangleMaterialData(FILE *fp)
{
	int	i; 
	short findex;
	short current_texture = 0;
	unsigned short num_faces;
	BOOL error = TRUE;
	char mat_name[256];


	// read in the materials name from file
	for (i = 0; i < 256; i++)
	{
		fread(&mat_name[i], sizeof(char), 1, fp);
		if(mat_name[i] == 0)
			break;
	}

	// Get the material's number. This number will also be used 
	// as the current texture number
	for (i = 0; i < num_maps; i++) 
	{
		if(strcmpi(mat_name, material_list[i]) == 0)
		{
			current_texture = i;

			if((current_texture < 0) || (current_texture > MAX_NUM_3DS_TEXTURES))
			{
				PrintMessage("C3DS::ProcessMaterialData - current_texture is out of bounds", NULL);
				current_texture = 0;
			}
			
			error = FALSE;
			break;
		}
	}

	// If we couldn't find the material name use the first one on the list
	// so we can at least see the polygons rendered with some texture.
	if(error == TRUE)
	{
		current_texture = 0;
		PrintMessage("Error : ProcessMaterialData couldn't find ", mat_name);
		strcpy(material_list[num_materials], "error");
	}

	// read a list of faces, these faces will be given this 
	// material / texture number
	fread(&num_faces, sizeof(num_faces), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, "TRIANGLE_MATERIAL `%s` %d\n", mat_name, num_faces);
	

	for (i = 0; i < num_faces; i++)
	{
		fread(&findex, sizeof(short), 1, fp);
		oblist[total_num_objects].faces[findex].tex = current_texture;
	
		if(bEnable3dsLogfile)
			fprintf(logfile, " %d   %d\n", i, oblist[total_num_objects].faces[i].tex);
	}

	return;
}

// Read in texture mapping co-ordinates from file
void C3DS::ProcessMappingData(FILE *fp)
{
	int	i; 
	unsigned short num_mapping_coords;
	
	
	fread(&num_mapping_coords, sizeof(num_mapping_coords), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, "%s %d\n", "TRIANGLE_MAPPINGCOORS ", num_mapping_coords);

	for (i = 0; i < num_mapping_coords; i++)
	{
		fread(&oblist[total_num_objects].texverts[i].x, sizeof(float), 1, fp);
		fread(&oblist[total_num_objects].texverts[i].y, sizeof(float), 1, fp);

		if(bEnable3dsLogfile)
		{
			fprintf(logfile, " %f %f\n", 
				oblist[total_num_objects].texverts[i].x,
				oblist[total_num_objects].texverts[i].y);
		}
		total_num_mcoords++;
	}

	oblist[total_num_objects].numtexverts = num_mapping_coords;

	return;
}


void C3DS::ProcessTriSmoothData(FILE *fp)
{
	int i, num_faces;
	BYTE a,b,c,d;

	// Just read in this data, and ignore
	// it's not useful for this sample
	num_faces = oblist[total_num_objects].numfaces; 

	for(i = 0;  i < num_faces; i++)
	{
		fread(&a, sizeof(BYTE), 1, fp);
		fread(&b, sizeof(BYTE), 1, fp);
		fread(&c, sizeof(BYTE), 1, fp);
		fread(&d, sizeof(BYTE), 1, fp);

		if(bEnable3dsLogfile)
			fprintf(logfile, " a,b,c,d : %d %d %d %d\n", a, b, c, d);
	}
}

void C3DS::ProcessTriLocalData(FILE *fp)
{
	float x,y,z;
	float local_centre_x, local_centre_y, local_centre_z;

	// We're ignoring this data as it isn't useful
	// to rendering the model in this sample. 
	// Dump to logfile anyway.

	fread(&x, sizeof(float), 1, fp);
	fread(&y, sizeof(float), 1, fp);
	fread(&z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, " x,y,z: %f %f %f\n", x, y, z);
		
	fread(&x, sizeof(float), 1, fp);
	fread(&y, sizeof(float), 1, fp);
	fread(&z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, " x,y,z: %f %f %f\n", x, y, z);
	
	fread(&x, sizeof(float), 1, fp);
	fread(&y, sizeof(float), 1, fp);
	fread(&z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
		fprintf(logfile, " x,y,z: %f %f %f\n", x, y, z);
	
	fread(&local_centre_x, sizeof(float), 1, fp);
	fread(&local_centre_y, sizeof(float), 1, fp);
	fread(&local_centre_z, sizeof(float), 1, fp);

	if(bEnable3dsLogfile)
	{
		fprintf(logfile, " local_centre_x,y,z : %f %f %f\n", 
			local_centre_x, local_centre_y, local_centre_z);
	}
}


void C3DS::Process3DSVersion(FILE *fp)
{
	short version;

	// 3DS File Version
	fread(&version, sizeof(short), 1, fp);
	if(bEnable3dsLogfile)
		fprintf(logfile, "3DS VERSION %d\n",version);
	fread(&version, sizeof(short), 1, fp);
}

void C3DS::ProcessMasterScale(FILE *fp)
{
	float master_scale;

	// Overall scale of a 3ds scene
	fread(&master_scale, sizeof(float), 1, fp);
	if(bEnable3dsLogfile)
		fprintf(logfile, "MASTER_SCALE %f\n",master_scale);	
}




// RENDER A 3DS MODEL

BOOL C3DS::Render3DSModel( LPDIRECT3DDEVICE7 m_pd3dDevice, 
						   float wx, float wy, float wz, 
						   float rotation_angle,
						   int frame_num,
						   k3DSMODEL *model )
{
	LPDIRECTDRAWSURFACE7 current_texture;
	FILE *fp;
	int i, v, f, icnt, vcnt;
	float x, y, z;
	float tu,tv;
	float sine, cosine;
	float scale = 0.05f;
	char current_texture_name[10];
	

	if(Rendering3DSModelForFirstTime)
	{
		fp = fopen("3dsRender.txt", "w+"); 
		fprintf(fp, "This logfile records what data is passed\n");
		fprintf(fp, "to the DrawPrimitive function\n\n");
	}

	// work out the cosine and sine of the rotation angle about the y axis
	// in advance to speed things up a little in the rendering loop.
	sine   = (float)sin(rotation_angle * 0.017453292f);
	cosine = (float)cos(rotation_angle * 0.017453292f);

	// render all 3ds object in the model
	for(i = 0; i < model->NumObjects; i++)
	{
		// Render a 3ds object
		for(f = 0; f < model->Objects[i].numfaces ; f++)
		{
			// render a triangle
			vcnt = 0;

			for(icnt = 0; icnt < 3 ; icnt++)
			{
				v = model->Objects[i].faces[f].indices[icnt];

				// scale model, and swap y and z vertex components
				// 3ds uses a different 3d axes system than this program
				// so we need to convert.
				x = scale * model->Objects[i].verts[v].x;
				z = scale * model->Objects[i].verts[v].y;
				y = scale * model->Objects[i].verts[v].z;

				tu = model->Objects[i].texverts[v].x;
				tv = model->Objects[i].texverts[v].y;

				// load up Draw Primitive's vertex list
				src_v[vcnt].x  = wx + (x*cosine - z*sine); 
				src_v[vcnt].y  = wy + y;
				src_v[vcnt].z  = wz + (x*sine + z*cosine);
				src_v[vcnt].tu = tu; 
				src_v[vcnt].tv = tv; 

				// write some debug info to help with debugging
				// of any new code added later on.
				if(Rendering3DSModelForFirstTime)
				{
					fprintf(fp, "%d : x = %f, y = %f, z = %f, tu = %f, tv = %f\n",
							vcnt, x, y, z, tu, tv);
				}
					
				vcnt++;
			} // end for icnt

			fprintf(fp, "\n");

			// Set the correct texture for this triangle
			strcpy(current_texture_name, mapnames[model->Objects[i].faces[f].tex]);
			current_texture = D3DTextr_GetSurface( current_texture_name );
			m_pd3dDevice->SetTexture( 0, current_texture );

			// Direct3D will now transfer this info to the 3d card
			if (m_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 
										D3DFVF_VERTEX, 
										(LPVOID)&src_v, 
										(DWORD)vcnt, 
										NULL) != D3D_OK) 
			{
				Rendering3DSModelForFirstTime = FALSE;
				PrintMessage("3DS::Render3DSModel - DrawPrimitive FAILED", NULL);	
				if(Rendering3DSModelForFirstTime)
					fclose (fp);
				return FALSE;
			}

		} // end for f
	}

	if(Rendering3DSModelForFirstTime)
	{
		fprintf(fp, "\nEND FILE\n");
		fclose (fp);
	}

	Rendering3DSModelForFirstTime = FALSE;

	return TRUE;
}




// RELEASE AND DEBUG ROUTINES

void C3DS::ReleaseTempMemory()
{
	int i;

	for(i = 0; i < total_num_objects; i++)
	{
		SAFE_DELETE_ARRAY(oblist[i].verts);
		SAFE_DELETE_ARRAY(oblist[i].faces);
		SAFE_DELETE_ARRAY(oblist[i].texverts);
	}

	for(i = 0; i < MAX_NUM_3DS_TEXTURES; i++)
		SAFE_DELETE_ARRAY(material_list[i]);

	SAFE_DELETE(material_list);


	for(i = 0; i < MAX_NUM_3DS_TEXTURES; i++)
		SAFE_DELETE_ARRAY(mapnames[i]);

	SAFE_DELETE(mapnames);
}

void C3DS::Release3DSModel(k3DSMODEL* model)
{
	int i;

	PrintMessage("C3DS::Release3DSModel - Releasing 3ds model", NULL);

	for(i = 0; i < total_num_objects; i++)
	{
		SAFE_DELETE_ARRAY(model->Objects[i].verts);
		SAFE_DELETE_ARRAY(model->Objects[i].faces);
		SAFE_DELETE_ARRAY(model->Objects[i].texverts);
	}
	SAFE_DELETE_ARRAY(model->Objects);

	for(i = 0; i < num_maps; i++)
	{
		D3DTextr_DestroyTexture(mapnames[i]);
		PrintMessage("C3DS::Release3DSModel - Destroyed Texture :", mapnames[i]);
	}
						
}


void C3DS::PrintLogFile(FILE *logfile, char *commmand)
{
	if(bEnable3dsLogfile)
	{
		fprintf(logfile, commmand);
		fprintf(logfile,"\n");
	}
	command_found_flag = TRUE;
}


void C3DS::Write_k3dsmodel_debugfile(k3DSMODEL *model)
{
	FILE *fp;
	int i, v, f, t;

	if ((fp = fopen("3dsmodel.txt", "w")) == 0) 
	{
		PrintMessage("Can't open 3dsmodel.txt for writing", NULL);
		return;
	}

	fprintf(fp, "This logfile lets you check if data has been sucessfully\n");
	fprintf(fp, "transfered from the oblist structure to the 3dsmodel structure\n\n");
	
	fprintf(fp, "Number of 3ds objects %d\n\n",model->NumObjects);
	
	for(i = 0; i < model->NumObjects; i++)
	{
		fprintf(fp, "\n\nObject # %d\n",i);

		fprintf(fp, "VERT LIST %d\n", model->Objects[i].numverts);

		for(v = 0; v < model->Objects[i].numverts; v++)
		{
			fprintf(fp, "%d : x = %f, y = %f, z = %f\n",
					v,
					model->Objects[i].verts[v].x,
					model->Objects[i].verts[v].y,
					model->Objects[i].verts[v].z);
		}


		fprintf(fp, "FACE LIST %d\n", model->Objects[i].numfaces);

		for(f = 0; f < model->Objects[i].numfaces; f++)
		{
			fprintf(fp, "%d : A = %d, B = %d, C = %d, Texture = %d\n",
					f,
					model->Objects[i].faces[f].indices[0],
					model->Objects[i].faces[f].indices[1],
					model->Objects[i].faces[f].indices[2], 
					model->Objects[i].faces[f].tex);
		}


		fprintf(fp, "TEXTURE VERT LIST %d\n", model->Objects[i].numtexverts);
	
		for(t = 0; t < model->Objects[i].numtexverts; t++)
		{
			fprintf(fp, "%d : x = %f, y = %f\n",
					t,
					model->Objects[i].texverts[t].x,
					model->Objects[i].texverts[t].y);
		}
	}
	
	model->NumObjects = total_num_objects;
	
	fprintf(fp, "\nEND FILE\n");	
	fclose (fp);
}
